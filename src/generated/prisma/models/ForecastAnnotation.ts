
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ForecastAnnotation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model ForecastAnnotation
 * 
 */
export type ForecastAnnotationModel = runtime.Types.Result.DefaultSelection<Prisma.$ForecastAnnotationPayload>

export type AggregateForecastAnnotation = {
  _count: ForecastAnnotationCountAggregateOutputType | null
  _min: ForecastAnnotationMinAggregateOutputType | null
  _max: ForecastAnnotationMaxAggregateOutputType | null
}

export type ForecastAnnotationMinAggregateOutputType = {
  id: string | null
  content: string | null
  authorId: string | null
  authorName: string | null
  lineItemId: string | null
  periodId: string | null
  revenueForecastId: string | null
  costForecastId: string | null
  cashForecastId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ForecastAnnotationMaxAggregateOutputType = {
  id: string | null
  content: string | null
  authorId: string | null
  authorName: string | null
  lineItemId: string | null
  periodId: string | null
  revenueForecastId: string | null
  costForecastId: string | null
  cashForecastId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ForecastAnnotationCountAggregateOutputType = {
  id: number
  content: number
  authorId: number
  authorName: number
  lineItemId: number
  periodId: number
  revenueForecastId: number
  costForecastId: number
  cashForecastId: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type ForecastAnnotationMinAggregateInputType = {
  id?: true
  content?: true
  authorId?: true
  authorName?: true
  lineItemId?: true
  periodId?: true
  revenueForecastId?: true
  costForecastId?: true
  cashForecastId?: true
  createdAt?: true
  updatedAt?: true
}

export type ForecastAnnotationMaxAggregateInputType = {
  id?: true
  content?: true
  authorId?: true
  authorName?: true
  lineItemId?: true
  periodId?: true
  revenueForecastId?: true
  costForecastId?: true
  cashForecastId?: true
  createdAt?: true
  updatedAt?: true
}

export type ForecastAnnotationCountAggregateInputType = {
  id?: true
  content?: true
  authorId?: true
  authorName?: true
  lineItemId?: true
  periodId?: true
  revenueForecastId?: true
  costForecastId?: true
  cashForecastId?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type ForecastAnnotationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ForecastAnnotation to aggregate.
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ForecastAnnotations to fetch.
   */
  orderBy?: Prisma.ForecastAnnotationOrderByWithRelationInput | Prisma.ForecastAnnotationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ForecastAnnotationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ForecastAnnotations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ForecastAnnotations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ForecastAnnotations
  **/
  _count?: true | ForecastAnnotationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ForecastAnnotationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ForecastAnnotationMaxAggregateInputType
}

export type GetForecastAnnotationAggregateType<T extends ForecastAnnotationAggregateArgs> = {
      [P in keyof T & keyof AggregateForecastAnnotation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateForecastAnnotation[P]>
    : Prisma.GetScalarType<T[P], AggregateForecastAnnotation[P]>
}




export type ForecastAnnotationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ForecastAnnotationWhereInput
  orderBy?: Prisma.ForecastAnnotationOrderByWithAggregationInput | Prisma.ForecastAnnotationOrderByWithAggregationInput[]
  by: Prisma.ForecastAnnotationScalarFieldEnum[] | Prisma.ForecastAnnotationScalarFieldEnum
  having?: Prisma.ForecastAnnotationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ForecastAnnotationCountAggregateInputType | true
  _min?: ForecastAnnotationMinAggregateInputType
  _max?: ForecastAnnotationMaxAggregateInputType
}

export type ForecastAnnotationGroupByOutputType = {
  id: string
  content: string
  authorId: string
  authorName: string
  lineItemId: string | null
  periodId: string | null
  revenueForecastId: string | null
  costForecastId: string | null
  cashForecastId: string | null
  createdAt: Date
  updatedAt: Date
  _count: ForecastAnnotationCountAggregateOutputType | null
  _min: ForecastAnnotationMinAggregateOutputType | null
  _max: ForecastAnnotationMaxAggregateOutputType | null
}

type GetForecastAnnotationGroupByPayload<T extends ForecastAnnotationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ForecastAnnotationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ForecastAnnotationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ForecastAnnotationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ForecastAnnotationGroupByOutputType[P]>
      }
    >
  >



export type ForecastAnnotationWhereInput = {
  AND?: Prisma.ForecastAnnotationWhereInput | Prisma.ForecastAnnotationWhereInput[]
  OR?: Prisma.ForecastAnnotationWhereInput[]
  NOT?: Prisma.ForecastAnnotationWhereInput | Prisma.ForecastAnnotationWhereInput[]
  id?: Prisma.StringFilter<"ForecastAnnotation"> | string
  content?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorId?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorName?: Prisma.StringFilter<"ForecastAnnotation"> | string
  lineItemId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  periodId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  revenueForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  costForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  cashForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  createdAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
  revenueForecast?: Prisma.XOR<Prisma.RevenueForecastNullableScalarRelationFilter, Prisma.RevenueForecastWhereInput> | null
  costForecast?: Prisma.XOR<Prisma.CostForecastNullableScalarRelationFilter, Prisma.CostForecastWhereInput> | null
  cashForecast?: Prisma.XOR<Prisma.CashForecastNullableScalarRelationFilter, Prisma.CashForecastWhereInput> | null
}

export type ForecastAnnotationOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  authorId?: Prisma.SortOrder
  authorName?: Prisma.SortOrder
  lineItemId?: Prisma.SortOrderInput | Prisma.SortOrder
  periodId?: Prisma.SortOrderInput | Prisma.SortOrder
  revenueForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  costForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  cashForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  revenueForecast?: Prisma.RevenueForecastOrderByWithRelationInput
  costForecast?: Prisma.CostForecastOrderByWithRelationInput
  cashForecast?: Prisma.CashForecastOrderByWithRelationInput
}

export type ForecastAnnotationWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.ForecastAnnotationWhereInput | Prisma.ForecastAnnotationWhereInput[]
  OR?: Prisma.ForecastAnnotationWhereInput[]
  NOT?: Prisma.ForecastAnnotationWhereInput | Prisma.ForecastAnnotationWhereInput[]
  content?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorId?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorName?: Prisma.StringFilter<"ForecastAnnotation"> | string
  lineItemId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  periodId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  revenueForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  costForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  cashForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  createdAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
  revenueForecast?: Prisma.XOR<Prisma.RevenueForecastNullableScalarRelationFilter, Prisma.RevenueForecastWhereInput> | null
  costForecast?: Prisma.XOR<Prisma.CostForecastNullableScalarRelationFilter, Prisma.CostForecastWhereInput> | null
  cashForecast?: Prisma.XOR<Prisma.CashForecastNullableScalarRelationFilter, Prisma.CashForecastWhereInput> | null
}, "id">

export type ForecastAnnotationOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  authorId?: Prisma.SortOrder
  authorName?: Prisma.SortOrder
  lineItemId?: Prisma.SortOrderInput | Prisma.SortOrder
  periodId?: Prisma.SortOrderInput | Prisma.SortOrder
  revenueForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  costForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  cashForecastId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.ForecastAnnotationCountOrderByAggregateInput
  _max?: Prisma.ForecastAnnotationMaxOrderByAggregateInput
  _min?: Prisma.ForecastAnnotationMinOrderByAggregateInput
}

export type ForecastAnnotationScalarWhereWithAggregatesInput = {
  AND?: Prisma.ForecastAnnotationScalarWhereWithAggregatesInput | Prisma.ForecastAnnotationScalarWhereWithAggregatesInput[]
  OR?: Prisma.ForecastAnnotationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ForecastAnnotationScalarWhereWithAggregatesInput | Prisma.ForecastAnnotationScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"ForecastAnnotation"> | string
  content?: Prisma.StringWithAggregatesFilter<"ForecastAnnotation"> | string
  authorId?: Prisma.StringWithAggregatesFilter<"ForecastAnnotation"> | string
  authorName?: Prisma.StringWithAggregatesFilter<"ForecastAnnotation"> | string
  lineItemId?: Prisma.StringNullableWithAggregatesFilter<"ForecastAnnotation"> | string | null
  periodId?: Prisma.StringNullableWithAggregatesFilter<"ForecastAnnotation"> | string | null
  revenueForecastId?: Prisma.StringNullableWithAggregatesFilter<"ForecastAnnotation"> | string | null
  costForecastId?: Prisma.StringNullableWithAggregatesFilter<"ForecastAnnotation"> | string | null
  cashForecastId?: Prisma.StringNullableWithAggregatesFilter<"ForecastAnnotation"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"ForecastAnnotation"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"ForecastAnnotation"> | Date | string
}

export type ForecastAnnotationCreateInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  revenueForecast?: Prisma.RevenueForecastCreateNestedOneWithoutAnnotationsInput
  costForecast?: Prisma.CostForecastCreateNestedOneWithoutAnnotationsInput
  cashForecast?: Prisma.CashForecastCreateNestedOneWithoutAnnotationsInput
}

export type ForecastAnnotationUncheckedCreateInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  costForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  revenueForecast?: Prisma.RevenueForecastUpdateOneWithoutAnnotationsNestedInput
  costForecast?: Prisma.CostForecastUpdateOneWithoutAnnotationsNestedInput
  cashForecast?: Prisma.CashForecastUpdateOneWithoutAnnotationsNestedInput
}

export type ForecastAnnotationUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationCreateManyInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  costForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationListRelationFilter = {
  every?: Prisma.ForecastAnnotationWhereInput
  some?: Prisma.ForecastAnnotationWhereInput
  none?: Prisma.ForecastAnnotationWhereInput
}

export type ForecastAnnotationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ForecastAnnotationCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  authorId?: Prisma.SortOrder
  authorName?: Prisma.SortOrder
  lineItemId?: Prisma.SortOrder
  periodId?: Prisma.SortOrder
  revenueForecastId?: Prisma.SortOrder
  costForecastId?: Prisma.SortOrder
  cashForecastId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ForecastAnnotationMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  authorId?: Prisma.SortOrder
  authorName?: Prisma.SortOrder
  lineItemId?: Prisma.SortOrder
  periodId?: Prisma.SortOrder
  revenueForecastId?: Prisma.SortOrder
  costForecastId?: Prisma.SortOrder
  cashForecastId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ForecastAnnotationMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  authorId?: Prisma.SortOrder
  authorName?: Prisma.SortOrder
  lineItemId?: Prisma.SortOrder
  periodId?: Prisma.SortOrder
  revenueForecastId?: Prisma.SortOrder
  costForecastId?: Prisma.SortOrder
  cashForecastId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ForecastAnnotationCreateNestedManyWithoutRevenueForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput> | Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyRevenueForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUncheckedCreateNestedManyWithoutRevenueForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput> | Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyRevenueForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUpdateManyWithoutRevenueForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput> | Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutRevenueForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyRevenueForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutRevenueForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutRevenueForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationUncheckedUpdateManyWithoutRevenueForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput> | Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutRevenueForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyRevenueForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutRevenueForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutRevenueForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutRevenueForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationCreateNestedManyWithoutCostForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput> | Prisma.ForecastAnnotationCreateWithoutCostForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCostForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUncheckedCreateNestedManyWithoutCostForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput> | Prisma.ForecastAnnotationCreateWithoutCostForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCostForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUpdateManyWithoutCostForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput> | Prisma.ForecastAnnotationCreateWithoutCostForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCostForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCostForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCostForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCostForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCostForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCostForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCostForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationUncheckedUpdateManyWithoutCostForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput> | Prisma.ForecastAnnotationCreateWithoutCostForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCostForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCostForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCostForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCostForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCostForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCostForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCostForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCostForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationCreateNestedManyWithoutCashForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput> | Prisma.ForecastAnnotationCreateWithoutCashForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCashForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUncheckedCreateNestedManyWithoutCashForecastInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput> | Prisma.ForecastAnnotationCreateWithoutCashForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCashForecastInputEnvelope
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
}

export type ForecastAnnotationUpdateManyWithoutCashForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput> | Prisma.ForecastAnnotationCreateWithoutCashForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCashForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCashForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCashForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCashForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCashForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCashForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCashForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationUncheckedUpdateManyWithoutCashForecastNestedInput = {
  create?: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput> | Prisma.ForecastAnnotationCreateWithoutCashForecastInput[] | Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput[]
  connectOrCreate?: Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput | Prisma.ForecastAnnotationCreateOrConnectWithoutCashForecastInput[]
  upsert?: Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCashForecastInput | Prisma.ForecastAnnotationUpsertWithWhereUniqueWithoutCashForecastInput[]
  createMany?: Prisma.ForecastAnnotationCreateManyCashForecastInputEnvelope
  set?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  disconnect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  delete?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  connect?: Prisma.ForecastAnnotationWhereUniqueInput | Prisma.ForecastAnnotationWhereUniqueInput[]
  update?: Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCashForecastInput | Prisma.ForecastAnnotationUpdateWithWhereUniqueWithoutCashForecastInput[]
  updateMany?: Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCashForecastInput | Prisma.ForecastAnnotationUpdateManyWithWhereWithoutCashForecastInput[]
  deleteMany?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
}

export type ForecastAnnotationCreateWithoutRevenueForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  costForecast?: Prisma.CostForecastCreateNestedOneWithoutAnnotationsInput
  cashForecast?: Prisma.CashForecastCreateNestedOneWithoutAnnotationsInput
}

export type ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  costForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationCreateOrConnectWithoutRevenueForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput>
}

export type ForecastAnnotationCreateManyRevenueForecastInputEnvelope = {
  data: Prisma.ForecastAnnotationCreateManyRevenueForecastInput | Prisma.ForecastAnnotationCreateManyRevenueForecastInput[]
  skipDuplicates?: boolean
}

export type ForecastAnnotationUpsertWithWhereUniqueWithoutRevenueForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  update: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutRevenueForecastInput>
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutRevenueForecastInput>
}

export type ForecastAnnotationUpdateWithWhereUniqueWithoutRevenueForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutRevenueForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutRevenueForecastInput>
}

export type ForecastAnnotationUpdateManyWithWhereWithoutRevenueForecastInput = {
  where: Prisma.ForecastAnnotationScalarWhereInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateManyMutationInput, Prisma.ForecastAnnotationUncheckedUpdateManyWithoutRevenueForecastInput>
}

export type ForecastAnnotationScalarWhereInput = {
  AND?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
  OR?: Prisma.ForecastAnnotationScalarWhereInput[]
  NOT?: Prisma.ForecastAnnotationScalarWhereInput | Prisma.ForecastAnnotationScalarWhereInput[]
  id?: Prisma.StringFilter<"ForecastAnnotation"> | string
  content?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorId?: Prisma.StringFilter<"ForecastAnnotation"> | string
  authorName?: Prisma.StringFilter<"ForecastAnnotation"> | string
  lineItemId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  periodId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  revenueForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  costForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  cashForecastId?: Prisma.StringNullableFilter<"ForecastAnnotation"> | string | null
  createdAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"ForecastAnnotation"> | Date | string
}

export type ForecastAnnotationCreateWithoutCostForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  revenueForecast?: Prisma.RevenueForecastCreateNestedOneWithoutAnnotationsInput
  cashForecast?: Prisma.CashForecastCreateNestedOneWithoutAnnotationsInput
}

export type ForecastAnnotationUncheckedCreateWithoutCostForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationCreateOrConnectWithoutCostForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput>
}

export type ForecastAnnotationCreateManyCostForecastInputEnvelope = {
  data: Prisma.ForecastAnnotationCreateManyCostForecastInput | Prisma.ForecastAnnotationCreateManyCostForecastInput[]
  skipDuplicates?: boolean
}

export type ForecastAnnotationUpsertWithWhereUniqueWithoutCostForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  update: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutCostForecastInput>
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCostForecastInput>
}

export type ForecastAnnotationUpdateWithWhereUniqueWithoutCostForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutCostForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutCostForecastInput>
}

export type ForecastAnnotationUpdateManyWithWhereWithoutCostForecastInput = {
  where: Prisma.ForecastAnnotationScalarWhereInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateManyMutationInput, Prisma.ForecastAnnotationUncheckedUpdateManyWithoutCostForecastInput>
}

export type ForecastAnnotationCreateWithoutCashForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  revenueForecast?: Prisma.RevenueForecastCreateNestedOneWithoutAnnotationsInput
  costForecast?: Prisma.CostForecastCreateNestedOneWithoutAnnotationsInput
}

export type ForecastAnnotationUncheckedCreateWithoutCashForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  costForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationCreateOrConnectWithoutCashForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput>
}

export type ForecastAnnotationCreateManyCashForecastInputEnvelope = {
  data: Prisma.ForecastAnnotationCreateManyCashForecastInput | Prisma.ForecastAnnotationCreateManyCashForecastInput[]
  skipDuplicates?: boolean
}

export type ForecastAnnotationUpsertWithWhereUniqueWithoutCashForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  update: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutCashForecastInput>
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedCreateWithoutCashForecastInput>
}

export type ForecastAnnotationUpdateWithWhereUniqueWithoutCashForecastInput = {
  where: Prisma.ForecastAnnotationWhereUniqueInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateWithoutCashForecastInput, Prisma.ForecastAnnotationUncheckedUpdateWithoutCashForecastInput>
}

export type ForecastAnnotationUpdateManyWithWhereWithoutCashForecastInput = {
  where: Prisma.ForecastAnnotationScalarWhereInput
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateManyMutationInput, Prisma.ForecastAnnotationUncheckedUpdateManyWithoutCashForecastInput>
}

export type ForecastAnnotationCreateManyRevenueForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  costForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationUpdateWithoutRevenueForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  costForecast?: Prisma.CostForecastUpdateOneWithoutAnnotationsNestedInput
  cashForecast?: Prisma.CashForecastUpdateOneWithoutAnnotationsNestedInput
}

export type ForecastAnnotationUncheckedUpdateWithoutRevenueForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationUncheckedUpdateManyWithoutRevenueForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationCreateManyCostForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  cashForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationUpdateWithoutCostForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  revenueForecast?: Prisma.RevenueForecastUpdateOneWithoutAnnotationsNestedInput
  cashForecast?: Prisma.CashForecastUpdateOneWithoutAnnotationsNestedInput
}

export type ForecastAnnotationUncheckedUpdateWithoutCostForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationUncheckedUpdateManyWithoutCostForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  cashForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationCreateManyCashForecastInput = {
  id?: string
  content: string
  authorId: string
  authorName: string
  lineItemId?: string | null
  periodId?: string | null
  revenueForecastId?: string | null
  costForecastId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ForecastAnnotationUpdateWithoutCashForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  revenueForecast?: Prisma.RevenueForecastUpdateOneWithoutAnnotationsNestedInput
  costForecast?: Prisma.CostForecastUpdateOneWithoutAnnotationsNestedInput
}

export type ForecastAnnotationUncheckedUpdateWithoutCashForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ForecastAnnotationUncheckedUpdateManyWithoutCashForecastInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  content?: Prisma.StringFieldUpdateOperationsInput | string
  authorId?: Prisma.StringFieldUpdateOperationsInput | string
  authorName?: Prisma.StringFieldUpdateOperationsInput | string
  lineItemId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  periodId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  revenueForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  costForecastId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type ForecastAnnotationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  authorId?: boolean
  authorName?: boolean
  lineItemId?: boolean
  periodId?: boolean
  revenueForecastId?: boolean
  costForecastId?: boolean
  cashForecastId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}, ExtArgs["result"]["forecastAnnotation"]>

export type ForecastAnnotationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  authorId?: boolean
  authorName?: boolean
  lineItemId?: boolean
  periodId?: boolean
  revenueForecastId?: boolean
  costForecastId?: boolean
  cashForecastId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}, ExtArgs["result"]["forecastAnnotation"]>

export type ForecastAnnotationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  authorId?: boolean
  authorName?: boolean
  lineItemId?: boolean
  periodId?: boolean
  revenueForecastId?: boolean
  costForecastId?: boolean
  cashForecastId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}, ExtArgs["result"]["forecastAnnotation"]>

export type ForecastAnnotationSelectScalar = {
  id?: boolean
  content?: boolean
  authorId?: boolean
  authorName?: boolean
  lineItemId?: boolean
  periodId?: boolean
  revenueForecastId?: boolean
  costForecastId?: boolean
  cashForecastId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type ForecastAnnotationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "content" | "authorId" | "authorName" | "lineItemId" | "periodId" | "revenueForecastId" | "costForecastId" | "cashForecastId" | "createdAt" | "updatedAt", ExtArgs["result"]["forecastAnnotation"]>
export type ForecastAnnotationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}
export type ForecastAnnotationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}
export type ForecastAnnotationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  revenueForecast?: boolean | Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>
  costForecast?: boolean | Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>
  cashForecast?: boolean | Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>
}

export type $ForecastAnnotationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ForecastAnnotation"
  objects: {
    revenueForecast: Prisma.$RevenueForecastPayload<ExtArgs> | null
    costForecast: Prisma.$CostForecastPayload<ExtArgs> | null
    cashForecast: Prisma.$CashForecastPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    content: string
    authorId: string
    authorName: string
    lineItemId: string | null
    periodId: string | null
    revenueForecastId: string | null
    costForecastId: string | null
    cashForecastId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["forecastAnnotation"]>
  composites: {}
}

export type ForecastAnnotationGetPayload<S extends boolean | null | undefined | ForecastAnnotationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload, S>

export type ForecastAnnotationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ForecastAnnotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ForecastAnnotationCountAggregateInputType | true
  }

export interface ForecastAnnotationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForecastAnnotation'], meta: { name: 'ForecastAnnotation' } }
  /**
   * Find zero or one ForecastAnnotation that matches the filter.
   * @param {ForecastAnnotationFindUniqueArgs} args - Arguments to find a ForecastAnnotation
   * @example
   * // Get one ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ForecastAnnotationFindUniqueArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ForecastAnnotation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ForecastAnnotationFindUniqueOrThrowArgs} args - Arguments to find a ForecastAnnotation
   * @example
   * // Get one ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ForecastAnnotationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ForecastAnnotation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationFindFirstArgs} args - Arguments to find a ForecastAnnotation
   * @example
   * // Get one ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ForecastAnnotationFindFirstArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationFindFirstArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ForecastAnnotation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationFindFirstOrThrowArgs} args - Arguments to find a ForecastAnnotation
   * @example
   * // Get one ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ForecastAnnotationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ForecastAnnotations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ForecastAnnotations
   * const forecastAnnotations = await prisma.forecastAnnotation.findMany()
   * 
   * // Get first 10 ForecastAnnotations
   * const forecastAnnotations = await prisma.forecastAnnotation.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const forecastAnnotationWithIdOnly = await prisma.forecastAnnotation.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ForecastAnnotationFindManyArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ForecastAnnotation.
   * @param {ForecastAnnotationCreateArgs} args - Arguments to create a ForecastAnnotation.
   * @example
   * // Create one ForecastAnnotation
   * const ForecastAnnotation = await prisma.forecastAnnotation.create({
   *   data: {
   *     // ... data to create a ForecastAnnotation
   *   }
   * })
   * 
   */
  create<T extends ForecastAnnotationCreateArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationCreateArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ForecastAnnotations.
   * @param {ForecastAnnotationCreateManyArgs} args - Arguments to create many ForecastAnnotations.
   * @example
   * // Create many ForecastAnnotations
   * const forecastAnnotation = await prisma.forecastAnnotation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ForecastAnnotationCreateManyArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ForecastAnnotations and returns the data saved in the database.
   * @param {ForecastAnnotationCreateManyAndReturnArgs} args - Arguments to create many ForecastAnnotations.
   * @example
   * // Create many ForecastAnnotations
   * const forecastAnnotation = await prisma.forecastAnnotation.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ForecastAnnotations and only return the `id`
   * const forecastAnnotationWithIdOnly = await prisma.forecastAnnotation.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ForecastAnnotationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ForecastAnnotation.
   * @param {ForecastAnnotationDeleteArgs} args - Arguments to delete one ForecastAnnotation.
   * @example
   * // Delete one ForecastAnnotation
   * const ForecastAnnotation = await prisma.forecastAnnotation.delete({
   *   where: {
   *     // ... filter to delete one ForecastAnnotation
   *   }
   * })
   * 
   */
  delete<T extends ForecastAnnotationDeleteArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationDeleteArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ForecastAnnotation.
   * @param {ForecastAnnotationUpdateArgs} args - Arguments to update one ForecastAnnotation.
   * @example
   * // Update one ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ForecastAnnotationUpdateArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationUpdateArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ForecastAnnotations.
   * @param {ForecastAnnotationDeleteManyArgs} args - Arguments to filter ForecastAnnotations to delete.
   * @example
   * // Delete a few ForecastAnnotations
   * const { count } = await prisma.forecastAnnotation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ForecastAnnotationDeleteManyArgs>(args?: Prisma.SelectSubset<T, ForecastAnnotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ForecastAnnotations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ForecastAnnotations
   * const forecastAnnotation = await prisma.forecastAnnotation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ForecastAnnotationUpdateManyArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ForecastAnnotations and returns the data updated in the database.
   * @param {ForecastAnnotationUpdateManyAndReturnArgs} args - Arguments to update many ForecastAnnotations.
   * @example
   * // Update many ForecastAnnotations
   * const forecastAnnotation = await prisma.forecastAnnotation.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ForecastAnnotations and only return the `id`
   * const forecastAnnotationWithIdOnly = await prisma.forecastAnnotation.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ForecastAnnotationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ForecastAnnotation.
   * @param {ForecastAnnotationUpsertArgs} args - Arguments to update or create a ForecastAnnotation.
   * @example
   * // Update or create a ForecastAnnotation
   * const forecastAnnotation = await prisma.forecastAnnotation.upsert({
   *   create: {
   *     // ... data to create a ForecastAnnotation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ForecastAnnotation we want to update
   *   }
   * })
   */
  upsert<T extends ForecastAnnotationUpsertArgs>(args: Prisma.SelectSubset<T, ForecastAnnotationUpsertArgs<ExtArgs>>): Prisma.Prisma__ForecastAnnotationClient<runtime.Types.Result.GetResult<Prisma.$ForecastAnnotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ForecastAnnotations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationCountArgs} args - Arguments to filter ForecastAnnotations to count.
   * @example
   * // Count the number of ForecastAnnotations
   * const count = await prisma.forecastAnnotation.count({
   *   where: {
   *     // ... the filter for the ForecastAnnotations we want to count
   *   }
   * })
  **/
  count<T extends ForecastAnnotationCountArgs>(
    args?: Prisma.Subset<T, ForecastAnnotationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ForecastAnnotationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ForecastAnnotation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ForecastAnnotationAggregateArgs>(args: Prisma.Subset<T, ForecastAnnotationAggregateArgs>): Prisma.PrismaPromise<GetForecastAnnotationAggregateType<T>>

  /**
   * Group by ForecastAnnotation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ForecastAnnotationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ForecastAnnotationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ForecastAnnotationGroupByArgs['orderBy'] }
      : { orderBy?: ForecastAnnotationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ForecastAnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForecastAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ForecastAnnotation model
 */
readonly fields: ForecastAnnotationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ForecastAnnotation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ForecastAnnotationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  revenueForecast<T extends Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ForecastAnnotation$revenueForecastArgs<ExtArgs>>): Prisma.Prisma__RevenueForecastClient<runtime.Types.Result.GetResult<Prisma.$RevenueForecastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  costForecast<T extends Prisma.ForecastAnnotation$costForecastArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ForecastAnnotation$costForecastArgs<ExtArgs>>): Prisma.Prisma__CostForecastClient<runtime.Types.Result.GetResult<Prisma.$CostForecastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  cashForecast<T extends Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ForecastAnnotation$cashForecastArgs<ExtArgs>>): Prisma.Prisma__CashForecastClient<runtime.Types.Result.GetResult<Prisma.$CashForecastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ForecastAnnotation model
 */
export interface ForecastAnnotationFieldRefs {
  readonly id: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly content: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly authorId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly authorName: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly lineItemId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly periodId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly revenueForecastId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly costForecastId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly cashForecastId: Prisma.FieldRef<"ForecastAnnotation", 'String'>
  readonly createdAt: Prisma.FieldRef<"ForecastAnnotation", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"ForecastAnnotation", 'DateTime'>
}
    

// Custom InputTypes
/**
 * ForecastAnnotation findUnique
 */
export type ForecastAnnotationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter, which ForecastAnnotation to fetch.
   */
  where: Prisma.ForecastAnnotationWhereUniqueInput
}

/**
 * ForecastAnnotation findUniqueOrThrow
 */
export type ForecastAnnotationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter, which ForecastAnnotation to fetch.
   */
  where: Prisma.ForecastAnnotationWhereUniqueInput
}

/**
 * ForecastAnnotation findFirst
 */
export type ForecastAnnotationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter, which ForecastAnnotation to fetch.
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ForecastAnnotations to fetch.
   */
  orderBy?: Prisma.ForecastAnnotationOrderByWithRelationInput | Prisma.ForecastAnnotationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ForecastAnnotations.
   */
  cursor?: Prisma.ForecastAnnotationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ForecastAnnotations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ForecastAnnotations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ForecastAnnotations.
   */
  distinct?: Prisma.ForecastAnnotationScalarFieldEnum | Prisma.ForecastAnnotationScalarFieldEnum[]
}

/**
 * ForecastAnnotation findFirstOrThrow
 */
export type ForecastAnnotationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter, which ForecastAnnotation to fetch.
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ForecastAnnotations to fetch.
   */
  orderBy?: Prisma.ForecastAnnotationOrderByWithRelationInput | Prisma.ForecastAnnotationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ForecastAnnotations.
   */
  cursor?: Prisma.ForecastAnnotationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ForecastAnnotations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ForecastAnnotations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ForecastAnnotations.
   */
  distinct?: Prisma.ForecastAnnotationScalarFieldEnum | Prisma.ForecastAnnotationScalarFieldEnum[]
}

/**
 * ForecastAnnotation findMany
 */
export type ForecastAnnotationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter, which ForecastAnnotations to fetch.
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ForecastAnnotations to fetch.
   */
  orderBy?: Prisma.ForecastAnnotationOrderByWithRelationInput | Prisma.ForecastAnnotationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ForecastAnnotations.
   */
  cursor?: Prisma.ForecastAnnotationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ForecastAnnotations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ForecastAnnotations.
   */
  skip?: number
  distinct?: Prisma.ForecastAnnotationScalarFieldEnum | Prisma.ForecastAnnotationScalarFieldEnum[]
}

/**
 * ForecastAnnotation create
 */
export type ForecastAnnotationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * The data needed to create a ForecastAnnotation.
   */
  data: Prisma.XOR<Prisma.ForecastAnnotationCreateInput, Prisma.ForecastAnnotationUncheckedCreateInput>
}

/**
 * ForecastAnnotation createMany
 */
export type ForecastAnnotationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ForecastAnnotations.
   */
  data: Prisma.ForecastAnnotationCreateManyInput | Prisma.ForecastAnnotationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ForecastAnnotation createManyAndReturn
 */
export type ForecastAnnotationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * The data used to create many ForecastAnnotations.
   */
  data: Prisma.ForecastAnnotationCreateManyInput | Prisma.ForecastAnnotationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ForecastAnnotation update
 */
export type ForecastAnnotationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * The data needed to update a ForecastAnnotation.
   */
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateInput, Prisma.ForecastAnnotationUncheckedUpdateInput>
  /**
   * Choose, which ForecastAnnotation to update.
   */
  where: Prisma.ForecastAnnotationWhereUniqueInput
}

/**
 * ForecastAnnotation updateMany
 */
export type ForecastAnnotationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ForecastAnnotations.
   */
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateManyMutationInput, Prisma.ForecastAnnotationUncheckedUpdateManyInput>
  /**
   * Filter which ForecastAnnotations to update
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * Limit how many ForecastAnnotations to update.
   */
  limit?: number
}

/**
 * ForecastAnnotation updateManyAndReturn
 */
export type ForecastAnnotationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * The data used to update ForecastAnnotations.
   */
  data: Prisma.XOR<Prisma.ForecastAnnotationUpdateManyMutationInput, Prisma.ForecastAnnotationUncheckedUpdateManyInput>
  /**
   * Filter which ForecastAnnotations to update
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * Limit how many ForecastAnnotations to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ForecastAnnotation upsert
 */
export type ForecastAnnotationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * The filter to search for the ForecastAnnotation to update in case it exists.
   */
  where: Prisma.ForecastAnnotationWhereUniqueInput
  /**
   * In case the ForecastAnnotation found by the `where` argument doesn't exist, create a new ForecastAnnotation with this data.
   */
  create: Prisma.XOR<Prisma.ForecastAnnotationCreateInput, Prisma.ForecastAnnotationUncheckedCreateInput>
  /**
   * In case the ForecastAnnotation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ForecastAnnotationUpdateInput, Prisma.ForecastAnnotationUncheckedUpdateInput>
}

/**
 * ForecastAnnotation delete
 */
export type ForecastAnnotationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
  /**
   * Filter which ForecastAnnotation to delete.
   */
  where: Prisma.ForecastAnnotationWhereUniqueInput
}

/**
 * ForecastAnnotation deleteMany
 */
export type ForecastAnnotationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ForecastAnnotations to delete
   */
  where?: Prisma.ForecastAnnotationWhereInput
  /**
   * Limit how many ForecastAnnotations to delete.
   */
  limit?: number
}

/**
 * ForecastAnnotation.revenueForecast
 */
export type ForecastAnnotation$revenueForecastArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RevenueForecast
   */
  select?: Prisma.RevenueForecastSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RevenueForecast
   */
  omit?: Prisma.RevenueForecastOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RevenueForecastInclude<ExtArgs> | null
  where?: Prisma.RevenueForecastWhereInput
}

/**
 * ForecastAnnotation.costForecast
 */
export type ForecastAnnotation$costForecastArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CostForecast
   */
  select?: Prisma.CostForecastSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CostForecast
   */
  omit?: Prisma.CostForecastOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CostForecastInclude<ExtArgs> | null
  where?: Prisma.CostForecastWhereInput
}

/**
 * ForecastAnnotation.cashForecast
 */
export type ForecastAnnotation$cashForecastArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CashForecast
   */
  select?: Prisma.CashForecastSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CashForecast
   */
  omit?: Prisma.CashForecastOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CashForecastInclude<ExtArgs> | null
  where?: Prisma.CashForecastWhereInput
}

/**
 * ForecastAnnotation without action
 */
export type ForecastAnnotationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ForecastAnnotation
   */
  select?: Prisma.ForecastAnnotationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ForecastAnnotation
   */
  omit?: Prisma.ForecastAnnotationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ForecastAnnotationInclude<ExtArgs> | null
}
