
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Project: 'Project',
  TimeEntry: 'TimeEntry',
  CostCenter: 'CostCenter',
  User: 'User',
  Account: 'Account',
  Session: 'Session',
  VerificationToken: 'VerificationToken',
  Organization: 'Organization',
  FinancialAccount: 'FinancialAccount',
  Transaction: 'Transaction',
  Receipt: 'Receipt',
  ChatChannel: 'ChatChannel',
  ChatMessage: 'ChatMessage',
  UserSettings: 'UserSettings',
  Wallet: 'Wallet',
  AISuggestion: 'AISuggestion',
  SavedReport: 'SavedReport',
  CorporateEntity: 'CorporateEntity',
  Invoice: 'Invoice',
  Order: 'Order',
  ArchiveItem: 'ArchiveItem',
  Liability: 'Liability',
  LiabilityPayment: 'LiabilityPayment',
  InventoryItem: 'InventoryItem',
  InventoryMovement: 'InventoryMovement',
  InventoryBatch: 'InventoryBatch',
  Receivable: 'Receivable',
  ReceivablePayment: 'ReceivablePayment',
  ReceivableEvent: 'ReceivableEvent',
  TreasuryAccount: 'TreasuryAccount',
  CapitalBucket: 'CapitalBucket',
  CreditFacility: 'CreditFacility',
  FacilityDrawdown: 'FacilityDrawdown',
  TreasuryDecision: 'TreasuryDecision',
  TreasuryScenario: 'TreasuryScenario',
  TreasuryCashMovement: 'TreasuryCashMovement',
  NettingOpportunity: 'NettingOpportunity',
  Asset: 'Asset',
  AssetDepreciation: 'AssetDepreciation',
  AssetEvent: 'AssetEvent',
  AssetTransfer: 'AssetTransfer',
  AssetDisposal: 'AssetDisposal',
  CapExBudget: 'CapExBudget',
  CapExItem: 'CapExItem'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "project" | "timeEntry" | "costCenter" | "user" | "account" | "session" | "verificationToken" | "organization" | "financialAccount" | "transaction" | "receipt" | "chatChannel" | "chatMessage" | "userSettings" | "wallet" | "aISuggestion" | "savedReport" | "corporateEntity" | "invoice" | "order" | "archiveItem" | "liability" | "liabilityPayment" | "inventoryItem" | "inventoryMovement" | "inventoryBatch" | "receivable" | "receivablePayment" | "receivableEvent" | "treasuryAccount" | "capitalBucket" | "creditFacility" | "facilityDrawdown" | "treasuryDecision" | "treasuryScenario" | "treasuryCashMovement" | "nettingOpportunity" | "asset" | "assetDepreciation" | "assetEvent" | "assetTransfer" | "assetDisposal" | "capExBudget" | "capExItem"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    TimeEntry: {
      payload: Prisma.$TimeEntryPayload<ExtArgs>
      fields: Prisma.TimeEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findFirst: {
          args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findMany: {
          args: Prisma.TimeEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        create: {
          args: Prisma.TimeEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        createMany: {
          args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        delete: {
          args: Prisma.TimeEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        update: {
          args: Prisma.TimeEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        deleteMany: {
          args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        upsert: {
          args: Prisma.TimeEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        aggregate: {
          args: Prisma.TimeEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeEntry>
        }
        groupBy: {
          args: Prisma.TimeEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryCountAggregateOutputType> | number
        }
      }
    }
    CostCenter: {
      payload: Prisma.$CostCenterPayload<ExtArgs>
      fields: Prisma.CostCenterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findFirst: {
          args: Prisma.CostCenterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findMany: {
          args: Prisma.CostCenterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        create: {
          args: Prisma.CostCenterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        createMany: {
          args: Prisma.CostCenterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        delete: {
          args: Prisma.CostCenterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        update: {
          args: Prisma.CostCenterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        deleteMany: {
          args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostCenterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        upsert: {
          args: Prisma.CostCenterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        aggregate: {
          args: Prisma.CostCenterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostCenter>
        }
        groupBy: {
          args: Prisma.CostCenterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostCenterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    FinancialAccount: {
      payload: Prisma.$FinancialAccountPayload<ExtArgs>
      fields: Prisma.FinancialAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        findFirst: {
          args: Prisma.FinancialAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        findMany: {
          args: Prisma.FinancialAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        create: {
          args: Prisma.FinancialAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        createMany: {
          args: Prisma.FinancialAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        delete: {
          args: Prisma.FinancialAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        update: {
          args: Prisma.FinancialAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        deleteMany: {
          args: Prisma.FinancialAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        upsert: {
          args: Prisma.FinancialAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        aggregate: {
          args: Prisma.FinancialAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialAccount>
        }
        groupBy: {
          args: Prisma.FinancialAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialAccountCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    Receipt: {
      payload: Prisma.$ReceiptPayload<ExtArgs>
      fields: Prisma.ReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findFirst: {
          args: Prisma.ReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findMany: {
          args: Prisma.ReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        create: {
          args: Prisma.ReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        createMany: {
          args: Prisma.ReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        delete: {
          args: Prisma.ReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        update: {
          args: Prisma.ReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        deleteMany: {
          args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        upsert: {
          args: Prisma.ReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        aggregate: {
          args: Prisma.ReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceipt>
        }
        groupBy: {
          args: Prisma.ReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptCountAggregateOutputType> | number
        }
      }
    }
    ChatChannel: {
      payload: Prisma.$ChatChannelPayload<ExtArgs>
      fields: Prisma.ChatChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChatChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChatChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        findFirst: {
          args: Prisma.ChatChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChatChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        findMany: {
          args: Prisma.ChatChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        create: {
          args: Prisma.ChatChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        createMany: {
          args: Prisma.ChatChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChatChannelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        delete: {
          args: Prisma.ChatChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        update: {
          args: Prisma.ChatChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        deleteMany: {
          args: Prisma.ChatChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChatChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChatChannelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        upsert: {
          args: Prisma.ChatChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        aggregate: {
          args: Prisma.ChatChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatChannel>
        }
        groupBy: {
          args: Prisma.ChatChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChatChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatChannelCountAggregateOutputType> | number
        }
      }
    }
    ChatMessage: {
      payload: Prisma.$ChatMessagePayload<ExtArgs>
      fields: Prisma.ChatMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        findFirst: {
          args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        findMany: {
          args: Prisma.ChatMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        create: {
          args: Prisma.ChatMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        createMany: {
          args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        delete: {
          args: Prisma.ChatMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        update: {
          args: Prisma.ChatMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        deleteMany: {
          args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        upsert: {
          args: Prisma.ChatMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        aggregate: {
          args: Prisma.ChatMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatMessage>
        }
        groupBy: {
          args: Prisma.ChatMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChatMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatMessageCountAggregateOutputType> | number
        }
      }
    }
    UserSettings: {
      payload: Prisma.$UserSettingsPayload<ExtArgs>
      fields: Prisma.UserSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findFirst: {
          args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findMany: {
          args: Prisma.UserSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        create: {
          args: Prisma.UserSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        createMany: {
          args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        delete: {
          args: Prisma.UserSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        update: {
          args: Prisma.UserSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        deleteMany: {
          args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        upsert: {
          args: Prisma.UserSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        aggregate: {
          args: Prisma.UserSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSettings>
        }
        groupBy: {
          args: Prisma.UserSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsCountAggregateOutputType> | number
        }
      }
    }
    Wallet: {
      payload: Prisma.$WalletPayload<ExtArgs>
      fields: Prisma.WalletFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findFirst: {
          args: Prisma.WalletFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findMany: {
          args: Prisma.WalletFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        create: {
          args: Prisma.WalletCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        createMany: {
          args: Prisma.WalletCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        delete: {
          args: Prisma.WalletDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        update: {
          args: Prisma.WalletUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        deleteMany: {
          args: Prisma.WalletDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        upsert: {
          args: Prisma.WalletUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        aggregate: {
          args: Prisma.WalletAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWallet>
        }
        groupBy: {
          args: Prisma.WalletGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletCountAggregateOutputType> | number
        }
      }
    }
    AISuggestion: {
      payload: Prisma.$AISuggestionPayload<ExtArgs>
      fields: Prisma.AISuggestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AISuggestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AISuggestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        findFirst: {
          args: Prisma.AISuggestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AISuggestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        findMany: {
          args: Prisma.AISuggestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        create: {
          args: Prisma.AISuggestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        createMany: {
          args: Prisma.AISuggestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AISuggestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        delete: {
          args: Prisma.AISuggestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        update: {
          args: Prisma.AISuggestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        deleteMany: {
          args: Prisma.AISuggestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AISuggestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AISuggestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        upsert: {
          args: Prisma.AISuggestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        aggregate: {
          args: Prisma.AISuggestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAISuggestion>
        }
        groupBy: {
          args: Prisma.AISuggestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AISuggestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AISuggestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AISuggestionCountAggregateOutputType> | number
        }
      }
    }
    SavedReport: {
      payload: Prisma.$SavedReportPayload<ExtArgs>
      fields: Prisma.SavedReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SavedReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SavedReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        findFirst: {
          args: Prisma.SavedReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SavedReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        findMany: {
          args: Prisma.SavedReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        create: {
          args: Prisma.SavedReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        createMany: {
          args: Prisma.SavedReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SavedReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        delete: {
          args: Prisma.SavedReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        update: {
          args: Prisma.SavedReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        deleteMany: {
          args: Prisma.SavedReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SavedReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SavedReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        upsert: {
          args: Prisma.SavedReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        aggregate: {
          args: Prisma.SavedReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSavedReport>
        }
        groupBy: {
          args: Prisma.SavedReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.SavedReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedReportCountAggregateOutputType> | number
        }
      }
    }
    CorporateEntity: {
      payload: Prisma.$CorporateEntityPayload<ExtArgs>
      fields: Prisma.CorporateEntityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CorporateEntityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CorporateEntityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        findFirst: {
          args: Prisma.CorporateEntityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CorporateEntityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        findMany: {
          args: Prisma.CorporateEntityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        create: {
          args: Prisma.CorporateEntityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        createMany: {
          args: Prisma.CorporateEntityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CorporateEntityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        delete: {
          args: Prisma.CorporateEntityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        update: {
          args: Prisma.CorporateEntityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        deleteMany: {
          args: Prisma.CorporateEntityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CorporateEntityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CorporateEntityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        upsert: {
          args: Prisma.CorporateEntityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        aggregate: {
          args: Prisma.CorporateEntityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCorporateEntity>
        }
        groupBy: {
          args: Prisma.CorporateEntityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CorporateEntityGroupByOutputType>[]
        }
        count: {
          args: Prisma.CorporateEntityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CorporateEntityCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    Order: {
      payload: Prisma.$OrderPayload<ExtArgs>
      fields: Prisma.OrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findFirst: {
          args: Prisma.OrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findMany: {
          args: Prisma.OrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        create: {
          args: Prisma.OrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        createMany: {
          args: Prisma.OrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        delete: {
          args: Prisma.OrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        update: {
          args: Prisma.OrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        deleteMany: {
          args: Prisma.OrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        upsert: {
          args: Prisma.OrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        aggregate: {
          args: Prisma.OrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrder>
        }
        groupBy: {
          args: Prisma.OrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderCountAggregateOutputType> | number
        }
      }
    }
    ArchiveItem: {
      payload: Prisma.$ArchiveItemPayload<ExtArgs>
      fields: Prisma.ArchiveItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        findFirst: {
          args: Prisma.ArchiveItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        findMany: {
          args: Prisma.ArchiveItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>[]
        }
        create: {
          args: Prisma.ArchiveItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        createMany: {
          args: Prisma.ArchiveItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>[]
        }
        delete: {
          args: Prisma.ArchiveItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        update: {
          args: Prisma.ArchiveItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveItemPayload>
        }
        aggregate: {
          args: Prisma.ArchiveItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveItem>
        }
        groupBy: {
          args: Prisma.ArchiveItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveItemCountAggregateOutputType> | number
        }
      }
    }
    Liability: {
      payload: Prisma.$LiabilityPayload<ExtArgs>
      fields: Prisma.LiabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        findFirst: {
          args: Prisma.LiabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        findMany: {
          args: Prisma.LiabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        create: {
          args: Prisma.LiabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        createMany: {
          args: Prisma.LiabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        delete: {
          args: Prisma.LiabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        update: {
          args: Prisma.LiabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        aggregate: {
          args: Prisma.LiabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiability>
        }
        groupBy: {
          args: Prisma.LiabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityCountAggregateOutputType> | number
        }
      }
    }
    LiabilityPayment: {
      payload: Prisma.$LiabilityPaymentPayload<ExtArgs>
      fields: Prisma.LiabilityPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        findFirst: {
          args: Prisma.LiabilityPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        findMany: {
          args: Prisma.LiabilityPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        create: {
          args: Prisma.LiabilityPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        createMany: {
          args: Prisma.LiabilityPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        delete: {
          args: Prisma.LiabilityPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        update: {
          args: Prisma.LiabilityPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        aggregate: {
          args: Prisma.LiabilityPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityPayment>
        }
        groupBy: {
          args: Prisma.LiabilityPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityPaymentCountAggregateOutputType> | number
        }
      }
    }
    InventoryItem: {
      payload: Prisma.$InventoryItemPayload<ExtArgs>
      fields: Prisma.InventoryItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findFirst: {
          args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findMany: {
          args: Prisma.InventoryItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        create: {
          args: Prisma.InventoryItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        createMany: {
          args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        delete: {
          args: Prisma.InventoryItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        update: {
          args: Prisma.InventoryItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        deleteMany: {
          args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        upsert: {
          args: Prisma.InventoryItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        aggregate: {
          args: Prisma.InventoryItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryItem>
        }
        groupBy: {
          args: Prisma.InventoryItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemCountAggregateOutputType> | number
        }
      }
    }
    InventoryMovement: {
      payload: Prisma.$InventoryMovementPayload<ExtArgs>
      fields: Prisma.InventoryMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        findFirst: {
          args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        findMany: {
          args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        create: {
          args: Prisma.InventoryMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        createMany: {
          args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        delete: {
          args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        update: {
          args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        deleteMany: {
          args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        upsert: {
          args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        aggregate: {
          args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryMovement>
        }
        groupBy: {
          args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryMovementCountAggregateOutputType> | number
        }
      }
    }
    InventoryBatch: {
      payload: Prisma.$InventoryBatchPayload<ExtArgs>
      fields: Prisma.InventoryBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        findFirst: {
          args: Prisma.InventoryBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        findMany: {
          args: Prisma.InventoryBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        create: {
          args: Prisma.InventoryBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        createMany: {
          args: Prisma.InventoryBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        delete: {
          args: Prisma.InventoryBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        update: {
          args: Prisma.InventoryBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        deleteMany: {
          args: Prisma.InventoryBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        upsert: {
          args: Prisma.InventoryBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        aggregate: {
          args: Prisma.InventoryBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryBatch>
        }
        groupBy: {
          args: Prisma.InventoryBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryBatchCountAggregateOutputType> | number
        }
      }
    }
    Receivable: {
      payload: Prisma.$ReceivablePayload<ExtArgs>
      fields: Prisma.ReceivableFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivableFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivableFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        findFirst: {
          args: Prisma.ReceivableFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivableFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        findMany: {
          args: Prisma.ReceivableFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        create: {
          args: Prisma.ReceivableCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        createMany: {
          args: Prisma.ReceivableCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivableCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        delete: {
          args: Prisma.ReceivableDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        update: {
          args: Prisma.ReceivableUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        deleteMany: {
          args: Prisma.ReceivableDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivableUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivableUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        upsert: {
          args: Prisma.ReceivableUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        aggregate: {
          args: Prisma.ReceivableAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivable>
        }
        groupBy: {
          args: Prisma.ReceivableGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivableCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableCountAggregateOutputType> | number
        }
      }
    }
    ReceivablePayment: {
      payload: Prisma.$ReceivablePaymentPayload<ExtArgs>
      fields: Prisma.ReceivablePaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivablePaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivablePaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        findFirst: {
          args: Prisma.ReceivablePaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivablePaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        findMany: {
          args: Prisma.ReceivablePaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        create: {
          args: Prisma.ReceivablePaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        createMany: {
          args: Prisma.ReceivablePaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivablePaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        delete: {
          args: Prisma.ReceivablePaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        update: {
          args: Prisma.ReceivablePaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        deleteMany: {
          args: Prisma.ReceivablePaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivablePaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivablePaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        upsert: {
          args: Prisma.ReceivablePaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        aggregate: {
          args: Prisma.ReceivablePaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivablePayment>
        }
        groupBy: {
          args: Prisma.ReceivablePaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivablePaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivablePaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivablePaymentCountAggregateOutputType> | number
        }
      }
    }
    ReceivableEvent: {
      payload: Prisma.$ReceivableEventPayload<ExtArgs>
      fields: Prisma.ReceivableEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivableEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivableEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        findFirst: {
          args: Prisma.ReceivableEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivableEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        findMany: {
          args: Prisma.ReceivableEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        create: {
          args: Prisma.ReceivableEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        createMany: {
          args: Prisma.ReceivableEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivableEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        delete: {
          args: Prisma.ReceivableEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        update: {
          args: Prisma.ReceivableEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        deleteMany: {
          args: Prisma.ReceivableEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivableEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivableEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        upsert: {
          args: Prisma.ReceivableEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        aggregate: {
          args: Prisma.ReceivableEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivableEvent>
        }
        groupBy: {
          args: Prisma.ReceivableEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivableEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableEventCountAggregateOutputType> | number
        }
      }
    }
    TreasuryAccount: {
      payload: Prisma.$TreasuryAccountPayload<ExtArgs>
      fields: Prisma.TreasuryAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        findFirst: {
          args: Prisma.TreasuryAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        findMany: {
          args: Prisma.TreasuryAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        create: {
          args: Prisma.TreasuryAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        createMany: {
          args: Prisma.TreasuryAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        delete: {
          args: Prisma.TreasuryAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        update: {
          args: Prisma.TreasuryAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        aggregate: {
          args: Prisma.TreasuryAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryAccount>
        }
        groupBy: {
          args: Prisma.TreasuryAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryAccountCountAggregateOutputType> | number
        }
      }
    }
    CapitalBucket: {
      payload: Prisma.$CapitalBucketPayload<ExtArgs>
      fields: Prisma.CapitalBucketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapitalBucketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapitalBucketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        findFirst: {
          args: Prisma.CapitalBucketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapitalBucketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        findMany: {
          args: Prisma.CapitalBucketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        create: {
          args: Prisma.CapitalBucketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        createMany: {
          args: Prisma.CapitalBucketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapitalBucketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        delete: {
          args: Prisma.CapitalBucketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        update: {
          args: Prisma.CapitalBucketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        deleteMany: {
          args: Prisma.CapitalBucketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapitalBucketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapitalBucketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        upsert: {
          args: Prisma.CapitalBucketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        aggregate: {
          args: Prisma.CapitalBucketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapitalBucket>
        }
        groupBy: {
          args: Prisma.CapitalBucketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapitalBucketGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapitalBucketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapitalBucketCountAggregateOutputType> | number
        }
      }
    }
    CreditFacility: {
      payload: Prisma.$CreditFacilityPayload<ExtArgs>
      fields: Prisma.CreditFacilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CreditFacilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CreditFacilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        findFirst: {
          args: Prisma.CreditFacilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CreditFacilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        findMany: {
          args: Prisma.CreditFacilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        create: {
          args: Prisma.CreditFacilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        createMany: {
          args: Prisma.CreditFacilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CreditFacilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        delete: {
          args: Prisma.CreditFacilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        update: {
          args: Prisma.CreditFacilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        deleteMany: {
          args: Prisma.CreditFacilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CreditFacilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CreditFacilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        upsert: {
          args: Prisma.CreditFacilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        aggregate: {
          args: Prisma.CreditFacilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCreditFacility>
        }
        groupBy: {
          args: Prisma.CreditFacilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditFacilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.CreditFacilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditFacilityCountAggregateOutputType> | number
        }
      }
    }
    FacilityDrawdown: {
      payload: Prisma.$FacilityDrawdownPayload<ExtArgs>
      fields: Prisma.FacilityDrawdownFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityDrawdownFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityDrawdownFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        findFirst: {
          args: Prisma.FacilityDrawdownFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityDrawdownFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        findMany: {
          args: Prisma.FacilityDrawdownFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        create: {
          args: Prisma.FacilityDrawdownCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        createMany: {
          args: Prisma.FacilityDrawdownCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityDrawdownCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        delete: {
          args: Prisma.FacilityDrawdownDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        update: {
          args: Prisma.FacilityDrawdownUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        deleteMany: {
          args: Prisma.FacilityDrawdownDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityDrawdownUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityDrawdownUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        upsert: {
          args: Prisma.FacilityDrawdownUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        aggregate: {
          args: Prisma.FacilityDrawdownAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacilityDrawdown>
        }
        groupBy: {
          args: Prisma.FacilityDrawdownGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityDrawdownGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityDrawdownCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityDrawdownCountAggregateOutputType> | number
        }
      }
    }
    TreasuryDecision: {
      payload: Prisma.$TreasuryDecisionPayload<ExtArgs>
      fields: Prisma.TreasuryDecisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryDecisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryDecisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        findFirst: {
          args: Prisma.TreasuryDecisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryDecisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        findMany: {
          args: Prisma.TreasuryDecisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        create: {
          args: Prisma.TreasuryDecisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        createMany: {
          args: Prisma.TreasuryDecisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryDecisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        delete: {
          args: Prisma.TreasuryDecisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        update: {
          args: Prisma.TreasuryDecisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryDecisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryDecisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryDecisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryDecisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        aggregate: {
          args: Prisma.TreasuryDecisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryDecision>
        }
        groupBy: {
          args: Prisma.TreasuryDecisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryDecisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryDecisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryDecisionCountAggregateOutputType> | number
        }
      }
    }
    TreasuryScenario: {
      payload: Prisma.$TreasuryScenarioPayload<ExtArgs>
      fields: Prisma.TreasuryScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        findFirst: {
          args: Prisma.TreasuryScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        findMany: {
          args: Prisma.TreasuryScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        create: {
          args: Prisma.TreasuryScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        createMany: {
          args: Prisma.TreasuryScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        delete: {
          args: Prisma.TreasuryScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        update: {
          args: Prisma.TreasuryScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        aggregate: {
          args: Prisma.TreasuryScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryScenario>
        }
        groupBy: {
          args: Prisma.TreasuryScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryScenarioCountAggregateOutputType> | number
        }
      }
    }
    TreasuryCashMovement: {
      payload: Prisma.$TreasuryCashMovementPayload<ExtArgs>
      fields: Prisma.TreasuryCashMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryCashMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryCashMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        findFirst: {
          args: Prisma.TreasuryCashMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryCashMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        findMany: {
          args: Prisma.TreasuryCashMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        create: {
          args: Prisma.TreasuryCashMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        createMany: {
          args: Prisma.TreasuryCashMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryCashMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        delete: {
          args: Prisma.TreasuryCashMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        update: {
          args: Prisma.TreasuryCashMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryCashMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryCashMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryCashMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryCashMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        aggregate: {
          args: Prisma.TreasuryCashMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryCashMovement>
        }
        groupBy: {
          args: Prisma.TreasuryCashMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryCashMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryCashMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryCashMovementCountAggregateOutputType> | number
        }
      }
    }
    NettingOpportunity: {
      payload: Prisma.$NettingOpportunityPayload<ExtArgs>
      fields: Prisma.NettingOpportunityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingOpportunityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingOpportunityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        findFirst: {
          args: Prisma.NettingOpportunityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingOpportunityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        findMany: {
          args: Prisma.NettingOpportunityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        create: {
          args: Prisma.NettingOpportunityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        createMany: {
          args: Prisma.NettingOpportunityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingOpportunityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        delete: {
          args: Prisma.NettingOpportunityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        update: {
          args: Prisma.NettingOpportunityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        deleteMany: {
          args: Prisma.NettingOpportunityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingOpportunityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingOpportunityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        upsert: {
          args: Prisma.NettingOpportunityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        aggregate: {
          args: Prisma.NettingOpportunityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingOpportunity>
        }
        groupBy: {
          args: Prisma.NettingOpportunityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingOpportunityGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingOpportunityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingOpportunityCountAggregateOutputType> | number
        }
      }
    }
    Asset: {
      payload: Prisma.$AssetPayload<ExtArgs>
      fields: Prisma.AssetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findFirst: {
          args: Prisma.AssetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findMany: {
          args: Prisma.AssetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        create: {
          args: Prisma.AssetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        createMany: {
          args: Prisma.AssetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        delete: {
          args: Prisma.AssetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        update: {
          args: Prisma.AssetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        deleteMany: {
          args: Prisma.AssetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        upsert: {
          args: Prisma.AssetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        aggregate: {
          args: Prisma.AssetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAsset>
        }
        groupBy: {
          args: Prisma.AssetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetCountAggregateOutputType> | number
        }
      }
    }
    AssetDepreciation: {
      payload: Prisma.$AssetDepreciationPayload<ExtArgs>
      fields: Prisma.AssetDepreciationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetDepreciationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetDepreciationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        findFirst: {
          args: Prisma.AssetDepreciationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetDepreciationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        findMany: {
          args: Prisma.AssetDepreciationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        create: {
          args: Prisma.AssetDepreciationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        createMany: {
          args: Prisma.AssetDepreciationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetDepreciationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        delete: {
          args: Prisma.AssetDepreciationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        update: {
          args: Prisma.AssetDepreciationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        deleteMany: {
          args: Prisma.AssetDepreciationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetDepreciationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetDepreciationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        upsert: {
          args: Prisma.AssetDepreciationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        aggregate: {
          args: Prisma.AssetDepreciationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetDepreciation>
        }
        groupBy: {
          args: Prisma.AssetDepreciationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDepreciationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetDepreciationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDepreciationCountAggregateOutputType> | number
        }
      }
    }
    AssetEvent: {
      payload: Prisma.$AssetEventPayload<ExtArgs>
      fields: Prisma.AssetEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        findFirst: {
          args: Prisma.AssetEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        findMany: {
          args: Prisma.AssetEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        create: {
          args: Prisma.AssetEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        createMany: {
          args: Prisma.AssetEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        delete: {
          args: Prisma.AssetEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        update: {
          args: Prisma.AssetEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        deleteMany: {
          args: Prisma.AssetEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        upsert: {
          args: Prisma.AssetEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        aggregate: {
          args: Prisma.AssetEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetEvent>
        }
        groupBy: {
          args: Prisma.AssetEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetEventCountAggregateOutputType> | number
        }
      }
    }
    AssetTransfer: {
      payload: Prisma.$AssetTransferPayload<ExtArgs>
      fields: Prisma.AssetTransferFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetTransferFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetTransferFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        findFirst: {
          args: Prisma.AssetTransferFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetTransferFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        findMany: {
          args: Prisma.AssetTransferFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        create: {
          args: Prisma.AssetTransferCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        createMany: {
          args: Prisma.AssetTransferCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetTransferCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        delete: {
          args: Prisma.AssetTransferDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        update: {
          args: Prisma.AssetTransferUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        deleteMany: {
          args: Prisma.AssetTransferDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetTransferUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetTransferUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        upsert: {
          args: Prisma.AssetTransferUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        aggregate: {
          args: Prisma.AssetTransferAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetTransfer>
        }
        groupBy: {
          args: Prisma.AssetTransferGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetTransferGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetTransferCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetTransferCountAggregateOutputType> | number
        }
      }
    }
    AssetDisposal: {
      payload: Prisma.$AssetDisposalPayload<ExtArgs>
      fields: Prisma.AssetDisposalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetDisposalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetDisposalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        findFirst: {
          args: Prisma.AssetDisposalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetDisposalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        findMany: {
          args: Prisma.AssetDisposalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        create: {
          args: Prisma.AssetDisposalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        createMany: {
          args: Prisma.AssetDisposalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetDisposalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        delete: {
          args: Prisma.AssetDisposalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        update: {
          args: Prisma.AssetDisposalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        deleteMany: {
          args: Prisma.AssetDisposalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetDisposalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetDisposalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        upsert: {
          args: Prisma.AssetDisposalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        aggregate: {
          args: Prisma.AssetDisposalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetDisposal>
        }
        groupBy: {
          args: Prisma.AssetDisposalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDisposalGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetDisposalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDisposalCountAggregateOutputType> | number
        }
      }
    }
    CapExBudget: {
      payload: Prisma.$CapExBudgetPayload<ExtArgs>
      fields: Prisma.CapExBudgetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapExBudgetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapExBudgetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        findFirst: {
          args: Prisma.CapExBudgetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapExBudgetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        findMany: {
          args: Prisma.CapExBudgetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        create: {
          args: Prisma.CapExBudgetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        createMany: {
          args: Prisma.CapExBudgetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapExBudgetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        delete: {
          args: Prisma.CapExBudgetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        update: {
          args: Prisma.CapExBudgetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        deleteMany: {
          args: Prisma.CapExBudgetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapExBudgetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapExBudgetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        upsert: {
          args: Prisma.CapExBudgetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        aggregate: {
          args: Prisma.CapExBudgetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapExBudget>
        }
        groupBy: {
          args: Prisma.CapExBudgetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExBudgetGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapExBudgetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExBudgetCountAggregateOutputType> | number
        }
      }
    }
    CapExItem: {
      payload: Prisma.$CapExItemPayload<ExtArgs>
      fields: Prisma.CapExItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapExItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapExItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        findFirst: {
          args: Prisma.CapExItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapExItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        findMany: {
          args: Prisma.CapExItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        create: {
          args: Prisma.CapExItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        createMany: {
          args: Prisma.CapExItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapExItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        delete: {
          args: Prisma.CapExItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        update: {
          args: Prisma.CapExItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        deleteMany: {
          args: Prisma.CapExItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapExItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapExItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        upsert: {
          args: Prisma.CapExItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        aggregate: {
          args: Prisma.CapExItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapExItem>
        }
        groupBy: {
          args: Prisma.CapExItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapExItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExItemCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ProjectScalarFieldEnum = {
  id: 'id',
  projectNumber: 'projectNumber',
  name: 'name',
  description: 'description',
  type: 'type',
  status: 'status',
  priority: 'priority',
  startDate: 'startDate',
  endDate: 'endDate',
  actualStartDate: 'actualStartDate',
  actualEndDate: 'actualEndDate',
  currency: 'currency',
  budgetAmount: 'budgetAmount',
  budgetSpent: 'budgetSpent',
  actualCost: 'actualCost',
  committedCost: 'committedCost',
  totalCosts: 'totalCosts',
  contractValue: 'contractValue',
  totalRevenue: 'totalRevenue',
  billedAmount: 'billedAmount',
  allocatedHours: 'allocatedHours',
  actualHours: 'actualHours',
  progressPercent: 'progressPercent',
  managerId: 'managerId',
  managerName: 'managerName',
  departmentId: 'departmentId',
  departmentName: 'departmentName',
  clientId: 'clientId',
  clientName: 'clientName',
  costCenterId: 'costCenterId',
  notes: 'notes',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const TimeEntryScalarFieldEnum = {
  id: 'id',
  date: 'date',
  hours: 'hours',
  description: 'description',
  billable: 'billable',
  billed: 'billed',
  hourlyRate: 'hourlyRate',
  userId: 'userId',
  userName: 'userName',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


export const CostCenterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  parentId: 'parentId',
  currency: 'currency',
  budgetAmount: 'budgetAmount',
  actualAmount: 'actualAmount',
  isActive: 'isActive',
  managerId: 'managerId',
  managerName: 'managerName',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  emailVerified: 'emailVerified',
  image: 'image',
  role: 'role',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  access_token: 'access_token',
  expires_at: 'expires_at',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  country: 'country',
  industry: 'industry',
  fiscalYearEnd: 'fiscalYearEnd',
  defaultCurrency: 'defaultCurrency',
  taxId: 'taxId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const FinancialAccountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  accountNumber: 'accountNumber',
  type: 'type',
  balance: 'balance',
  currency: 'currency',
  isActive: 'isActive',
  description: 'description',
  parentId: 'parentId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinancialAccountScalarFieldEnum = (typeof FinancialAccountScalarFieldEnum)[keyof typeof FinancialAccountScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  date: 'date',
  description: 'description',
  amount: 'amount',
  currency: 'currency',
  type: 'type',
  category: 'category',
  status: 'status',
  tags: 'tags',
  tokenized: 'tokenized',
  txHash: 'txHash',
  accountId: 'accountId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const ReceiptScalarFieldEnum = {
  id: 'id',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  fileSize: 'fileSize',
  vendor: 'vendor',
  amount: 'amount',
  date: 'date',
  extractedText: 'extractedText',
  confidence: 'confidence',
  category: 'category',
  status: 'status',
  deletedAt: 'deletedAt',
  transactionId: 'transactionId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


export const ChatChannelScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChatChannelScalarFieldEnum = (typeof ChatChannelScalarFieldEnum)[keyof typeof ChatChannelScalarFieldEnum]


export const ChatMessageScalarFieldEnum = {
  id: 'id',
  content: 'content',
  channelId: 'channelId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


export const UserSettingsScalarFieldEnum = {
  id: 'id',
  language: 'language',
  timezone: 'timezone',
  currency: 'currency',
  dateFormat: 'dateFormat',
  theme: 'theme',
  emailNotifications: 'emailNotifications',
  pushNotifications: 'pushNotifications',
  transactionNotifications: 'transactionNotifications',
  reportNotifications: 'reportNotifications',
  aiSuggestionNotifications: 'aiSuggestionNotifications',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


export const WalletScalarFieldEnum = {
  id: 'id',
  name: 'name',
  address: 'address',
  network: 'network',
  provider: 'provider',
  isActive: 'isActive',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


export const AISuggestionScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  impact: 'impact',
  priority: 'priority',
  status: 'status',
  metadata: 'metadata',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AISuggestionScalarFieldEnum = (typeof AISuggestionScalarFieldEnum)[keyof typeof AISuggestionScalarFieldEnum]


export const SavedReportScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  parameters: 'parameters',
  isScheduled: 'isScheduled',
  scheduleFreq: 'scheduleFreq',
  lastGenerated: 'lastGenerated',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SavedReportScalarFieldEnum = (typeof SavedReportScalarFieldEnum)[keyof typeof SavedReportScalarFieldEnum]


export const CorporateEntityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  jurisdiction: 'jurisdiction',
  taxId: 'taxId',
  incorporationDate: 'incorporationDate',
  ownershipPercent: 'ownershipPercent',
  revenue: 'revenue',
  expenses: 'expenses',
  taxLiability: 'taxLiability',
  effectiveTaxRate: 'effectiveTaxRate',
  isActive: 'isActive',
  parentId: 'parentId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CorporateEntityScalarFieldEnum = (typeof CorporateEntityScalarFieldEnum)[keyof typeof CorporateEntityScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  invoiceNumber: 'invoiceNumber',
  status: 'status',
  sender: 'sender',
  recipient: 'recipient',
  invoiceDate: 'invoiceDate',
  dueDate: 'dueDate',
  serviceDate: 'serviceDate',
  servicePeriodStart: 'servicePeriodStart',
  servicePeriodEnd: 'servicePeriodEnd',
  items: 'items',
  currency: 'currency',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  total: 'total',
  applyTax: 'applyTax',
  taxRate: 'taxRate',
  taxExemptReason: 'taxExemptReason',
  taxExemptNote: 'taxExemptNote',
  payment: 'payment',
  notes: 'notes',
  internalNotes: 'internalNotes',
  language: 'language',
  sentAt: 'sentAt',
  paidAt: 'paidAt',
  isRecurring: 'isRecurring',
  recurringInterval: 'recurringInterval',
  nextRecurringDate: 'nextRecurringDate',
  organizationId: 'organizationId',
  orderId: 'orderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const OrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  status: 'status',
  customerId: 'customerId',
  customerName: 'customerName',
  customerEmail: 'customerEmail',
  customerAddress: 'customerAddress',
  orderDate: 'orderDate',
  expectedDeliveryDate: 'expectedDeliveryDate',
  completedDate: 'completedDate',
  items: 'items',
  currency: 'currency',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  discountAmount: 'discountAmount',
  total: 'total',
  taxRate: 'taxRate',
  fulfilledQuantity: 'fulfilledQuantity',
  totalQuantity: 'totalQuantity',
  fulfillmentPercent: 'fulfillmentPercent',
  invoicedAmount: 'invoicedAmount',
  paidAmount: 'paidAmount',
  notes: 'notes',
  internalNotes: 'internalNotes',
  tags: 'tags',
  priority: 'priority',
  isRecurring: 'isRecurring',
  recurringInterval: 'recurringInterval',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId'
} as const

export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


export const ArchiveItemScalarFieldEnum = {
  id: 'id',
  category: 'category',
  status: 'status',
  originalId: 'originalId',
  originalType: 'originalType',
  title: 'title',
  description: 'description',
  amount: 'amount',
  currency: 'currency',
  counterparty: 'counterparty',
  itemDate: 'itemDate',
  archivedAt: 'archivedAt',
  restoredAt: 'restoredAt',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  tags: 'tags',
  attachments: 'attachments',
  metadata: 'metadata',
  archivedBy: 'archivedBy',
  restoredBy: 'restoredBy',
  archiveReason: 'archiveReason',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArchiveItemScalarFieldEnum = (typeof ArchiveItemScalarFieldEnum)[keyof typeof ArchiveItemScalarFieldEnum]


export const LiabilityScalarFieldEnum = {
  id: 'id',
  type: 'type',
  status: 'status',
  name: 'name',
  description: 'description',
  reference: 'reference',
  counterpartyId: 'counterpartyId',
  counterpartyName: 'counterpartyName',
  counterpartyType: 'counterpartyType',
  currency: 'currency',
  principalAmount: 'principalAmount',
  outstandingAmount: 'outstandingAmount',
  paidAmount: 'paidAmount',
  creditLimit: 'creditLimit',
  availableCredit: 'availableCredit',
  utilizationRate: 'utilizationRate',
  interestRate: 'interestRate',
  interestType: 'interestType',
  interestAccrued: 'interestAccrued',
  startDate: 'startDate',
  maturityDate: 'maturityDate',
  nextPaymentDate: 'nextPaymentDate',
  lastPaymentDate: 'lastPaymentDate',
  paymentFrequency: 'paymentFrequency',
  paymentAmount: 'paymentAmount',
  paymentSchedule: 'paymentSchedule',
  isSecured: 'isSecured',
  collateralDescription: 'collateralDescription',
  collateralValue: 'collateralValue',
  covenants: 'covenants',
  riskLevel: 'riskLevel',
  alertThreshold: 'alertThreshold',
  tags: 'tags',
  notes: 'notes',
  attachments: 'attachments',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilityScalarFieldEnum = (typeof LiabilityScalarFieldEnum)[keyof typeof LiabilityScalarFieldEnum]


export const LiabilityPaymentScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  principalAmount: 'principalAmount',
  interestAmount: 'interestAmount',
  feesAmount: 'feesAmount',
  currency: 'currency',
  paymentDate: 'paymentDate',
  dueDate: 'dueDate',
  status: 'status',
  reference: 'reference',
  transactionId: 'transactionId',
  notes: 'notes',
  liabilityId: 'liabilityId',
  createdAt: 'createdAt'
} as const

export type LiabilityPaymentScalarFieldEnum = (typeof LiabilityPaymentScalarFieldEnum)[keyof typeof LiabilityPaymentScalarFieldEnum]


export const InventoryItemScalarFieldEnum = {
  id: 'id',
  type: 'type',
  status: 'status',
  sku: 'sku',
  name: 'name',
  description: 'description',
  barcode: 'barcode',
  category: 'category',
  subcategory: 'subcategory',
  quantityOnHand: 'quantityOnHand',
  quantityReserved: 'quantityReserved',
  quantityAvailable: 'quantityAvailable',
  quantityOnOrder: 'quantityOnOrder',
  unitOfMeasure: 'unitOfMeasure',
  minimumStock: 'minimumStock',
  maximumStock: 'maximumStock',
  reorderPoint: 'reorderPoint',
  reorderQuantity: 'reorderQuantity',
  currency: 'currency',
  unitCost: 'unitCost',
  averageCost: 'averageCost',
  lastPurchaseCost: 'lastPurchaseCost',
  sellingPrice: 'sellingPrice',
  totalValue: 'totalValue',
  costingMethod: 'costingMethod',
  warehouseId: 'warehouseId',
  warehouseName: 'warehouseName',
  location: 'location',
  zone: 'zone',
  ownershipType: 'ownershipType',
  supplierId: 'supplierId',
  supplierName: 'supplierName',
  isSerialTracked: 'isSerialTracked',
  isBatchTracked: 'isBatchTracked',
  isExpiryTracked: 'isExpiryTracked',
  leadTimeDays: 'leadTimeDays',
  weight: 'weight',
  weightUnit: 'weightUnit',
  length: 'length',
  width: 'width',
  height: 'height',
  dimensionUnit: 'dimensionUnit',
  tags: 'tags',
  notes: 'notes',
  imageUrl: 'imageUrl',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


export const InventoryMovementScalarFieldEnum = {
  id: 'id',
  type: 'type',
  quantity: 'quantity',
  previousQuantity: 'previousQuantity',
  newQuantity: 'newQuantity',
  unitCost: 'unitCost',
  totalCost: 'totalCost',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  referenceNumber: 'referenceNumber',
  fromWarehouseId: 'fromWarehouseId',
  fromLocation: 'fromLocation',
  toWarehouseId: 'toWarehouseId',
  toLocation: 'toLocation',
  batchId: 'batchId',
  serialNumber: 'serialNumber',
  reason: 'reason',
  notes: 'notes',
  performedBy: 'performedBy',
  movementDate: 'movementDate',
  inventoryItemId: 'inventoryItemId',
  createdAt: 'createdAt'
} as const

export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


export const InventoryBatchScalarFieldEnum = {
  id: 'id',
  batchNumber: 'batchNumber',
  lotNumber: 'lotNumber',
  initialQuantity: 'initialQuantity',
  currentQuantity: 'currentQuantity',
  reservedQuantity: 'reservedQuantity',
  unitCost: 'unitCost',
  manufacturingDate: 'manufacturingDate',
  expiryDate: 'expiryDate',
  receivedDate: 'receivedDate',
  status: 'status',
  supplierId: 'supplierId',
  supplierBatchRef: 'supplierBatchRef',
  qualityStatus: 'qualityStatus',
  qualityNotes: 'qualityNotes',
  warehouseId: 'warehouseId',
  location: 'location',
  inventoryItemId: 'inventoryItemId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InventoryBatchScalarFieldEnum = (typeof InventoryBatchScalarFieldEnum)[keyof typeof InventoryBatchScalarFieldEnum]


export const ReceivableScalarFieldEnum = {
  id: 'id',
  originType: 'originType',
  originReferenceId: 'originReferenceId',
  creditorEntityId: 'creditorEntityId',
  debtorId: 'debtorId',
  debtorName: 'debtorName',
  debtorEmail: 'debtorEmail',
  debtorPhone: 'debtorPhone',
  debtorAddress: 'debtorAddress',
  currency: 'currency',
  originalAmount: 'originalAmount',
  outstandingAmount: 'outstandingAmount',
  paidAmount: 'paidAmount',
  disputedAmount: 'disputedAmount',
  writtenOffAmount: 'writtenOffAmount',
  issueDate: 'issueDate',
  dueDate: 'dueDate',
  expectedPaymentDate: 'expectedPaymentDate',
  lastActivityDate: 'lastActivityDate',
  status: 'status',
  riskLevel: 'riskLevel',
  daysOutstanding: 'daysOutstanding',
  agingBucket: 'agingBucket',
  isDisputed: 'isDisputed',
  disputeReason: 'disputeReason',
  disputeOpenedAt: 'disputeOpenedAt',
  disputeResolvedAt: 'disputeResolvedAt',
  collectionStage: 'collectionStage',
  collectionStartedAt: 'collectionStartedAt',
  collectionAgency: 'collectionAgency',
  autoRemindersEnabled: 'autoRemindersEnabled',
  nextReminderDate: 'nextReminderDate',
  reminderCount: 'reminderCount',
  reference: 'reference',
  description: 'description',
  notes: 'notes',
  internalNotes: 'internalNotes',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReceivableScalarFieldEnum = (typeof ReceivableScalarFieldEnum)[keyof typeof ReceivableScalarFieldEnum]


export const ReceivablePaymentScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  currency: 'currency',
  appliedAt: 'appliedAt',
  type: 'type',
  reference: 'reference',
  transactionId: 'transactionId',
  notes: 'notes',
  appliedBy: 'appliedBy',
  receivableId: 'receivableId',
  createdAt: 'createdAt'
} as const

export type ReceivablePaymentScalarFieldEnum = (typeof ReceivablePaymentScalarFieldEnum)[keyof typeof ReceivablePaymentScalarFieldEnum]


export const ReceivableEventScalarFieldEnum = {
  id: 'id',
  type: 'type',
  description: 'description',
  previousValue: 'previousValue',
  newValue: 'newValue',
  amount: 'amount',
  performedBy: 'performedBy',
  notes: 'notes',
  metadata: 'metadata',
  receivableId: 'receivableId',
  createdAt: 'createdAt'
} as const

export type ReceivableEventScalarFieldEnum = (typeof ReceivableEventScalarFieldEnum)[keyof typeof ReceivableEventScalarFieldEnum]


export const TreasuryAccountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  accountNumber: 'accountNumber',
  type: 'type',
  bankName: 'bankName',
  bankCode: 'bankCode',
  iban: 'iban',
  cashClassification: 'cashClassification',
  currency: 'currency',
  currentBalance: 'currentBalance',
  availableBalance: 'availableBalance',
  pendingInflows: 'pendingInflows',
  pendingOutflows: 'pendingOutflows',
  minimumBalance: 'minimumBalance',
  targetBalance: 'targetBalance',
  status: 'status',
  isMainAccount: 'isMainAccount',
  participatesInPooling: 'participatesInPooling',
  poolingRole: 'poolingRole',
  masterAccountId: 'masterAccountId',
  entityId: 'entityId',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryAccountScalarFieldEnum = (typeof TreasuryAccountScalarFieldEnum)[keyof typeof TreasuryAccountScalarFieldEnum]


export const CapitalBucketScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  currency: 'currency',
  targetAmount: 'targetAmount',
  currentAmount: 'currentAmount',
  minimumAmount: 'minimumAmount',
  fundingStatus: 'fundingStatus',
  fundingPercent: 'fundingPercent',
  priority: 'priority',
  isRequired: 'isRequired',
  autoFund: 'autoFund',
  fundingSourceAccountId: 'fundingSourceAccountId',
  timeHorizon: 'timeHorizon',
  targetDate: 'targetDate',
  notes: 'notes',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapitalBucketScalarFieldEnum = (typeof CapitalBucketScalarFieldEnum)[keyof typeof CapitalBucketScalarFieldEnum]


export const CreditFacilityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  status: 'status',
  lenderName: 'lenderName',
  lenderId: 'lenderId',
  currency: 'currency',
  facilityLimit: 'facilityLimit',
  drawnAmount: 'drawnAmount',
  availableAmount: 'availableAmount',
  pendingDrawdowns: 'pendingDrawdowns',
  utilizationRate: 'utilizationRate',
  utilizationAlert: 'utilizationAlert',
  interestRate: 'interestRate',
  interestType: 'interestType',
  spreadBps: 'spreadBps',
  commitmentFeeBps: 'commitmentFeeBps',
  arrangementFee: 'arrangementFee',
  startDate: 'startDate',
  maturityDate: 'maturityDate',
  nextReviewDate: 'nextReviewDate',
  covenants: 'covenants',
  covenantStatus: 'covenantStatus',
  isSecured: 'isSecured',
  securityDescription: 'securityDescription',
  reference: 'reference',
  notes: 'notes',
  documents: 'documents',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CreditFacilityScalarFieldEnum = (typeof CreditFacilityScalarFieldEnum)[keyof typeof CreditFacilityScalarFieldEnum]


export const FacilityDrawdownScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  currency: 'currency',
  drawdownDate: 'drawdownDate',
  repaidAmount: 'repaidAmount',
  outstandingAmount: 'outstandingAmount',
  status: 'status',
  interestRate: 'interestRate',
  accruedInterest: 'accruedInterest',
  maturityDate: 'maturityDate',
  reference: 'reference',
  purpose: 'purpose',
  notes: 'notes',
  facilityId: 'facilityId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityDrawdownScalarFieldEnum = (typeof FacilityDrawdownScalarFieldEnum)[keyof typeof FacilityDrawdownScalarFieldEnum]


export const TreasuryDecisionScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  status: 'status',
  priority: 'priority',
  currency: 'currency',
  amount: 'amount',
  riskDelta: 'riskDelta',
  requiresApproval: 'requiresApproval',
  approvalThreshold: 'approvalThreshold',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectedBy: 'rejectedBy',
  rejectedAt: 'rejectedAt',
  rejectionReason: 'rejectionReason',
  executionMode: 'executionMode',
  scheduledDate: 'scheduledDate',
  executedAt: 'executedAt',
  executedBy: 'executedBy',
  executionNotes: 'executionNotes',
  expiresAt: 'expiresAt',
  sourceAccountId: 'sourceAccountId',
  targetAccountId: 'targetAccountId',
  facilityId: 'facilityId',
  bucketId: 'bucketId',
  alternatives: 'alternatives',
  notes: 'notes',
  metadata: 'metadata',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryDecisionScalarFieldEnum = (typeof TreasuryDecisionScalarFieldEnum)[keyof typeof TreasuryDecisionScalarFieldEnum]


export const TreasuryScenarioScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  isActive: 'isActive',
  isBaseline: 'isBaseline',
  assumptions: 'assumptions',
  horizonDays: 'horizonDays',
  startDate: 'startDate',
  endDate: 'endDate',
  results: 'results',
  cashFlowProjection: 'cashFlowProjection',
  minimumCashDate: 'minimumCashDate',
  minimumCashAmount: 'minimumCashAmount',
  endingCashAmount: 'endingCashAmount',
  probabilityWeight: 'probabilityWeight',
  riskScore: 'riskScore',
  createdBy: 'createdBy',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryScenarioScalarFieldEnum = (typeof TreasuryScenarioScalarFieldEnum)[keyof typeof TreasuryScenarioScalarFieldEnum]


export const TreasuryCashMovementScalarFieldEnum = {
  id: 'id',
  type: 'type',
  category: 'category',
  amount: 'amount',
  currency: 'currency',
  balanceBefore: 'balanceBefore',
  balanceAfter: 'balanceAfter',
  movementDate: 'movementDate',
  valueDate: 'valueDate',
  description: 'description',
  reference: 'reference',
  counterparty: 'counterparty',
  status: 'status',
  transactionId: 'transactionId',
  decisionId: 'decisionId',
  accountId: 'accountId',
  createdAt: 'createdAt'
} as const

export type TreasuryCashMovementScalarFieldEnum = (typeof TreasuryCashMovementScalarFieldEnum)[keyof typeof TreasuryCashMovementScalarFieldEnum]


export const NettingOpportunityScalarFieldEnum = {
  id: 'id',
  entityAId: 'entityAId',
  entityAName: 'entityAName',
  entityBId: 'entityBId',
  entityBName: 'entityBName',
  currency: 'currency',
  amountAToB: 'amountAToB',
  amountBToA: 'amountBToA',
  netAmount: 'netAmount',
  netDirection: 'netDirection',
  grossAmount: 'grossAmount',
  savingsAmount: 'savingsAmount',
  savingsPercent: 'savingsPercent',
  status: 'status',
  executedAt: 'executedAt',
  executedBy: 'executedBy',
  validUntil: 'validUntil',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NettingOpportunityScalarFieldEnum = (typeof NettingOpportunityScalarFieldEnum)[keyof typeof NettingOpportunityScalarFieldEnum]


export const AssetScalarFieldEnum = {
  id: 'id',
  assetNumber: 'assetNumber',
  name: 'name',
  description: 'description',
  category: 'category',
  subcategory: 'subcategory',
  assetClass: 'assetClass',
  status: 'status',
  acquisitionDate: 'acquisitionDate',
  acquisitionType: 'acquisitionType',
  acquisitionCost: 'acquisitionCost',
  currency: 'currency',
  vendorId: 'vendorId',
  vendorName: 'vendorName',
  purchaseOrderRef: 'purchaseOrderRef',
  invoiceRef: 'invoiceRef',
  currentBookValue: 'currentBookValue',
  fairValue: 'fairValue',
  residualValue: 'residualValue',
  isDepreciable: 'isDepreciable',
  depreciationMethod: 'depreciationMethod',
  usefulLifeMonths: 'usefulLifeMonths',
  usefulLifeUnits: 'usefulLifeUnits',
  depreciationRate: 'depreciationRate',
  accumulatedDepreciation: 'accumulatedDepreciation',
  accumulatedImpairment: 'accumulatedImpairment',
  depreciationStartDate: 'depreciationStartDate',
  lastDepreciationDate: 'lastDepreciationDate',
  nextDepreciationDate: 'nextDepreciationDate',
  monthlyDepreciation: 'monthlyDepreciation',
  locationId: 'locationId',
  locationName: 'locationName',
  locationAddress: 'locationAddress',
  costCenterId: 'costCenterId',
  costCenterName: 'costCenterName',
  responsibleParty: 'responsibleParty',
  responsiblePartyId: 'responsiblePartyId',
  entityId: 'entityId',
  entityName: 'entityName',
  serialNumber: 'serialNumber',
  modelNumber: 'modelNumber',
  manufacturer: 'manufacturer',
  barcode: 'barcode',
  quantity: 'quantity',
  unitOfMeasure: 'unitOfMeasure',
  isInsured: 'isInsured',
  insurancePolicy: 'insurancePolicy',
  insuredValue: 'insuredValue',
  insuranceExpiry: 'insuranceExpiry',
  warrantyExpiry: 'warrantyExpiry',
  warrantyTerms: 'warrantyTerms',
  requiresMaintenance: 'requiresMaintenance',
  maintenanceSchedule: 'maintenanceSchedule',
  lastMaintenanceDate: 'lastMaintenanceDate',
  nextMaintenanceDate: 'nextMaintenanceDate',
  plannedDisposalDate: 'plannedDisposalDate',
  disposalMethod: 'disposalMethod',
  lastRevaluationDate: 'lastRevaluationDate',
  revaluationSurplus: 'revaluationSurplus',
  isComponent: 'isComponent',
  parentAssetId: 'parentAssetId',
  tags: 'tags',
  notes: 'notes',
  attachments: 'attachments',
  customFields: 'customFields',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


export const AssetDepreciationScalarFieldEnum = {
  id: 'id',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  depreciationAmount: 'depreciationAmount',
  accumulatedDepreciation: 'accumulatedDepreciation',
  openingBookValue: 'openingBookValue',
  closingBookValue: 'closingBookValue',
  method: 'method',
  rate: 'rate',
  status: 'status',
  journalEntryId: 'journalEntryId',
  postedAt: 'postedAt',
  postedBy: 'postedBy',
  bookType: 'bookType',
  notes: 'notes',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetDepreciationScalarFieldEnum = (typeof AssetDepreciationScalarFieldEnum)[keyof typeof AssetDepreciationScalarFieldEnum]


export const AssetEventScalarFieldEnum = {
  id: 'id',
  type: 'type',
  description: 'description',
  amount: 'amount',
  previousValue: 'previousValue',
  newValue: 'newValue',
  eventDate: 'eventDate',
  effectiveDate: 'effectiveDate',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  requiresApproval: 'requiresApproval',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  performedBy: 'performedBy',
  notes: 'notes',
  metadata: 'metadata',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetEventScalarFieldEnum = (typeof AssetEventScalarFieldEnum)[keyof typeof AssetEventScalarFieldEnum]


export const AssetTransferScalarFieldEnum = {
  id: 'id',
  transferDate: 'transferDate',
  effectiveDate: 'effectiveDate',
  transferType: 'transferType',
  fromEntityId: 'fromEntityId',
  fromEntityName: 'fromEntityName',
  fromCostCenterId: 'fromCostCenterId',
  fromCostCenterName: 'fromCostCenterName',
  fromLocationId: 'fromLocationId',
  fromLocationName: 'fromLocationName',
  fromResponsibleParty: 'fromResponsibleParty',
  toEntityId: 'toEntityId',
  toEntityName: 'toEntityName',
  toCostCenterId: 'toCostCenterId',
  toCostCenterName: 'toCostCenterName',
  toLocationId: 'toLocationId',
  toLocationName: 'toLocationName',
  toResponsibleParty: 'toResponsibleParty',
  bookValueAtTransfer: 'bookValueAtTransfer',
  accumulatedDepAtTransfer: 'accumulatedDepAtTransfer',
  status: 'status',
  requestedBy: 'requestedBy',
  requestedAt: 'requestedAt',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  reason: 'reason',
  notes: 'notes',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetTransferScalarFieldEnum = (typeof AssetTransferScalarFieldEnum)[keyof typeof AssetTransferScalarFieldEnum]


export const AssetDisposalScalarFieldEnum = {
  id: 'id',
  disposalDate: 'disposalDate',
  disposalType: 'disposalType',
  carryingAmount: 'carryingAmount',
  accumulatedDepreciation: 'accumulatedDepreciation',
  salePrice: 'salePrice',
  saleCurrency: 'saleCurrency',
  buyerName: 'buyerName',
  buyerReference: 'buyerReference',
  invoiceId: 'invoiceId',
  gainOrLoss: 'gainOrLoss',
  isGain: 'isGain',
  disposalCosts: 'disposalCosts',
  taxAmount: 'taxAmount',
  taxTreatment: 'taxTreatment',
  status: 'status',
  reason: 'reason',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  notes: 'notes',
  attachments: 'attachments',
  assetId: 'assetId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssetDisposalScalarFieldEnum = (typeof AssetDisposalScalarFieldEnum)[keyof typeof AssetDisposalScalarFieldEnum]


export const CapExBudgetScalarFieldEnum = {
  id: 'id',
  name: 'name',
  fiscalYear: 'fiscalYear',
  description: 'description',
  entityId: 'entityId',
  entityName: 'entityName',
  projectId: 'projectId',
  projectName: 'projectName',
  costCenterId: 'costCenterId',
  currency: 'currency',
  budgetAmount: 'budgetAmount',
  committedAmount: 'committedAmount',
  spentAmount: 'spentAmount',
  remainingAmount: 'remainingAmount',
  status: 'status',
  utilizationPercent: 'utilizationPercent',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapExBudgetScalarFieldEnum = (typeof CapExBudgetScalarFieldEnum)[keyof typeof CapExBudgetScalarFieldEnum]


export const CapExItemScalarFieldEnum = {
  id: 'id',
  description: 'description',
  category: 'category',
  estimatedAmount: 'estimatedAmount',
  actualAmount: 'actualAmount',
  variance: 'variance',
  status: 'status',
  classification: 'classification',
  classificationReason: 'classificationReason',
  assetId: 'assetId',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  plannedDate: 'plannedDate',
  actualDate: 'actualDate',
  notes: 'notes',
  budgetId: 'budgetId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapExItemScalarFieldEnum = (typeof CapExItemScalarFieldEnum)[keyof typeof CapExItemScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  project?: Prisma.ProjectOmit
  timeEntry?: Prisma.TimeEntryOmit
  costCenter?: Prisma.CostCenterOmit
  user?: Prisma.UserOmit
  account?: Prisma.AccountOmit
  session?: Prisma.SessionOmit
  verificationToken?: Prisma.VerificationTokenOmit
  organization?: Prisma.OrganizationOmit
  financialAccount?: Prisma.FinancialAccountOmit
  transaction?: Prisma.TransactionOmit
  receipt?: Prisma.ReceiptOmit
  chatChannel?: Prisma.ChatChannelOmit
  chatMessage?: Prisma.ChatMessageOmit
  userSettings?: Prisma.UserSettingsOmit
  wallet?: Prisma.WalletOmit
  aISuggestion?: Prisma.AISuggestionOmit
  savedReport?: Prisma.SavedReportOmit
  corporateEntity?: Prisma.CorporateEntityOmit
  invoice?: Prisma.InvoiceOmit
  order?: Prisma.OrderOmit
  archiveItem?: Prisma.ArchiveItemOmit
  liability?: Prisma.LiabilityOmit
  liabilityPayment?: Prisma.LiabilityPaymentOmit
  inventoryItem?: Prisma.InventoryItemOmit
  inventoryMovement?: Prisma.InventoryMovementOmit
  inventoryBatch?: Prisma.InventoryBatchOmit
  receivable?: Prisma.ReceivableOmit
  receivablePayment?: Prisma.ReceivablePaymentOmit
  receivableEvent?: Prisma.ReceivableEventOmit
  treasuryAccount?: Prisma.TreasuryAccountOmit
  capitalBucket?: Prisma.CapitalBucketOmit
  creditFacility?: Prisma.CreditFacilityOmit
  facilityDrawdown?: Prisma.FacilityDrawdownOmit
  treasuryDecision?: Prisma.TreasuryDecisionOmit
  treasuryScenario?: Prisma.TreasuryScenarioOmit
  treasuryCashMovement?: Prisma.TreasuryCashMovementOmit
  nettingOpportunity?: Prisma.NettingOpportunityOmit
  asset?: Prisma.AssetOmit
  assetDepreciation?: Prisma.AssetDepreciationOmit
  assetEvent?: Prisma.AssetEventOmit
  assetTransfer?: Prisma.AssetTransferOmit
  assetDisposal?: Prisma.AssetDisposalOmit
  capExBudget?: Prisma.CapExBudgetOmit
  capExItem?: Prisma.CapExItemOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

