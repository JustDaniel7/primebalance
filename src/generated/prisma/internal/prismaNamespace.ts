
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Account: 'Account',
  Session: 'Session',
  VerificationToken: 'VerificationToken',
  Organization: 'Organization',
  FinancialAccount: 'FinancialAccount',
  Transaction: 'Transaction',
  Receipt: 'Receipt',
  ChatChannel: 'ChatChannel',
  ChatMessage: 'ChatMessage',
  UserSettings: 'UserSettings',
  Wallet: 'Wallet',
  WalletToken: 'WalletToken',
  WalletTransaction: 'WalletTransaction',
  AISuggestion: 'AISuggestion',
  SavedReport: 'SavedReport',
  CorporateEntity: 'CorporateEntity',
  Invoice: 'Invoice',
  InvoiceVersion: 'InvoiceVersion',
  InvoiceAccountingEvent: 'InvoiceAccountingEvent',
  InvoicePayment: 'InvoicePayment',
  Order: 'Order',
  ArchiveRecord: 'ArchiveRecord',
  ArchiveLink: 'ArchiveLink',
  ArchiveVersion: 'ArchiveVersion',
  ArchiveAccessLog: 'ArchiveAccessLog',
  ArchiveRetentionPolicy: 'ArchiveRetentionPolicy',
  ArchiveExport: 'ArchiveExport',
  ArchiveImportBatch: 'ArchiveImportBatch',
  ArchiveAutomationRule: 'ArchiveAutomationRule',
  ArchiveException: 'ArchiveException',
  ArchiveSavedView: 'ArchiveSavedView',
  Liability: 'Liability',
  LiabilityEvent: 'LiabilityEvent',
  LiabilityPayment: 'LiabilityPayment',
  LiabilitySettlement: 'LiabilitySettlement',
  LiabilityAccrual: 'LiabilityAccrual',
  LiabilityCovenantCheck: 'LiabilityCovenantCheck',
  LiabilityImportBatch: 'LiabilityImportBatch',
  LiabilityAutomationRule: 'LiabilityAutomationRule',
  LiabilityException: 'LiabilityException',
  LiabilitySavedView: 'LiabilitySavedView',
  InventoryItem: 'InventoryItem',
  InventoryMovement: 'InventoryMovement',
  InventoryBatch: 'InventoryBatch',
  Receivable: 'Receivable',
  ReceivablePayment: 'ReceivablePayment',
  ReceivableEvent: 'ReceivableEvent',
  TreasuryAccount: 'TreasuryAccount',
  CapitalBucket: 'CapitalBucket',
  CreditFacility: 'CreditFacility',
  FacilityDrawdown: 'FacilityDrawdown',
  TreasuryDecision: 'TreasuryDecision',
  TreasuryScenario: 'TreasuryScenario',
  TreasuryCashMovement: 'TreasuryCashMovement',
  NettingOpportunity: 'NettingOpportunity',
  Asset: 'Asset',
  AssetDepreciation: 'AssetDepreciation',
  AssetEvent: 'AssetEvent',
  AssetTransfer: 'AssetTransfer',
  AssetDisposal: 'AssetDisposal',
  CapExBudget: 'CapExBudget',
  CapExItem: 'CapExItem',
  CostCenter: 'CostCenter',
  Project: 'Project',
  ProjectMilestone: 'ProjectMilestone',
  TimeEntry: 'TimeEntry',
  InternalChargeback: 'InternalChargeback',
  AccountingPeriod: 'AccountingPeriod',
  CloseChecklistItem: 'CloseChecklistItem',
  PeriodMissingItem: 'PeriodMissingItem',
  PeriodAdjustment: 'PeriodAdjustment',
  PeriodAuditEntry: 'PeriodAuditEntry',
  Customer: 'Customer',
  CustomerContact: 'CustomerContact',
  CustomerPayment: 'CustomerPayment',
  CustomerCreditEvent: 'CustomerCreditEvent',
  CustomerRevenue: 'CustomerRevenue',
  CustomerRiskIndicator: 'CustomerRiskIndicator',
  Supplier: 'Supplier',
  SupplierContact: 'SupplierContact',
  SupplierBalance: 'SupplierBalance',
  SupplierPayment: 'SupplierPayment',
  SupplierReliability: 'SupplierReliability',
  SupplierSpend: 'SupplierSpend',
  SupplierRisk: 'SupplierRisk',
  NettingAgreement: 'NettingAgreement',
  NettingParty: 'NettingParty',
  NettingSession: 'NettingSession',
  NettingPosition: 'NettingPosition',
  NettingTransaction: 'NettingTransaction',
  SettlementInstruction: 'SettlementInstruction',
  OffsetEntry: 'OffsetEntry',
  Offer: 'Offer',
  OfferVersion: 'OfferVersion',
  OfferAuditLog: 'OfferAuditLog',
  OfferTemplate: 'OfferTemplate',
  Task: 'Task',
  TaskAssignee: 'TaskAssignee',
  TaskWatcher: 'TaskWatcher',
  TaskTag: 'TaskTag',
  TaskTagLink: 'TaskTagLink',
  TaskDependency: 'TaskDependency',
  TaskComment: 'TaskComment',
  TaskActivity: 'TaskActivity',
  TaskAttachment: 'TaskAttachment',
  Risk: 'Risk',
  RiskMitigationStep: 'RiskMitigationStep',
  TaskRiskLink: 'TaskRiskLink',
  RiskComment: 'RiskComment',
  RiskActivity: 'RiskActivity',
  TaskNotification: 'TaskNotification',
  SavedTaskFilter: 'SavedTaskFilter',
  RevenueForecast: 'RevenueForecast',
  RevenueLineItem: 'RevenueLineItem',
  CostForecast: 'CostForecast',
  CostLineItem: 'CostLineItem',
  CashForecast: 'CashForecast',
  CashForecastPeriod: 'CashForecastPeriod',
  ForecastScenario: 'ForecastScenario',
  ForecastAssumption: 'ForecastAssumption',
  ForecastAlert: 'ForecastAlert',
  ForecastAnnotation: 'ForecastAnnotation',
  ForecastVariance: 'ForecastVariance',
  Scenario: 'Scenario',
  ScenarioAssumption: 'ScenarioAssumption',
  StressTest: 'StressTest',
  SimulationState: 'SimulationState',
  ScenarioComment: 'ScenarioComment',
  ScenarioDecision: 'ScenarioDecision',
  ScenarioChangeEvent: 'ScenarioChangeEvent',
  KPI: 'KPI',
  KPIHistory: 'KPIHistory',
  KPIAlert: 'KPIAlert',
  KPITarget: 'KPITarget',
  KPIBenchmark: 'KPIBenchmark',
  FXRate: 'FXRate',
  FXExposure: 'FXExposure',
  FXConversion: 'FXConversion',
  FXScenario: 'FXScenario',
  FXForecast: 'FXForecast',
  FXCost: 'FXCost',
  FXRiskIndicator: 'FXRiskIndicator',
  FXAuditLog: 'FXAuditLog',
  InvestorSnapshot: 'InvestorSnapshot',
  BoardReport: 'BoardReport',
  RunwayProjection: 'RunwayProjection',
  InvestorAccessLog: 'InvestorAccessLog',
  CashflowItem: 'CashflowItem',
  LiquidityScenario: 'LiquidityScenario',
  LiquidityGap: 'LiquidityGap',
  LiquidityRiskSignal: 'LiquidityRiskSignal',
  LiquidityAuditLog: 'LiquidityAuditLog',
  LiquidityPosition: 'LiquidityPosition'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "account" | "session" | "verificationToken" | "organization" | "financialAccount" | "transaction" | "receipt" | "chatChannel" | "chatMessage" | "userSettings" | "wallet" | "walletToken" | "walletTransaction" | "aISuggestion" | "savedReport" | "corporateEntity" | "invoice" | "invoiceVersion" | "invoiceAccountingEvent" | "invoicePayment" | "order" | "archiveRecord" | "archiveLink" | "archiveVersion" | "archiveAccessLog" | "archiveRetentionPolicy" | "archiveExport" | "archiveImportBatch" | "archiveAutomationRule" | "archiveException" | "archiveSavedView" | "liability" | "liabilityEvent" | "liabilityPayment" | "liabilitySettlement" | "liabilityAccrual" | "liabilityCovenantCheck" | "liabilityImportBatch" | "liabilityAutomationRule" | "liabilityException" | "liabilitySavedView" | "inventoryItem" | "inventoryMovement" | "inventoryBatch" | "receivable" | "receivablePayment" | "receivableEvent" | "treasuryAccount" | "capitalBucket" | "creditFacility" | "facilityDrawdown" | "treasuryDecision" | "treasuryScenario" | "treasuryCashMovement" | "nettingOpportunity" | "asset" | "assetDepreciation" | "assetEvent" | "assetTransfer" | "assetDisposal" | "capExBudget" | "capExItem" | "costCenter" | "project" | "projectMilestone" | "timeEntry" | "internalChargeback" | "accountingPeriod" | "closeChecklistItem" | "periodMissingItem" | "periodAdjustment" | "periodAuditEntry" | "customer" | "customerContact" | "customerPayment" | "customerCreditEvent" | "customerRevenue" | "customerRiskIndicator" | "supplier" | "supplierContact" | "supplierBalance" | "supplierPayment" | "supplierReliability" | "supplierSpend" | "supplierRisk" | "nettingAgreement" | "nettingParty" | "nettingSession" | "nettingPosition" | "nettingTransaction" | "settlementInstruction" | "offsetEntry" | "offer" | "offerVersion" | "offerAuditLog" | "offerTemplate" | "task" | "taskAssignee" | "taskWatcher" | "taskTag" | "taskTagLink" | "taskDependency" | "taskComment" | "taskActivity" | "taskAttachment" | "risk" | "riskMitigationStep" | "taskRiskLink" | "riskComment" | "riskActivity" | "taskNotification" | "savedTaskFilter" | "revenueForecast" | "revenueLineItem" | "costForecast" | "costLineItem" | "cashForecast" | "cashForecastPeriod" | "forecastScenario" | "forecastAssumption" | "forecastAlert" | "forecastAnnotation" | "forecastVariance" | "scenario" | "scenarioAssumption" | "stressTest" | "simulationState" | "scenarioComment" | "scenarioDecision" | "scenarioChangeEvent" | "kPI" | "kPIHistory" | "kPIAlert" | "kPITarget" | "kPIBenchmark" | "fXRate" | "fXExposure" | "fXConversion" | "fXScenario" | "fXForecast" | "fXCost" | "fXRiskIndicator" | "fXAuditLog" | "investorSnapshot" | "boardReport" | "runwayProjection" | "investorAccessLog" | "cashflowItem" | "liquidityScenario" | "liquidityGap" | "liquidityRiskSignal" | "liquidityAuditLog" | "liquidityPosition"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    FinancialAccount: {
      payload: Prisma.$FinancialAccountPayload<ExtArgs>
      fields: Prisma.FinancialAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        findFirst: {
          args: Prisma.FinancialAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        findMany: {
          args: Prisma.FinancialAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        create: {
          args: Prisma.FinancialAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        createMany: {
          args: Prisma.FinancialAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        delete: {
          args: Prisma.FinancialAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        update: {
          args: Prisma.FinancialAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        deleteMany: {
          args: Prisma.FinancialAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>[]
        }
        upsert: {
          args: Prisma.FinancialAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialAccountPayload>
        }
        aggregate: {
          args: Prisma.FinancialAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialAccount>
        }
        groupBy: {
          args: Prisma.FinancialAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialAccountCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    Receipt: {
      payload: Prisma.$ReceiptPayload<ExtArgs>
      fields: Prisma.ReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findFirst: {
          args: Prisma.ReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findMany: {
          args: Prisma.ReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        create: {
          args: Prisma.ReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        createMany: {
          args: Prisma.ReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        delete: {
          args: Prisma.ReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        update: {
          args: Prisma.ReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        deleteMany: {
          args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        upsert: {
          args: Prisma.ReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        aggregate: {
          args: Prisma.ReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceipt>
        }
        groupBy: {
          args: Prisma.ReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptCountAggregateOutputType> | number
        }
      }
    }
    ChatChannel: {
      payload: Prisma.$ChatChannelPayload<ExtArgs>
      fields: Prisma.ChatChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChatChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChatChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        findFirst: {
          args: Prisma.ChatChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChatChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        findMany: {
          args: Prisma.ChatChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        create: {
          args: Prisma.ChatChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        createMany: {
          args: Prisma.ChatChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChatChannelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        delete: {
          args: Prisma.ChatChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        update: {
          args: Prisma.ChatChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        deleteMany: {
          args: Prisma.ChatChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChatChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChatChannelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>[]
        }
        upsert: {
          args: Prisma.ChatChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatChannelPayload>
        }
        aggregate: {
          args: Prisma.ChatChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatChannel>
        }
        groupBy: {
          args: Prisma.ChatChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChatChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatChannelCountAggregateOutputType> | number
        }
      }
    }
    ChatMessage: {
      payload: Prisma.$ChatMessagePayload<ExtArgs>
      fields: Prisma.ChatMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        findFirst: {
          args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        findMany: {
          args: Prisma.ChatMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        create: {
          args: Prisma.ChatMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        createMany: {
          args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        delete: {
          args: Prisma.ChatMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        update: {
          args: Prisma.ChatMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        deleteMany: {
          args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
        }
        upsert: {
          args: Prisma.ChatMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatMessagePayload>
        }
        aggregate: {
          args: Prisma.ChatMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatMessage>
        }
        groupBy: {
          args: Prisma.ChatMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChatMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatMessageCountAggregateOutputType> | number
        }
      }
    }
    UserSettings: {
      payload: Prisma.$UserSettingsPayload<ExtArgs>
      fields: Prisma.UserSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findFirst: {
          args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        findMany: {
          args: Prisma.UserSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        create: {
          args: Prisma.UserSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        createMany: {
          args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        delete: {
          args: Prisma.UserSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        update: {
          args: Prisma.UserSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        deleteMany: {
          args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
        }
        upsert: {
          args: Prisma.UserSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSettingsPayload>
        }
        aggregate: {
          args: Prisma.UserSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSettings>
        }
        groupBy: {
          args: Prisma.UserSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSettingsCountAggregateOutputType> | number
        }
      }
    }
    Wallet: {
      payload: Prisma.$WalletPayload<ExtArgs>
      fields: Prisma.WalletFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findFirst: {
          args: Prisma.WalletFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findMany: {
          args: Prisma.WalletFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        create: {
          args: Prisma.WalletCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        createMany: {
          args: Prisma.WalletCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        delete: {
          args: Prisma.WalletDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        update: {
          args: Prisma.WalletUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        deleteMany: {
          args: Prisma.WalletDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        upsert: {
          args: Prisma.WalletUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        aggregate: {
          args: Prisma.WalletAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWallet>
        }
        groupBy: {
          args: Prisma.WalletGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletCountAggregateOutputType> | number
        }
      }
    }
    WalletToken: {
      payload: Prisma.$WalletTokenPayload<ExtArgs>
      fields: Prisma.WalletTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        findFirst: {
          args: Prisma.WalletTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        findMany: {
          args: Prisma.WalletTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>[]
        }
        create: {
          args: Prisma.WalletTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        createMany: {
          args: Prisma.WalletTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>[]
        }
        delete: {
          args: Prisma.WalletTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        update: {
          args: Prisma.WalletTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        deleteMany: {
          args: Prisma.WalletTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>[]
        }
        upsert: {
          args: Prisma.WalletTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTokenPayload>
        }
        aggregate: {
          args: Prisma.WalletTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletToken>
        }
        groupBy: {
          args: Prisma.WalletTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletTokenCountAggregateOutputType> | number
        }
      }
    }
    WalletTransaction: {
      payload: Prisma.$WalletTransactionPayload<ExtArgs>
      fields: Prisma.WalletTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        findFirst: {
          args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        findMany: {
          args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
        }
        create: {
          args: Prisma.WalletTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        createMany: {
          args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
        }
        delete: {
          args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        update: {
          args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        deleteMany: {
          args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
        }
        upsert: {
          args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
        }
        aggregate: {
          args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWalletTransaction>
        }
        groupBy: {
          args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletTransactionCountAggregateOutputType> | number
        }
      }
    }
    AISuggestion: {
      payload: Prisma.$AISuggestionPayload<ExtArgs>
      fields: Prisma.AISuggestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AISuggestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AISuggestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        findFirst: {
          args: Prisma.AISuggestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AISuggestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        findMany: {
          args: Prisma.AISuggestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        create: {
          args: Prisma.AISuggestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        createMany: {
          args: Prisma.AISuggestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AISuggestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        delete: {
          args: Prisma.AISuggestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        update: {
          args: Prisma.AISuggestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        deleteMany: {
          args: Prisma.AISuggestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AISuggestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AISuggestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>[]
        }
        upsert: {
          args: Prisma.AISuggestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AISuggestionPayload>
        }
        aggregate: {
          args: Prisma.AISuggestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAISuggestion>
        }
        groupBy: {
          args: Prisma.AISuggestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AISuggestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AISuggestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AISuggestionCountAggregateOutputType> | number
        }
      }
    }
    SavedReport: {
      payload: Prisma.$SavedReportPayload<ExtArgs>
      fields: Prisma.SavedReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SavedReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SavedReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        findFirst: {
          args: Prisma.SavedReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SavedReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        findMany: {
          args: Prisma.SavedReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        create: {
          args: Prisma.SavedReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        createMany: {
          args: Prisma.SavedReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SavedReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        delete: {
          args: Prisma.SavedReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        update: {
          args: Prisma.SavedReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        deleteMany: {
          args: Prisma.SavedReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SavedReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SavedReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>[]
        }
        upsert: {
          args: Prisma.SavedReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedReportPayload>
        }
        aggregate: {
          args: Prisma.SavedReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSavedReport>
        }
        groupBy: {
          args: Prisma.SavedReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.SavedReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedReportCountAggregateOutputType> | number
        }
      }
    }
    CorporateEntity: {
      payload: Prisma.$CorporateEntityPayload<ExtArgs>
      fields: Prisma.CorporateEntityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CorporateEntityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CorporateEntityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        findFirst: {
          args: Prisma.CorporateEntityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CorporateEntityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        findMany: {
          args: Prisma.CorporateEntityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        create: {
          args: Prisma.CorporateEntityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        createMany: {
          args: Prisma.CorporateEntityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CorporateEntityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        delete: {
          args: Prisma.CorporateEntityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        update: {
          args: Prisma.CorporateEntityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        deleteMany: {
          args: Prisma.CorporateEntityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CorporateEntityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CorporateEntityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>[]
        }
        upsert: {
          args: Prisma.CorporateEntityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CorporateEntityPayload>
        }
        aggregate: {
          args: Prisma.CorporateEntityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCorporateEntity>
        }
        groupBy: {
          args: Prisma.CorporateEntityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CorporateEntityGroupByOutputType>[]
        }
        count: {
          args: Prisma.CorporateEntityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CorporateEntityCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    InvoiceVersion: {
      payload: Prisma.$InvoiceVersionPayload<ExtArgs>
      fields: Prisma.InvoiceVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        findFirst: {
          args: Prisma.InvoiceVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        findMany: {
          args: Prisma.InvoiceVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>[]
        }
        create: {
          args: Prisma.InvoiceVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        createMany: {
          args: Prisma.InvoiceVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>[]
        }
        delete: {
          args: Prisma.InvoiceVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        update: {
          args: Prisma.InvoiceVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        deleteMany: {
          args: Prisma.InvoiceVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>[]
        }
        upsert: {
          args: Prisma.InvoiceVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceVersionPayload>
        }
        aggregate: {
          args: Prisma.InvoiceVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceVersion>
        }
        groupBy: {
          args: Prisma.InvoiceVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceVersionCountAggregateOutputType> | number
        }
      }
    }
    InvoiceAccountingEvent: {
      payload: Prisma.$InvoiceAccountingEventPayload<ExtArgs>
      fields: Prisma.InvoiceAccountingEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceAccountingEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceAccountingEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        findFirst: {
          args: Prisma.InvoiceAccountingEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceAccountingEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        findMany: {
          args: Prisma.InvoiceAccountingEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>[]
        }
        create: {
          args: Prisma.InvoiceAccountingEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        createMany: {
          args: Prisma.InvoiceAccountingEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceAccountingEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>[]
        }
        delete: {
          args: Prisma.InvoiceAccountingEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        update: {
          args: Prisma.InvoiceAccountingEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        deleteMany: {
          args: Prisma.InvoiceAccountingEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceAccountingEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceAccountingEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>[]
        }
        upsert: {
          args: Prisma.InvoiceAccountingEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceAccountingEventPayload>
        }
        aggregate: {
          args: Prisma.InvoiceAccountingEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceAccountingEvent>
        }
        groupBy: {
          args: Prisma.InvoiceAccountingEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceAccountingEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceAccountingEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceAccountingEventCountAggregateOutputType> | number
        }
      }
    }
    InvoicePayment: {
      payload: Prisma.$InvoicePaymentPayload<ExtArgs>
      fields: Prisma.InvoicePaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoicePaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        findFirst: {
          args: Prisma.InvoicePaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoicePaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        findMany: {
          args: Prisma.InvoicePaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
        }
        create: {
          args: Prisma.InvoicePaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        createMany: {
          args: Prisma.InvoicePaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoicePaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
        }
        delete: {
          args: Prisma.InvoicePaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        update: {
          args: Prisma.InvoicePaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        deleteMany: {
          args: Prisma.InvoicePaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoicePaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
        }
        upsert: {
          args: Prisma.InvoicePaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
        }
        aggregate: {
          args: Prisma.InvoicePaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoicePayment>
        }
        groupBy: {
          args: Prisma.InvoicePaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoicePaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoicePaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoicePaymentCountAggregateOutputType> | number
        }
      }
    }
    Order: {
      payload: Prisma.$OrderPayload<ExtArgs>
      fields: Prisma.OrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findFirst: {
          args: Prisma.OrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        findMany: {
          args: Prisma.OrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        create: {
          args: Prisma.OrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        createMany: {
          args: Prisma.OrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        delete: {
          args: Prisma.OrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        update: {
          args: Prisma.OrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        deleteMany: {
          args: Prisma.OrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>[]
        }
        upsert: {
          args: Prisma.OrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderPayload>
        }
        aggregate: {
          args: Prisma.OrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrder>
        }
        groupBy: {
          args: Prisma.OrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderCountAggregateOutputType> | number
        }
      }
    }
    ArchiveRecord: {
      payload: Prisma.$ArchiveRecordPayload<ExtArgs>
      fields: Prisma.ArchiveRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        findFirst: {
          args: Prisma.ArchiveRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        findMany: {
          args: Prisma.ArchiveRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>[]
        }
        create: {
          args: Prisma.ArchiveRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        createMany: {
          args: Prisma.ArchiveRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>[]
        }
        delete: {
          args: Prisma.ArchiveRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        update: {
          args: Prisma.ArchiveRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRecordPayload>
        }
        aggregate: {
          args: Prisma.ArchiveRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveRecord>
        }
        groupBy: {
          args: Prisma.ArchiveRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveRecordCountAggregateOutputType> | number
        }
      }
    }
    ArchiveLink: {
      payload: Prisma.$ArchiveLinkPayload<ExtArgs>
      fields: Prisma.ArchiveLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        findFirst: {
          args: Prisma.ArchiveLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        findMany: {
          args: Prisma.ArchiveLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>[]
        }
        create: {
          args: Prisma.ArchiveLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        createMany: {
          args: Prisma.ArchiveLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>[]
        }
        delete: {
          args: Prisma.ArchiveLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        update: {
          args: Prisma.ArchiveLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveLinkPayload>
        }
        aggregate: {
          args: Prisma.ArchiveLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveLink>
        }
        groupBy: {
          args: Prisma.ArchiveLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveLinkCountAggregateOutputType> | number
        }
      }
    }
    ArchiveVersion: {
      payload: Prisma.$ArchiveVersionPayload<ExtArgs>
      fields: Prisma.ArchiveVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        findFirst: {
          args: Prisma.ArchiveVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        findMany: {
          args: Prisma.ArchiveVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>[]
        }
        create: {
          args: Prisma.ArchiveVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        createMany: {
          args: Prisma.ArchiveVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>[]
        }
        delete: {
          args: Prisma.ArchiveVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        update: {
          args: Prisma.ArchiveVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveVersionPayload>
        }
        aggregate: {
          args: Prisma.ArchiveVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveVersion>
        }
        groupBy: {
          args: Prisma.ArchiveVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveVersionCountAggregateOutputType> | number
        }
      }
    }
    ArchiveAccessLog: {
      payload: Prisma.$ArchiveAccessLogPayload<ExtArgs>
      fields: Prisma.ArchiveAccessLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveAccessLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveAccessLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        findFirst: {
          args: Prisma.ArchiveAccessLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveAccessLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        findMany: {
          args: Prisma.ArchiveAccessLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>[]
        }
        create: {
          args: Prisma.ArchiveAccessLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        createMany: {
          args: Prisma.ArchiveAccessLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveAccessLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>[]
        }
        delete: {
          args: Prisma.ArchiveAccessLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        update: {
          args: Prisma.ArchiveAccessLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveAccessLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveAccessLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveAccessLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveAccessLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAccessLogPayload>
        }
        aggregate: {
          args: Prisma.ArchiveAccessLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveAccessLog>
        }
        groupBy: {
          args: Prisma.ArchiveAccessLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveAccessLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveAccessLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveAccessLogCountAggregateOutputType> | number
        }
      }
    }
    ArchiveRetentionPolicy: {
      payload: Prisma.$ArchiveRetentionPolicyPayload<ExtArgs>
      fields: Prisma.ArchiveRetentionPolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveRetentionPolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveRetentionPolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        findFirst: {
          args: Prisma.ArchiveRetentionPolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveRetentionPolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        findMany: {
          args: Prisma.ArchiveRetentionPolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>[]
        }
        create: {
          args: Prisma.ArchiveRetentionPolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        createMany: {
          args: Prisma.ArchiveRetentionPolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveRetentionPolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>[]
        }
        delete: {
          args: Prisma.ArchiveRetentionPolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        update: {
          args: Prisma.ArchiveRetentionPolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveRetentionPolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveRetentionPolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveRetentionPolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveRetentionPolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveRetentionPolicyPayload>
        }
        aggregate: {
          args: Prisma.ArchiveRetentionPolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveRetentionPolicy>
        }
        groupBy: {
          args: Prisma.ArchiveRetentionPolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveRetentionPolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveRetentionPolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveRetentionPolicyCountAggregateOutputType> | number
        }
      }
    }
    ArchiveExport: {
      payload: Prisma.$ArchiveExportPayload<ExtArgs>
      fields: Prisma.ArchiveExportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveExportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveExportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        findFirst: {
          args: Prisma.ArchiveExportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveExportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        findMany: {
          args: Prisma.ArchiveExportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>[]
        }
        create: {
          args: Prisma.ArchiveExportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        createMany: {
          args: Prisma.ArchiveExportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveExportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>[]
        }
        delete: {
          args: Prisma.ArchiveExportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        update: {
          args: Prisma.ArchiveExportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveExportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveExportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveExportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveExportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExportPayload>
        }
        aggregate: {
          args: Prisma.ArchiveExportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveExport>
        }
        groupBy: {
          args: Prisma.ArchiveExportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveExportGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveExportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveExportCountAggregateOutputType> | number
        }
      }
    }
    ArchiveImportBatch: {
      payload: Prisma.$ArchiveImportBatchPayload<ExtArgs>
      fields: Prisma.ArchiveImportBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveImportBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveImportBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        findFirst: {
          args: Prisma.ArchiveImportBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveImportBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        findMany: {
          args: Prisma.ArchiveImportBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>[]
        }
        create: {
          args: Prisma.ArchiveImportBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        createMany: {
          args: Prisma.ArchiveImportBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveImportBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>[]
        }
        delete: {
          args: Prisma.ArchiveImportBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        update: {
          args: Prisma.ArchiveImportBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveImportBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveImportBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveImportBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveImportBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveImportBatchPayload>
        }
        aggregate: {
          args: Prisma.ArchiveImportBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveImportBatch>
        }
        groupBy: {
          args: Prisma.ArchiveImportBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveImportBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveImportBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveImportBatchCountAggregateOutputType> | number
        }
      }
    }
    ArchiveAutomationRule: {
      payload: Prisma.$ArchiveAutomationRulePayload<ExtArgs>
      fields: Prisma.ArchiveAutomationRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveAutomationRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveAutomationRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        findFirst: {
          args: Prisma.ArchiveAutomationRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveAutomationRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        findMany: {
          args: Prisma.ArchiveAutomationRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>[]
        }
        create: {
          args: Prisma.ArchiveAutomationRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        createMany: {
          args: Prisma.ArchiveAutomationRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveAutomationRuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>[]
        }
        delete: {
          args: Prisma.ArchiveAutomationRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        update: {
          args: Prisma.ArchiveAutomationRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        deleteMany: {
          args: Prisma.ArchiveAutomationRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveAutomationRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveAutomationRuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>[]
        }
        upsert: {
          args: Prisma.ArchiveAutomationRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveAutomationRulePayload>
        }
        aggregate: {
          args: Prisma.ArchiveAutomationRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveAutomationRule>
        }
        groupBy: {
          args: Prisma.ArchiveAutomationRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveAutomationRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveAutomationRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveAutomationRuleCountAggregateOutputType> | number
        }
      }
    }
    ArchiveException: {
      payload: Prisma.$ArchiveExceptionPayload<ExtArgs>
      fields: Prisma.ArchiveExceptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveExceptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveExceptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        findFirst: {
          args: Prisma.ArchiveExceptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveExceptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        findMany: {
          args: Prisma.ArchiveExceptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>[]
        }
        create: {
          args: Prisma.ArchiveExceptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        createMany: {
          args: Prisma.ArchiveExceptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveExceptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>[]
        }
        delete: {
          args: Prisma.ArchiveExceptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        update: {
          args: Prisma.ArchiveExceptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveExceptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveExceptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveExceptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveExceptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveExceptionPayload>
        }
        aggregate: {
          args: Prisma.ArchiveExceptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveException>
        }
        groupBy: {
          args: Prisma.ArchiveExceptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveExceptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveExceptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveExceptionCountAggregateOutputType> | number
        }
      }
    }
    ArchiveSavedView: {
      payload: Prisma.$ArchiveSavedViewPayload<ExtArgs>
      fields: Prisma.ArchiveSavedViewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArchiveSavedViewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArchiveSavedViewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        findFirst: {
          args: Prisma.ArchiveSavedViewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArchiveSavedViewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        findMany: {
          args: Prisma.ArchiveSavedViewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>[]
        }
        create: {
          args: Prisma.ArchiveSavedViewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        createMany: {
          args: Prisma.ArchiveSavedViewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArchiveSavedViewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>[]
        }
        delete: {
          args: Prisma.ArchiveSavedViewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        update: {
          args: Prisma.ArchiveSavedViewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        deleteMany: {
          args: Prisma.ArchiveSavedViewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArchiveSavedViewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArchiveSavedViewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>[]
        }
        upsert: {
          args: Prisma.ArchiveSavedViewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArchiveSavedViewPayload>
        }
        aggregate: {
          args: Prisma.ArchiveSavedViewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArchiveSavedView>
        }
        groupBy: {
          args: Prisma.ArchiveSavedViewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveSavedViewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArchiveSavedViewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArchiveSavedViewCountAggregateOutputType> | number
        }
      }
    }
    Liability: {
      payload: Prisma.$LiabilityPayload<ExtArgs>
      fields: Prisma.LiabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        findFirst: {
          args: Prisma.LiabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        findMany: {
          args: Prisma.LiabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        create: {
          args: Prisma.LiabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        createMany: {
          args: Prisma.LiabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        delete: {
          args: Prisma.LiabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        update: {
          args: Prisma.LiabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPayload>
        }
        aggregate: {
          args: Prisma.LiabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiability>
        }
        groupBy: {
          args: Prisma.LiabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityCountAggregateOutputType> | number
        }
      }
    }
    LiabilityEvent: {
      payload: Prisma.$LiabilityEventPayload<ExtArgs>
      fields: Prisma.LiabilityEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        findFirst: {
          args: Prisma.LiabilityEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        findMany: {
          args: Prisma.LiabilityEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>[]
        }
        create: {
          args: Prisma.LiabilityEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        createMany: {
          args: Prisma.LiabilityEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>[]
        }
        delete: {
          args: Prisma.LiabilityEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        update: {
          args: Prisma.LiabilityEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityEventPayload>
        }
        aggregate: {
          args: Prisma.LiabilityEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityEvent>
        }
        groupBy: {
          args: Prisma.LiabilityEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityEventCountAggregateOutputType> | number
        }
      }
    }
    LiabilityPayment: {
      payload: Prisma.$LiabilityPaymentPayload<ExtArgs>
      fields: Prisma.LiabilityPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        findFirst: {
          args: Prisma.LiabilityPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        findMany: {
          args: Prisma.LiabilityPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        create: {
          args: Prisma.LiabilityPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        createMany: {
          args: Prisma.LiabilityPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        delete: {
          args: Prisma.LiabilityPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        update: {
          args: Prisma.LiabilityPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityPaymentPayload>
        }
        aggregate: {
          args: Prisma.LiabilityPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityPayment>
        }
        groupBy: {
          args: Prisma.LiabilityPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityPaymentCountAggregateOutputType> | number
        }
      }
    }
    LiabilitySettlement: {
      payload: Prisma.$LiabilitySettlementPayload<ExtArgs>
      fields: Prisma.LiabilitySettlementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilitySettlementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilitySettlementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        findFirst: {
          args: Prisma.LiabilitySettlementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilitySettlementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        findMany: {
          args: Prisma.LiabilitySettlementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>[]
        }
        create: {
          args: Prisma.LiabilitySettlementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        createMany: {
          args: Prisma.LiabilitySettlementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilitySettlementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>[]
        }
        delete: {
          args: Prisma.LiabilitySettlementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        update: {
          args: Prisma.LiabilitySettlementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        deleteMany: {
          args: Prisma.LiabilitySettlementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilitySettlementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilitySettlementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>[]
        }
        upsert: {
          args: Prisma.LiabilitySettlementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySettlementPayload>
        }
        aggregate: {
          args: Prisma.LiabilitySettlementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilitySettlement>
        }
        groupBy: {
          args: Prisma.LiabilitySettlementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilitySettlementGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilitySettlementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilitySettlementCountAggregateOutputType> | number
        }
      }
    }
    LiabilityAccrual: {
      payload: Prisma.$LiabilityAccrualPayload<ExtArgs>
      fields: Prisma.LiabilityAccrualFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityAccrualFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityAccrualFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        findFirst: {
          args: Prisma.LiabilityAccrualFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityAccrualFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        findMany: {
          args: Prisma.LiabilityAccrualFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>[]
        }
        create: {
          args: Prisma.LiabilityAccrualCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        createMany: {
          args: Prisma.LiabilityAccrualCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityAccrualCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>[]
        }
        delete: {
          args: Prisma.LiabilityAccrualDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        update: {
          args: Prisma.LiabilityAccrualUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityAccrualDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityAccrualUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityAccrualUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityAccrualUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAccrualPayload>
        }
        aggregate: {
          args: Prisma.LiabilityAccrualAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityAccrual>
        }
        groupBy: {
          args: Prisma.LiabilityAccrualGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityAccrualGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityAccrualCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityAccrualCountAggregateOutputType> | number
        }
      }
    }
    LiabilityCovenantCheck: {
      payload: Prisma.$LiabilityCovenantCheckPayload<ExtArgs>
      fields: Prisma.LiabilityCovenantCheckFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityCovenantCheckFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityCovenantCheckFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        findFirst: {
          args: Prisma.LiabilityCovenantCheckFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityCovenantCheckFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        findMany: {
          args: Prisma.LiabilityCovenantCheckFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>[]
        }
        create: {
          args: Prisma.LiabilityCovenantCheckCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        createMany: {
          args: Prisma.LiabilityCovenantCheckCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityCovenantCheckCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>[]
        }
        delete: {
          args: Prisma.LiabilityCovenantCheckDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        update: {
          args: Prisma.LiabilityCovenantCheckUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityCovenantCheckDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityCovenantCheckUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityCovenantCheckUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityCovenantCheckUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityCovenantCheckPayload>
        }
        aggregate: {
          args: Prisma.LiabilityCovenantCheckAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityCovenantCheck>
        }
        groupBy: {
          args: Prisma.LiabilityCovenantCheckGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityCovenantCheckGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityCovenantCheckCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityCovenantCheckCountAggregateOutputType> | number
        }
      }
    }
    LiabilityImportBatch: {
      payload: Prisma.$LiabilityImportBatchPayload<ExtArgs>
      fields: Prisma.LiabilityImportBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityImportBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityImportBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        findFirst: {
          args: Prisma.LiabilityImportBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityImportBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        findMany: {
          args: Prisma.LiabilityImportBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>[]
        }
        create: {
          args: Prisma.LiabilityImportBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        createMany: {
          args: Prisma.LiabilityImportBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityImportBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>[]
        }
        delete: {
          args: Prisma.LiabilityImportBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        update: {
          args: Prisma.LiabilityImportBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityImportBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityImportBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityImportBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityImportBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityImportBatchPayload>
        }
        aggregate: {
          args: Prisma.LiabilityImportBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityImportBatch>
        }
        groupBy: {
          args: Prisma.LiabilityImportBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityImportBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityImportBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityImportBatchCountAggregateOutputType> | number
        }
      }
    }
    LiabilityAutomationRule: {
      payload: Prisma.$LiabilityAutomationRulePayload<ExtArgs>
      fields: Prisma.LiabilityAutomationRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityAutomationRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityAutomationRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        findFirst: {
          args: Prisma.LiabilityAutomationRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityAutomationRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        findMany: {
          args: Prisma.LiabilityAutomationRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>[]
        }
        create: {
          args: Prisma.LiabilityAutomationRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        createMany: {
          args: Prisma.LiabilityAutomationRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityAutomationRuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>[]
        }
        delete: {
          args: Prisma.LiabilityAutomationRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        update: {
          args: Prisma.LiabilityAutomationRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        deleteMany: {
          args: Prisma.LiabilityAutomationRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityAutomationRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityAutomationRuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>[]
        }
        upsert: {
          args: Prisma.LiabilityAutomationRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityAutomationRulePayload>
        }
        aggregate: {
          args: Prisma.LiabilityAutomationRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityAutomationRule>
        }
        groupBy: {
          args: Prisma.LiabilityAutomationRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityAutomationRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityAutomationRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityAutomationRuleCountAggregateOutputType> | number
        }
      }
    }
    LiabilityException: {
      payload: Prisma.$LiabilityExceptionPayload<ExtArgs>
      fields: Prisma.LiabilityExceptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilityExceptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilityExceptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        findFirst: {
          args: Prisma.LiabilityExceptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilityExceptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        findMany: {
          args: Prisma.LiabilityExceptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>[]
        }
        create: {
          args: Prisma.LiabilityExceptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        createMany: {
          args: Prisma.LiabilityExceptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilityExceptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>[]
        }
        delete: {
          args: Prisma.LiabilityExceptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        update: {
          args: Prisma.LiabilityExceptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        deleteMany: {
          args: Prisma.LiabilityExceptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilityExceptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilityExceptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>[]
        }
        upsert: {
          args: Prisma.LiabilityExceptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilityExceptionPayload>
        }
        aggregate: {
          args: Prisma.LiabilityExceptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilityException>
        }
        groupBy: {
          args: Prisma.LiabilityExceptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityExceptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilityExceptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilityExceptionCountAggregateOutputType> | number
        }
      }
    }
    LiabilitySavedView: {
      payload: Prisma.$LiabilitySavedViewPayload<ExtArgs>
      fields: Prisma.LiabilitySavedViewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiabilitySavedViewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiabilitySavedViewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        findFirst: {
          args: Prisma.LiabilitySavedViewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiabilitySavedViewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        findMany: {
          args: Prisma.LiabilitySavedViewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>[]
        }
        create: {
          args: Prisma.LiabilitySavedViewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        createMany: {
          args: Prisma.LiabilitySavedViewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiabilitySavedViewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>[]
        }
        delete: {
          args: Prisma.LiabilitySavedViewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        update: {
          args: Prisma.LiabilitySavedViewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        deleteMany: {
          args: Prisma.LiabilitySavedViewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiabilitySavedViewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiabilitySavedViewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>[]
        }
        upsert: {
          args: Prisma.LiabilitySavedViewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiabilitySavedViewPayload>
        }
        aggregate: {
          args: Prisma.LiabilitySavedViewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiabilitySavedView>
        }
        groupBy: {
          args: Prisma.LiabilitySavedViewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilitySavedViewGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiabilitySavedViewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiabilitySavedViewCountAggregateOutputType> | number
        }
      }
    }
    InventoryItem: {
      payload: Prisma.$InventoryItemPayload<ExtArgs>
      fields: Prisma.InventoryItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findFirst: {
          args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findMany: {
          args: Prisma.InventoryItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        create: {
          args: Prisma.InventoryItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        createMany: {
          args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        delete: {
          args: Prisma.InventoryItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        update: {
          args: Prisma.InventoryItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        deleteMany: {
          args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        upsert: {
          args: Prisma.InventoryItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        aggregate: {
          args: Prisma.InventoryItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryItem>
        }
        groupBy: {
          args: Prisma.InventoryItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemCountAggregateOutputType> | number
        }
      }
    }
    InventoryMovement: {
      payload: Prisma.$InventoryMovementPayload<ExtArgs>
      fields: Prisma.InventoryMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        findFirst: {
          args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        findMany: {
          args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        create: {
          args: Prisma.InventoryMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        createMany: {
          args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        delete: {
          args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        update: {
          args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        deleteMany: {
          args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
        }
        upsert: {
          args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
        }
        aggregate: {
          args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryMovement>
        }
        groupBy: {
          args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryMovementCountAggregateOutputType> | number
        }
      }
    }
    InventoryBatch: {
      payload: Prisma.$InventoryBatchPayload<ExtArgs>
      fields: Prisma.InventoryBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        findFirst: {
          args: Prisma.InventoryBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        findMany: {
          args: Prisma.InventoryBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        create: {
          args: Prisma.InventoryBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        createMany: {
          args: Prisma.InventoryBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        delete: {
          args: Prisma.InventoryBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        update: {
          args: Prisma.InventoryBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        deleteMany: {
          args: Prisma.InventoryBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
        }
        upsert: {
          args: Prisma.InventoryBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
        }
        aggregate: {
          args: Prisma.InventoryBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryBatch>
        }
        groupBy: {
          args: Prisma.InventoryBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryBatchCountAggregateOutputType> | number
        }
      }
    }
    Receivable: {
      payload: Prisma.$ReceivablePayload<ExtArgs>
      fields: Prisma.ReceivableFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivableFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivableFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        findFirst: {
          args: Prisma.ReceivableFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivableFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        findMany: {
          args: Prisma.ReceivableFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        create: {
          args: Prisma.ReceivableCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        createMany: {
          args: Prisma.ReceivableCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivableCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        delete: {
          args: Prisma.ReceivableDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        update: {
          args: Prisma.ReceivableUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        deleteMany: {
          args: Prisma.ReceivableDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivableUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivableUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
        }
        upsert: {
          args: Prisma.ReceivableUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePayload>
        }
        aggregate: {
          args: Prisma.ReceivableAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivable>
        }
        groupBy: {
          args: Prisma.ReceivableGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivableCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableCountAggregateOutputType> | number
        }
      }
    }
    ReceivablePayment: {
      payload: Prisma.$ReceivablePaymentPayload<ExtArgs>
      fields: Prisma.ReceivablePaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivablePaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivablePaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        findFirst: {
          args: Prisma.ReceivablePaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivablePaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        findMany: {
          args: Prisma.ReceivablePaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        create: {
          args: Prisma.ReceivablePaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        createMany: {
          args: Prisma.ReceivablePaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivablePaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        delete: {
          args: Prisma.ReceivablePaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        update: {
          args: Prisma.ReceivablePaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        deleteMany: {
          args: Prisma.ReceivablePaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivablePaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivablePaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>[]
        }
        upsert: {
          args: Prisma.ReceivablePaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivablePaymentPayload>
        }
        aggregate: {
          args: Prisma.ReceivablePaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivablePayment>
        }
        groupBy: {
          args: Prisma.ReceivablePaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivablePaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivablePaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivablePaymentCountAggregateOutputType> | number
        }
      }
    }
    ReceivableEvent: {
      payload: Prisma.$ReceivableEventPayload<ExtArgs>
      fields: Prisma.ReceivableEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceivableEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceivableEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        findFirst: {
          args: Prisma.ReceivableEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceivableEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        findMany: {
          args: Prisma.ReceivableEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        create: {
          args: Prisma.ReceivableEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        createMany: {
          args: Prisma.ReceivableEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceivableEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        delete: {
          args: Prisma.ReceivableEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        update: {
          args: Prisma.ReceivableEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        deleteMany: {
          args: Prisma.ReceivableEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceivableEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceivableEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>[]
        }
        upsert: {
          args: Prisma.ReceivableEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceivableEventPayload>
        }
        aggregate: {
          args: Prisma.ReceivableEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceivableEvent>
        }
        groupBy: {
          args: Prisma.ReceivableEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceivableEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceivableEventCountAggregateOutputType> | number
        }
      }
    }
    TreasuryAccount: {
      payload: Prisma.$TreasuryAccountPayload<ExtArgs>
      fields: Prisma.TreasuryAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        findFirst: {
          args: Prisma.TreasuryAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        findMany: {
          args: Prisma.TreasuryAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        create: {
          args: Prisma.TreasuryAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        createMany: {
          args: Prisma.TreasuryAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        delete: {
          args: Prisma.TreasuryAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        update: {
          args: Prisma.TreasuryAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryAccountPayload>
        }
        aggregate: {
          args: Prisma.TreasuryAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryAccount>
        }
        groupBy: {
          args: Prisma.TreasuryAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryAccountCountAggregateOutputType> | number
        }
      }
    }
    CapitalBucket: {
      payload: Prisma.$CapitalBucketPayload<ExtArgs>
      fields: Prisma.CapitalBucketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapitalBucketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapitalBucketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        findFirst: {
          args: Prisma.CapitalBucketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapitalBucketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        findMany: {
          args: Prisma.CapitalBucketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        create: {
          args: Prisma.CapitalBucketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        createMany: {
          args: Prisma.CapitalBucketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapitalBucketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        delete: {
          args: Prisma.CapitalBucketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        update: {
          args: Prisma.CapitalBucketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        deleteMany: {
          args: Prisma.CapitalBucketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapitalBucketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapitalBucketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>[]
        }
        upsert: {
          args: Prisma.CapitalBucketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapitalBucketPayload>
        }
        aggregate: {
          args: Prisma.CapitalBucketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapitalBucket>
        }
        groupBy: {
          args: Prisma.CapitalBucketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapitalBucketGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapitalBucketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapitalBucketCountAggregateOutputType> | number
        }
      }
    }
    CreditFacility: {
      payload: Prisma.$CreditFacilityPayload<ExtArgs>
      fields: Prisma.CreditFacilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CreditFacilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CreditFacilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        findFirst: {
          args: Prisma.CreditFacilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CreditFacilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        findMany: {
          args: Prisma.CreditFacilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        create: {
          args: Prisma.CreditFacilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        createMany: {
          args: Prisma.CreditFacilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CreditFacilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        delete: {
          args: Prisma.CreditFacilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        update: {
          args: Prisma.CreditFacilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        deleteMany: {
          args: Prisma.CreditFacilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CreditFacilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CreditFacilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>[]
        }
        upsert: {
          args: Prisma.CreditFacilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CreditFacilityPayload>
        }
        aggregate: {
          args: Prisma.CreditFacilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCreditFacility>
        }
        groupBy: {
          args: Prisma.CreditFacilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditFacilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.CreditFacilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CreditFacilityCountAggregateOutputType> | number
        }
      }
    }
    FacilityDrawdown: {
      payload: Prisma.$FacilityDrawdownPayload<ExtArgs>
      fields: Prisma.FacilityDrawdownFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityDrawdownFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityDrawdownFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        findFirst: {
          args: Prisma.FacilityDrawdownFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityDrawdownFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        findMany: {
          args: Prisma.FacilityDrawdownFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        create: {
          args: Prisma.FacilityDrawdownCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        createMany: {
          args: Prisma.FacilityDrawdownCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityDrawdownCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        delete: {
          args: Prisma.FacilityDrawdownDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        update: {
          args: Prisma.FacilityDrawdownUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        deleteMany: {
          args: Prisma.FacilityDrawdownDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityDrawdownUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityDrawdownUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>[]
        }
        upsert: {
          args: Prisma.FacilityDrawdownUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityDrawdownPayload>
        }
        aggregate: {
          args: Prisma.FacilityDrawdownAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacilityDrawdown>
        }
        groupBy: {
          args: Prisma.FacilityDrawdownGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityDrawdownGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityDrawdownCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityDrawdownCountAggregateOutputType> | number
        }
      }
    }
    TreasuryDecision: {
      payload: Prisma.$TreasuryDecisionPayload<ExtArgs>
      fields: Prisma.TreasuryDecisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryDecisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryDecisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        findFirst: {
          args: Prisma.TreasuryDecisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryDecisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        findMany: {
          args: Prisma.TreasuryDecisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        create: {
          args: Prisma.TreasuryDecisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        createMany: {
          args: Prisma.TreasuryDecisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryDecisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        delete: {
          args: Prisma.TreasuryDecisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        update: {
          args: Prisma.TreasuryDecisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryDecisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryDecisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryDecisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryDecisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryDecisionPayload>
        }
        aggregate: {
          args: Prisma.TreasuryDecisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryDecision>
        }
        groupBy: {
          args: Prisma.TreasuryDecisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryDecisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryDecisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryDecisionCountAggregateOutputType> | number
        }
      }
    }
    TreasuryScenario: {
      payload: Prisma.$TreasuryScenarioPayload<ExtArgs>
      fields: Prisma.TreasuryScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        findFirst: {
          args: Prisma.TreasuryScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        findMany: {
          args: Prisma.TreasuryScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        create: {
          args: Prisma.TreasuryScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        createMany: {
          args: Prisma.TreasuryScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        delete: {
          args: Prisma.TreasuryScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        update: {
          args: Prisma.TreasuryScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryScenarioPayload>
        }
        aggregate: {
          args: Prisma.TreasuryScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryScenario>
        }
        groupBy: {
          args: Prisma.TreasuryScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryScenarioCountAggregateOutputType> | number
        }
      }
    }
    TreasuryCashMovement: {
      payload: Prisma.$TreasuryCashMovementPayload<ExtArgs>
      fields: Prisma.TreasuryCashMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TreasuryCashMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TreasuryCashMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        findFirst: {
          args: Prisma.TreasuryCashMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TreasuryCashMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        findMany: {
          args: Prisma.TreasuryCashMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        create: {
          args: Prisma.TreasuryCashMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        createMany: {
          args: Prisma.TreasuryCashMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TreasuryCashMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        delete: {
          args: Prisma.TreasuryCashMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        update: {
          args: Prisma.TreasuryCashMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        deleteMany: {
          args: Prisma.TreasuryCashMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TreasuryCashMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TreasuryCashMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>[]
        }
        upsert: {
          args: Prisma.TreasuryCashMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TreasuryCashMovementPayload>
        }
        aggregate: {
          args: Prisma.TreasuryCashMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTreasuryCashMovement>
        }
        groupBy: {
          args: Prisma.TreasuryCashMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryCashMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.TreasuryCashMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TreasuryCashMovementCountAggregateOutputType> | number
        }
      }
    }
    NettingOpportunity: {
      payload: Prisma.$NettingOpportunityPayload<ExtArgs>
      fields: Prisma.NettingOpportunityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingOpportunityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingOpportunityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        findFirst: {
          args: Prisma.NettingOpportunityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingOpportunityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        findMany: {
          args: Prisma.NettingOpportunityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        create: {
          args: Prisma.NettingOpportunityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        createMany: {
          args: Prisma.NettingOpportunityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingOpportunityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        delete: {
          args: Prisma.NettingOpportunityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        update: {
          args: Prisma.NettingOpportunityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        deleteMany: {
          args: Prisma.NettingOpportunityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingOpportunityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingOpportunityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>[]
        }
        upsert: {
          args: Prisma.NettingOpportunityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingOpportunityPayload>
        }
        aggregate: {
          args: Prisma.NettingOpportunityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingOpportunity>
        }
        groupBy: {
          args: Prisma.NettingOpportunityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingOpportunityGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingOpportunityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingOpportunityCountAggregateOutputType> | number
        }
      }
    }
    Asset: {
      payload: Prisma.$AssetPayload<ExtArgs>
      fields: Prisma.AssetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findFirst: {
          args: Prisma.AssetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findMany: {
          args: Prisma.AssetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        create: {
          args: Prisma.AssetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        createMany: {
          args: Prisma.AssetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        delete: {
          args: Prisma.AssetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        update: {
          args: Prisma.AssetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        deleteMany: {
          args: Prisma.AssetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        upsert: {
          args: Prisma.AssetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        aggregate: {
          args: Prisma.AssetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAsset>
        }
        groupBy: {
          args: Prisma.AssetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetCountAggregateOutputType> | number
        }
      }
    }
    AssetDepreciation: {
      payload: Prisma.$AssetDepreciationPayload<ExtArgs>
      fields: Prisma.AssetDepreciationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetDepreciationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetDepreciationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        findFirst: {
          args: Prisma.AssetDepreciationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetDepreciationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        findMany: {
          args: Prisma.AssetDepreciationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        create: {
          args: Prisma.AssetDepreciationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        createMany: {
          args: Prisma.AssetDepreciationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetDepreciationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        delete: {
          args: Prisma.AssetDepreciationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        update: {
          args: Prisma.AssetDepreciationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        deleteMany: {
          args: Prisma.AssetDepreciationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetDepreciationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetDepreciationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
        }
        upsert: {
          args: Prisma.AssetDepreciationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
        }
        aggregate: {
          args: Prisma.AssetDepreciationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetDepreciation>
        }
        groupBy: {
          args: Prisma.AssetDepreciationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDepreciationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetDepreciationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDepreciationCountAggregateOutputType> | number
        }
      }
    }
    AssetEvent: {
      payload: Prisma.$AssetEventPayload<ExtArgs>
      fields: Prisma.AssetEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        findFirst: {
          args: Prisma.AssetEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        findMany: {
          args: Prisma.AssetEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        create: {
          args: Prisma.AssetEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        createMany: {
          args: Prisma.AssetEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        delete: {
          args: Prisma.AssetEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        update: {
          args: Prisma.AssetEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        deleteMany: {
          args: Prisma.AssetEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>[]
        }
        upsert: {
          args: Prisma.AssetEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetEventPayload>
        }
        aggregate: {
          args: Prisma.AssetEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetEvent>
        }
        groupBy: {
          args: Prisma.AssetEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetEventCountAggregateOutputType> | number
        }
      }
    }
    AssetTransfer: {
      payload: Prisma.$AssetTransferPayload<ExtArgs>
      fields: Prisma.AssetTransferFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetTransferFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetTransferFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        findFirst: {
          args: Prisma.AssetTransferFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetTransferFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        findMany: {
          args: Prisma.AssetTransferFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        create: {
          args: Prisma.AssetTransferCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        createMany: {
          args: Prisma.AssetTransferCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetTransferCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        delete: {
          args: Prisma.AssetTransferDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        update: {
          args: Prisma.AssetTransferUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        deleteMany: {
          args: Prisma.AssetTransferDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetTransferUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetTransferUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>[]
        }
        upsert: {
          args: Prisma.AssetTransferUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetTransferPayload>
        }
        aggregate: {
          args: Prisma.AssetTransferAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetTransfer>
        }
        groupBy: {
          args: Prisma.AssetTransferGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetTransferGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetTransferCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetTransferCountAggregateOutputType> | number
        }
      }
    }
    AssetDisposal: {
      payload: Prisma.$AssetDisposalPayload<ExtArgs>
      fields: Prisma.AssetDisposalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetDisposalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetDisposalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        findFirst: {
          args: Prisma.AssetDisposalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetDisposalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        findMany: {
          args: Prisma.AssetDisposalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        create: {
          args: Prisma.AssetDisposalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        createMany: {
          args: Prisma.AssetDisposalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetDisposalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        delete: {
          args: Prisma.AssetDisposalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        update: {
          args: Prisma.AssetDisposalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        deleteMany: {
          args: Prisma.AssetDisposalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetDisposalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetDisposalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
        }
        upsert: {
          args: Prisma.AssetDisposalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
        }
        aggregate: {
          args: Prisma.AssetDisposalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetDisposal>
        }
        groupBy: {
          args: Prisma.AssetDisposalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDisposalGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetDisposalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetDisposalCountAggregateOutputType> | number
        }
      }
    }
    CapExBudget: {
      payload: Prisma.$CapExBudgetPayload<ExtArgs>
      fields: Prisma.CapExBudgetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapExBudgetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapExBudgetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        findFirst: {
          args: Prisma.CapExBudgetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapExBudgetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        findMany: {
          args: Prisma.CapExBudgetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        create: {
          args: Prisma.CapExBudgetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        createMany: {
          args: Prisma.CapExBudgetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapExBudgetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        delete: {
          args: Prisma.CapExBudgetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        update: {
          args: Prisma.CapExBudgetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        deleteMany: {
          args: Prisma.CapExBudgetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapExBudgetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapExBudgetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>[]
        }
        upsert: {
          args: Prisma.CapExBudgetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExBudgetPayload>
        }
        aggregate: {
          args: Prisma.CapExBudgetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapExBudget>
        }
        groupBy: {
          args: Prisma.CapExBudgetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExBudgetGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapExBudgetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExBudgetCountAggregateOutputType> | number
        }
      }
    }
    CapExItem: {
      payload: Prisma.$CapExItemPayload<ExtArgs>
      fields: Prisma.CapExItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CapExItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CapExItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        findFirst: {
          args: Prisma.CapExItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CapExItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        findMany: {
          args: Prisma.CapExItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        create: {
          args: Prisma.CapExItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        createMany: {
          args: Prisma.CapExItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CapExItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        delete: {
          args: Prisma.CapExItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        update: {
          args: Prisma.CapExItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        deleteMany: {
          args: Prisma.CapExItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CapExItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CapExItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>[]
        }
        upsert: {
          args: Prisma.CapExItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CapExItemPayload>
        }
        aggregate: {
          args: Prisma.CapExItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCapExItem>
        }
        groupBy: {
          args: Prisma.CapExItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CapExItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CapExItemCountAggregateOutputType> | number
        }
      }
    }
    CostCenter: {
      payload: Prisma.$CostCenterPayload<ExtArgs>
      fields: Prisma.CostCenterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostCenterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostCenterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findFirst: {
          args: Prisma.CostCenterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostCenterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        findMany: {
          args: Prisma.CostCenterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        create: {
          args: Prisma.CostCenterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        createMany: {
          args: Prisma.CostCenterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostCenterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        delete: {
          args: Prisma.CostCenterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        update: {
          args: Prisma.CostCenterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        deleteMany: {
          args: Prisma.CostCenterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostCenterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostCenterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>[]
        }
        upsert: {
          args: Prisma.CostCenterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCenterPayload>
        }
        aggregate: {
          args: Prisma.CostCenterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostCenter>
        }
        groupBy: {
          args: Prisma.CostCenterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostCenterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCenterCountAggregateOutputType> | number
        }
      }
    }
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    ProjectMilestone: {
      payload: Prisma.$ProjectMilestonePayload<ExtArgs>
      fields: Prisma.ProjectMilestoneFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectMilestoneFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectMilestoneFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        findFirst: {
          args: Prisma.ProjectMilestoneFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectMilestoneFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        findMany: {
          args: Prisma.ProjectMilestoneFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>[]
        }
        create: {
          args: Prisma.ProjectMilestoneCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        createMany: {
          args: Prisma.ProjectMilestoneCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectMilestoneCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>[]
        }
        delete: {
          args: Prisma.ProjectMilestoneDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        update: {
          args: Prisma.ProjectMilestoneUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        deleteMany: {
          args: Prisma.ProjectMilestoneDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectMilestoneUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectMilestoneUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>[]
        }
        upsert: {
          args: Prisma.ProjectMilestoneUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectMilestonePayload>
        }
        aggregate: {
          args: Prisma.ProjectMilestoneAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectMilestone>
        }
        groupBy: {
          args: Prisma.ProjectMilestoneGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectMilestoneGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectMilestoneCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectMilestoneCountAggregateOutputType> | number
        }
      }
    }
    TimeEntry: {
      payload: Prisma.$TimeEntryPayload<ExtArgs>
      fields: Prisma.TimeEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findFirst: {
          args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        findMany: {
          args: Prisma.TimeEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        create: {
          args: Prisma.TimeEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        createMany: {
          args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        delete: {
          args: Prisma.TimeEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        update: {
          args: Prisma.TimeEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        deleteMany: {
          args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
        }
        upsert: {
          args: Prisma.TimeEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeEntryPayload>
        }
        aggregate: {
          args: Prisma.TimeEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeEntry>
        }
        groupBy: {
          args: Prisma.TimeEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeEntryCountAggregateOutputType> | number
        }
      }
    }
    InternalChargeback: {
      payload: Prisma.$InternalChargebackPayload<ExtArgs>
      fields: Prisma.InternalChargebackFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InternalChargebackFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InternalChargebackFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        findFirst: {
          args: Prisma.InternalChargebackFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InternalChargebackFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        findMany: {
          args: Prisma.InternalChargebackFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>[]
        }
        create: {
          args: Prisma.InternalChargebackCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        createMany: {
          args: Prisma.InternalChargebackCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InternalChargebackCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>[]
        }
        delete: {
          args: Prisma.InternalChargebackDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        update: {
          args: Prisma.InternalChargebackUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        deleteMany: {
          args: Prisma.InternalChargebackDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InternalChargebackUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InternalChargebackUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>[]
        }
        upsert: {
          args: Prisma.InternalChargebackUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InternalChargebackPayload>
        }
        aggregate: {
          args: Prisma.InternalChargebackAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInternalChargeback>
        }
        groupBy: {
          args: Prisma.InternalChargebackGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InternalChargebackGroupByOutputType>[]
        }
        count: {
          args: Prisma.InternalChargebackCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InternalChargebackCountAggregateOutputType> | number
        }
      }
    }
    AccountingPeriod: {
      payload: Prisma.$AccountingPeriodPayload<ExtArgs>
      fields: Prisma.AccountingPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountingPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountingPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        findFirst: {
          args: Prisma.AccountingPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountingPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        findMany: {
          args: Prisma.AccountingPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>[]
        }
        create: {
          args: Prisma.AccountingPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        createMany: {
          args: Prisma.AccountingPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountingPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>[]
        }
        delete: {
          args: Prisma.AccountingPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        update: {
          args: Prisma.AccountingPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        deleteMany: {
          args: Prisma.AccountingPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountingPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountingPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>[]
        }
        upsert: {
          args: Prisma.AccountingPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingPeriodPayload>
        }
        aggregate: {
          args: Prisma.AccountingPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccountingPeriod>
        }
        groupBy: {
          args: Prisma.AccountingPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountingPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingPeriodCountAggregateOutputType> | number
        }
      }
    }
    CloseChecklistItem: {
      payload: Prisma.$CloseChecklistItemPayload<ExtArgs>
      fields: Prisma.CloseChecklistItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CloseChecklistItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CloseChecklistItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        findFirst: {
          args: Prisma.CloseChecklistItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CloseChecklistItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        findMany: {
          args: Prisma.CloseChecklistItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>[]
        }
        create: {
          args: Prisma.CloseChecklistItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        createMany: {
          args: Prisma.CloseChecklistItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CloseChecklistItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>[]
        }
        delete: {
          args: Prisma.CloseChecklistItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        update: {
          args: Prisma.CloseChecklistItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        deleteMany: {
          args: Prisma.CloseChecklistItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CloseChecklistItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CloseChecklistItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>[]
        }
        upsert: {
          args: Prisma.CloseChecklistItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CloseChecklistItemPayload>
        }
        aggregate: {
          args: Prisma.CloseChecklistItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCloseChecklistItem>
        }
        groupBy: {
          args: Prisma.CloseChecklistItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CloseChecklistItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CloseChecklistItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CloseChecklistItemCountAggregateOutputType> | number
        }
      }
    }
    PeriodMissingItem: {
      payload: Prisma.$PeriodMissingItemPayload<ExtArgs>
      fields: Prisma.PeriodMissingItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PeriodMissingItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PeriodMissingItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        findFirst: {
          args: Prisma.PeriodMissingItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PeriodMissingItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        findMany: {
          args: Prisma.PeriodMissingItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>[]
        }
        create: {
          args: Prisma.PeriodMissingItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        createMany: {
          args: Prisma.PeriodMissingItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PeriodMissingItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>[]
        }
        delete: {
          args: Prisma.PeriodMissingItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        update: {
          args: Prisma.PeriodMissingItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        deleteMany: {
          args: Prisma.PeriodMissingItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PeriodMissingItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PeriodMissingItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>[]
        }
        upsert: {
          args: Prisma.PeriodMissingItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodMissingItemPayload>
        }
        aggregate: {
          args: Prisma.PeriodMissingItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePeriodMissingItem>
        }
        groupBy: {
          args: Prisma.PeriodMissingItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodMissingItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.PeriodMissingItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodMissingItemCountAggregateOutputType> | number
        }
      }
    }
    PeriodAdjustment: {
      payload: Prisma.$PeriodAdjustmentPayload<ExtArgs>
      fields: Prisma.PeriodAdjustmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PeriodAdjustmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PeriodAdjustmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        findFirst: {
          args: Prisma.PeriodAdjustmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PeriodAdjustmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        findMany: {
          args: Prisma.PeriodAdjustmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>[]
        }
        create: {
          args: Prisma.PeriodAdjustmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        createMany: {
          args: Prisma.PeriodAdjustmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PeriodAdjustmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>[]
        }
        delete: {
          args: Prisma.PeriodAdjustmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        update: {
          args: Prisma.PeriodAdjustmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        deleteMany: {
          args: Prisma.PeriodAdjustmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PeriodAdjustmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PeriodAdjustmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>[]
        }
        upsert: {
          args: Prisma.PeriodAdjustmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAdjustmentPayload>
        }
        aggregate: {
          args: Prisma.PeriodAdjustmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePeriodAdjustment>
        }
        groupBy: {
          args: Prisma.PeriodAdjustmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodAdjustmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PeriodAdjustmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodAdjustmentCountAggregateOutputType> | number
        }
      }
    }
    PeriodAuditEntry: {
      payload: Prisma.$PeriodAuditEntryPayload<ExtArgs>
      fields: Prisma.PeriodAuditEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PeriodAuditEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PeriodAuditEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        findFirst: {
          args: Prisma.PeriodAuditEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PeriodAuditEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        findMany: {
          args: Prisma.PeriodAuditEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>[]
        }
        create: {
          args: Prisma.PeriodAuditEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        createMany: {
          args: Prisma.PeriodAuditEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PeriodAuditEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>[]
        }
        delete: {
          args: Prisma.PeriodAuditEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        update: {
          args: Prisma.PeriodAuditEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        deleteMany: {
          args: Prisma.PeriodAuditEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PeriodAuditEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PeriodAuditEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>[]
        }
        upsert: {
          args: Prisma.PeriodAuditEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PeriodAuditEntryPayload>
        }
        aggregate: {
          args: Prisma.PeriodAuditEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePeriodAuditEntry>
        }
        groupBy: {
          args: Prisma.PeriodAuditEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodAuditEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PeriodAuditEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PeriodAuditEntryCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    CustomerContact: {
      payload: Prisma.$CustomerContactPayload<ExtArgs>
      fields: Prisma.CustomerContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        findFirst: {
          args: Prisma.CustomerContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        findMany: {
          args: Prisma.CustomerContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
        }
        create: {
          args: Prisma.CustomerContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        createMany: {
          args: Prisma.CustomerContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
        }
        delete: {
          args: Prisma.CustomerContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        update: {
          args: Prisma.CustomerContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        deleteMany: {
          args: Prisma.CustomerContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>[]
        }
        upsert: {
          args: Prisma.CustomerContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerContactPayload>
        }
        aggregate: {
          args: Prisma.CustomerContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerContact>
        }
        groupBy: {
          args: Prisma.CustomerContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerContactCountAggregateOutputType> | number
        }
      }
    }
    CustomerPayment: {
      payload: Prisma.$CustomerPaymentPayload<ExtArgs>
      fields: Prisma.CustomerPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        findFirst: {
          args: Prisma.CustomerPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        findMany: {
          args: Prisma.CustomerPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>[]
        }
        create: {
          args: Prisma.CustomerPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        createMany: {
          args: Prisma.CustomerPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>[]
        }
        delete: {
          args: Prisma.CustomerPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        update: {
          args: Prisma.CustomerPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        deleteMany: {
          args: Prisma.CustomerPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>[]
        }
        upsert: {
          args: Prisma.CustomerPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPaymentPayload>
        }
        aggregate: {
          args: Prisma.CustomerPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerPayment>
        }
        groupBy: {
          args: Prisma.CustomerPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerPaymentCountAggregateOutputType> | number
        }
      }
    }
    CustomerCreditEvent: {
      payload: Prisma.$CustomerCreditEventPayload<ExtArgs>
      fields: Prisma.CustomerCreditEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerCreditEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerCreditEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        findFirst: {
          args: Prisma.CustomerCreditEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerCreditEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        findMany: {
          args: Prisma.CustomerCreditEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>[]
        }
        create: {
          args: Prisma.CustomerCreditEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        createMany: {
          args: Prisma.CustomerCreditEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreditEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>[]
        }
        delete: {
          args: Prisma.CustomerCreditEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        update: {
          args: Prisma.CustomerCreditEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        deleteMany: {
          args: Prisma.CustomerCreditEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerCreditEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerCreditEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>[]
        }
        upsert: {
          args: Prisma.CustomerCreditEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerCreditEventPayload>
        }
        aggregate: {
          args: Prisma.CustomerCreditEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerCreditEvent>
        }
        groupBy: {
          args: Prisma.CustomerCreditEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCreditEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCreditEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCreditEventCountAggregateOutputType> | number
        }
      }
    }
    CustomerRevenue: {
      payload: Prisma.$CustomerRevenuePayload<ExtArgs>
      fields: Prisma.CustomerRevenueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerRevenueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerRevenueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        findFirst: {
          args: Prisma.CustomerRevenueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerRevenueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        findMany: {
          args: Prisma.CustomerRevenueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>[]
        }
        create: {
          args: Prisma.CustomerRevenueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        createMany: {
          args: Prisma.CustomerRevenueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerRevenueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>[]
        }
        delete: {
          args: Prisma.CustomerRevenueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        update: {
          args: Prisma.CustomerRevenueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        deleteMany: {
          args: Prisma.CustomerRevenueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerRevenueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerRevenueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>[]
        }
        upsert: {
          args: Prisma.CustomerRevenueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRevenuePayload>
        }
        aggregate: {
          args: Prisma.CustomerRevenueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerRevenue>
        }
        groupBy: {
          args: Prisma.CustomerRevenueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerRevenueGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerRevenueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerRevenueCountAggregateOutputType> | number
        }
      }
    }
    CustomerRiskIndicator: {
      payload: Prisma.$CustomerRiskIndicatorPayload<ExtArgs>
      fields: Prisma.CustomerRiskIndicatorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerRiskIndicatorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerRiskIndicatorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        findFirst: {
          args: Prisma.CustomerRiskIndicatorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerRiskIndicatorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        findMany: {
          args: Prisma.CustomerRiskIndicatorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>[]
        }
        create: {
          args: Prisma.CustomerRiskIndicatorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        createMany: {
          args: Prisma.CustomerRiskIndicatorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerRiskIndicatorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>[]
        }
        delete: {
          args: Prisma.CustomerRiskIndicatorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        update: {
          args: Prisma.CustomerRiskIndicatorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        deleteMany: {
          args: Prisma.CustomerRiskIndicatorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerRiskIndicatorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerRiskIndicatorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>[]
        }
        upsert: {
          args: Prisma.CustomerRiskIndicatorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerRiskIndicatorPayload>
        }
        aggregate: {
          args: Prisma.CustomerRiskIndicatorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerRiskIndicator>
        }
        groupBy: {
          args: Prisma.CustomerRiskIndicatorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerRiskIndicatorGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerRiskIndicatorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerRiskIndicatorCountAggregateOutputType> | number
        }
      }
    }
    Supplier: {
      payload: Prisma.$SupplierPayload<ExtArgs>
      fields: Prisma.SupplierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findFirst: {
          args: Prisma.SupplierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findMany: {
          args: Prisma.SupplierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        create: {
          args: Prisma.SupplierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        createMany: {
          args: Prisma.SupplierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        delete: {
          args: Prisma.SupplierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        update: {
          args: Prisma.SupplierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        deleteMany: {
          args: Prisma.SupplierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        upsert: {
          args: Prisma.SupplierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        aggregate: {
          args: Prisma.SupplierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplier>
        }
        groupBy: {
          args: Prisma.SupplierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierCountAggregateOutputType> | number
        }
      }
    }
    SupplierContact: {
      payload: Prisma.$SupplierContactPayload<ExtArgs>
      fields: Prisma.SupplierContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        findFirst: {
          args: Prisma.SupplierContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        findMany: {
          args: Prisma.SupplierContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>[]
        }
        create: {
          args: Prisma.SupplierContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        createMany: {
          args: Prisma.SupplierContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>[]
        }
        delete: {
          args: Prisma.SupplierContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        update: {
          args: Prisma.SupplierContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        deleteMany: {
          args: Prisma.SupplierContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>[]
        }
        upsert: {
          args: Prisma.SupplierContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierContactPayload>
        }
        aggregate: {
          args: Prisma.SupplierContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierContact>
        }
        groupBy: {
          args: Prisma.SupplierContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierContactCountAggregateOutputType> | number
        }
      }
    }
    SupplierBalance: {
      payload: Prisma.$SupplierBalancePayload<ExtArgs>
      fields: Prisma.SupplierBalanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierBalanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierBalanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        findFirst: {
          args: Prisma.SupplierBalanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierBalanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        findMany: {
          args: Prisma.SupplierBalanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>[]
        }
        create: {
          args: Prisma.SupplierBalanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        createMany: {
          args: Prisma.SupplierBalanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierBalanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>[]
        }
        delete: {
          args: Prisma.SupplierBalanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        update: {
          args: Prisma.SupplierBalanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        deleteMany: {
          args: Prisma.SupplierBalanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierBalanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierBalanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>[]
        }
        upsert: {
          args: Prisma.SupplierBalanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierBalancePayload>
        }
        aggregate: {
          args: Prisma.SupplierBalanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierBalance>
        }
        groupBy: {
          args: Prisma.SupplierBalanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierBalanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierBalanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierBalanceCountAggregateOutputType> | number
        }
      }
    }
    SupplierPayment: {
      payload: Prisma.$SupplierPaymentPayload<ExtArgs>
      fields: Prisma.SupplierPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        findFirst: {
          args: Prisma.SupplierPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        findMany: {
          args: Prisma.SupplierPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>[]
        }
        create: {
          args: Prisma.SupplierPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        createMany: {
          args: Prisma.SupplierPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>[]
        }
        delete: {
          args: Prisma.SupplierPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        update: {
          args: Prisma.SupplierPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        deleteMany: {
          args: Prisma.SupplierPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>[]
        }
        upsert: {
          args: Prisma.SupplierPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPaymentPayload>
        }
        aggregate: {
          args: Prisma.SupplierPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierPayment>
        }
        groupBy: {
          args: Prisma.SupplierPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierPaymentCountAggregateOutputType> | number
        }
      }
    }
    SupplierReliability: {
      payload: Prisma.$SupplierReliabilityPayload<ExtArgs>
      fields: Prisma.SupplierReliabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierReliabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierReliabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        findFirst: {
          args: Prisma.SupplierReliabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierReliabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        findMany: {
          args: Prisma.SupplierReliabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>[]
        }
        create: {
          args: Prisma.SupplierReliabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        createMany: {
          args: Prisma.SupplierReliabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierReliabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>[]
        }
        delete: {
          args: Prisma.SupplierReliabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        update: {
          args: Prisma.SupplierReliabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        deleteMany: {
          args: Prisma.SupplierReliabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierReliabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierReliabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>[]
        }
        upsert: {
          args: Prisma.SupplierReliabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierReliabilityPayload>
        }
        aggregate: {
          args: Prisma.SupplierReliabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierReliability>
        }
        groupBy: {
          args: Prisma.SupplierReliabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierReliabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierReliabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierReliabilityCountAggregateOutputType> | number
        }
      }
    }
    SupplierSpend: {
      payload: Prisma.$SupplierSpendPayload<ExtArgs>
      fields: Prisma.SupplierSpendFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierSpendFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierSpendFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        findFirst: {
          args: Prisma.SupplierSpendFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierSpendFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        findMany: {
          args: Prisma.SupplierSpendFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>[]
        }
        create: {
          args: Prisma.SupplierSpendCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        createMany: {
          args: Prisma.SupplierSpendCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierSpendCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>[]
        }
        delete: {
          args: Prisma.SupplierSpendDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        update: {
          args: Prisma.SupplierSpendUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        deleteMany: {
          args: Prisma.SupplierSpendDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierSpendUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierSpendUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>[]
        }
        upsert: {
          args: Prisma.SupplierSpendUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierSpendPayload>
        }
        aggregate: {
          args: Prisma.SupplierSpendAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierSpend>
        }
        groupBy: {
          args: Prisma.SupplierSpendGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierSpendGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierSpendCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierSpendCountAggregateOutputType> | number
        }
      }
    }
    SupplierRisk: {
      payload: Prisma.$SupplierRiskPayload<ExtArgs>
      fields: Prisma.SupplierRiskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierRiskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierRiskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        findFirst: {
          args: Prisma.SupplierRiskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierRiskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        findMany: {
          args: Prisma.SupplierRiskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>[]
        }
        create: {
          args: Prisma.SupplierRiskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        createMany: {
          args: Prisma.SupplierRiskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierRiskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>[]
        }
        delete: {
          args: Prisma.SupplierRiskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        update: {
          args: Prisma.SupplierRiskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        deleteMany: {
          args: Prisma.SupplierRiskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierRiskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierRiskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>[]
        }
        upsert: {
          args: Prisma.SupplierRiskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierRiskPayload>
        }
        aggregate: {
          args: Prisma.SupplierRiskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplierRisk>
        }
        groupBy: {
          args: Prisma.SupplierRiskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierRiskGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierRiskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierRiskCountAggregateOutputType> | number
        }
      }
    }
    NettingAgreement: {
      payload: Prisma.$NettingAgreementPayload<ExtArgs>
      fields: Prisma.NettingAgreementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingAgreementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingAgreementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        findFirst: {
          args: Prisma.NettingAgreementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingAgreementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        findMany: {
          args: Prisma.NettingAgreementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>[]
        }
        create: {
          args: Prisma.NettingAgreementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        createMany: {
          args: Prisma.NettingAgreementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingAgreementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>[]
        }
        delete: {
          args: Prisma.NettingAgreementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        update: {
          args: Prisma.NettingAgreementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        deleteMany: {
          args: Prisma.NettingAgreementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingAgreementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingAgreementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>[]
        }
        upsert: {
          args: Prisma.NettingAgreementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingAgreementPayload>
        }
        aggregate: {
          args: Prisma.NettingAgreementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingAgreement>
        }
        groupBy: {
          args: Prisma.NettingAgreementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingAgreementGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingAgreementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingAgreementCountAggregateOutputType> | number
        }
      }
    }
    NettingParty: {
      payload: Prisma.$NettingPartyPayload<ExtArgs>
      fields: Prisma.NettingPartyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingPartyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingPartyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        findFirst: {
          args: Prisma.NettingPartyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingPartyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        findMany: {
          args: Prisma.NettingPartyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>[]
        }
        create: {
          args: Prisma.NettingPartyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        createMany: {
          args: Prisma.NettingPartyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingPartyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>[]
        }
        delete: {
          args: Prisma.NettingPartyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        update: {
          args: Prisma.NettingPartyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        deleteMany: {
          args: Prisma.NettingPartyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingPartyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingPartyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>[]
        }
        upsert: {
          args: Prisma.NettingPartyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPartyPayload>
        }
        aggregate: {
          args: Prisma.NettingPartyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingParty>
        }
        groupBy: {
          args: Prisma.NettingPartyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingPartyGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingPartyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingPartyCountAggregateOutputType> | number
        }
      }
    }
    NettingSession: {
      payload: Prisma.$NettingSessionPayload<ExtArgs>
      fields: Prisma.NettingSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        findFirst: {
          args: Prisma.NettingSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        findMany: {
          args: Prisma.NettingSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>[]
        }
        create: {
          args: Prisma.NettingSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        createMany: {
          args: Prisma.NettingSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>[]
        }
        delete: {
          args: Prisma.NettingSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        update: {
          args: Prisma.NettingSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        deleteMany: {
          args: Prisma.NettingSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>[]
        }
        upsert: {
          args: Prisma.NettingSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingSessionPayload>
        }
        aggregate: {
          args: Prisma.NettingSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingSession>
        }
        groupBy: {
          args: Prisma.NettingSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingSessionCountAggregateOutputType> | number
        }
      }
    }
    NettingPosition: {
      payload: Prisma.$NettingPositionPayload<ExtArgs>
      fields: Prisma.NettingPositionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingPositionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingPositionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        findFirst: {
          args: Prisma.NettingPositionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingPositionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        findMany: {
          args: Prisma.NettingPositionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>[]
        }
        create: {
          args: Prisma.NettingPositionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        createMany: {
          args: Prisma.NettingPositionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingPositionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>[]
        }
        delete: {
          args: Prisma.NettingPositionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        update: {
          args: Prisma.NettingPositionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        deleteMany: {
          args: Prisma.NettingPositionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingPositionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingPositionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>[]
        }
        upsert: {
          args: Prisma.NettingPositionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingPositionPayload>
        }
        aggregate: {
          args: Prisma.NettingPositionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingPosition>
        }
        groupBy: {
          args: Prisma.NettingPositionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingPositionGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingPositionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingPositionCountAggregateOutputType> | number
        }
      }
    }
    NettingTransaction: {
      payload: Prisma.$NettingTransactionPayload<ExtArgs>
      fields: Prisma.NettingTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NettingTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NettingTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        findFirst: {
          args: Prisma.NettingTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NettingTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        findMany: {
          args: Prisma.NettingTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>[]
        }
        create: {
          args: Prisma.NettingTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        createMany: {
          args: Prisma.NettingTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NettingTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>[]
        }
        delete: {
          args: Prisma.NettingTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        update: {
          args: Prisma.NettingTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        deleteMany: {
          args: Prisma.NettingTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NettingTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NettingTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>[]
        }
        upsert: {
          args: Prisma.NettingTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NettingTransactionPayload>
        }
        aggregate: {
          args: Prisma.NettingTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNettingTransaction>
        }
        groupBy: {
          args: Prisma.NettingTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.NettingTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NettingTransactionCountAggregateOutputType> | number
        }
      }
    }
    SettlementInstruction: {
      payload: Prisma.$SettlementInstructionPayload<ExtArgs>
      fields: Prisma.SettlementInstructionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SettlementInstructionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SettlementInstructionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        findFirst: {
          args: Prisma.SettlementInstructionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SettlementInstructionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        findMany: {
          args: Prisma.SettlementInstructionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>[]
        }
        create: {
          args: Prisma.SettlementInstructionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        createMany: {
          args: Prisma.SettlementInstructionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SettlementInstructionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>[]
        }
        delete: {
          args: Prisma.SettlementInstructionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        update: {
          args: Prisma.SettlementInstructionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        deleteMany: {
          args: Prisma.SettlementInstructionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SettlementInstructionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SettlementInstructionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>[]
        }
        upsert: {
          args: Prisma.SettlementInstructionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettlementInstructionPayload>
        }
        aggregate: {
          args: Prisma.SettlementInstructionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSettlementInstruction>
        }
        groupBy: {
          args: Prisma.SettlementInstructionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettlementInstructionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SettlementInstructionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettlementInstructionCountAggregateOutputType> | number
        }
      }
    }
    OffsetEntry: {
      payload: Prisma.$OffsetEntryPayload<ExtArgs>
      fields: Prisma.OffsetEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OffsetEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OffsetEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        findFirst: {
          args: Prisma.OffsetEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OffsetEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        findMany: {
          args: Prisma.OffsetEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>[]
        }
        create: {
          args: Prisma.OffsetEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        createMany: {
          args: Prisma.OffsetEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OffsetEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>[]
        }
        delete: {
          args: Prisma.OffsetEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        update: {
          args: Prisma.OffsetEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        deleteMany: {
          args: Prisma.OffsetEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OffsetEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OffsetEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>[]
        }
        upsert: {
          args: Prisma.OffsetEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffsetEntryPayload>
        }
        aggregate: {
          args: Prisma.OffsetEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffsetEntry>
        }
        groupBy: {
          args: Prisma.OffsetEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffsetEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.OffsetEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffsetEntryCountAggregateOutputType> | number
        }
      }
    }
    Offer: {
      payload: Prisma.$OfferPayload<ExtArgs>
      fields: Prisma.OfferFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OfferFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        findFirst: {
          args: Prisma.OfferFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        findMany: {
          args: Prisma.OfferFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>[]
        }
        create: {
          args: Prisma.OfferCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        createMany: {
          args: Prisma.OfferCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>[]
        }
        delete: {
          args: Prisma.OfferDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        update: {
          args: Prisma.OfferUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        deleteMany: {
          args: Prisma.OfferDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OfferUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OfferUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>[]
        }
        upsert: {
          args: Prisma.OfferUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferPayload>
        }
        aggregate: {
          args: Prisma.OfferAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffer>
        }
        groupBy: {
          args: Prisma.OfferGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferGroupByOutputType>[]
        }
        count: {
          args: Prisma.OfferCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferCountAggregateOutputType> | number
        }
      }
    }
    OfferVersion: {
      payload: Prisma.$OfferVersionPayload<ExtArgs>
      fields: Prisma.OfferVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OfferVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OfferVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        findFirst: {
          args: Prisma.OfferVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OfferVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        findMany: {
          args: Prisma.OfferVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>[]
        }
        create: {
          args: Prisma.OfferVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        createMany: {
          args: Prisma.OfferVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OfferVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>[]
        }
        delete: {
          args: Prisma.OfferVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        update: {
          args: Prisma.OfferVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        deleteMany: {
          args: Prisma.OfferVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OfferVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OfferVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>[]
        }
        upsert: {
          args: Prisma.OfferVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferVersionPayload>
        }
        aggregate: {
          args: Prisma.OfferVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOfferVersion>
        }
        groupBy: {
          args: Prisma.OfferVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.OfferVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferVersionCountAggregateOutputType> | number
        }
      }
    }
    OfferAuditLog: {
      payload: Prisma.$OfferAuditLogPayload<ExtArgs>
      fields: Prisma.OfferAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OfferAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OfferAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        findFirst: {
          args: Prisma.OfferAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OfferAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        findMany: {
          args: Prisma.OfferAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>[]
        }
        create: {
          args: Prisma.OfferAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        createMany: {
          args: Prisma.OfferAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OfferAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>[]
        }
        delete: {
          args: Prisma.OfferAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        update: {
          args: Prisma.OfferAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.OfferAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OfferAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OfferAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.OfferAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferAuditLogPayload>
        }
        aggregate: {
          args: Prisma.OfferAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOfferAuditLog>
        }
        groupBy: {
          args: Prisma.OfferAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.OfferAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferAuditLogCountAggregateOutputType> | number
        }
      }
    }
    OfferTemplate: {
      payload: Prisma.$OfferTemplatePayload<ExtArgs>
      fields: Prisma.OfferTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OfferTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OfferTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        findFirst: {
          args: Prisma.OfferTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OfferTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        findMany: {
          args: Prisma.OfferTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>[]
        }
        create: {
          args: Prisma.OfferTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        createMany: {
          args: Prisma.OfferTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OfferTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>[]
        }
        delete: {
          args: Prisma.OfferTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        update: {
          args: Prisma.OfferTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        deleteMany: {
          args: Prisma.OfferTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OfferTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OfferTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>[]
        }
        upsert: {
          args: Prisma.OfferTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferTemplatePayload>
        }
        aggregate: {
          args: Prisma.OfferTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOfferTemplate>
        }
        groupBy: {
          args: Prisma.OfferTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.OfferTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferTemplateCountAggregateOutputType> | number
        }
      }
    }
    Task: {
      payload: Prisma.$TaskPayload<ExtArgs>
      fields: Prisma.TaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findFirst: {
          args: Prisma.TaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findMany: {
          args: Prisma.TaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        create: {
          args: Prisma.TaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        createMany: {
          args: Prisma.TaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        delete: {
          args: Prisma.TaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        update: {
          args: Prisma.TaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        deleteMany: {
          args: Prisma.TaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        upsert: {
          args: Prisma.TaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        aggregate: {
          args: Prisma.TaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTask>
        }
        groupBy: {
          args: Prisma.TaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCountAggregateOutputType> | number
        }
      }
    }
    TaskAssignee: {
      payload: Prisma.$TaskAssigneePayload<ExtArgs>
      fields: Prisma.TaskAssigneeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        findFirst: {
          args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        findMany: {
          args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
        }
        create: {
          args: Prisma.TaskAssigneeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        createMany: {
          args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskAssigneeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
        }
        delete: {
          args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        update: {
          args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        deleteMany: {
          args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
        }
        upsert: {
          args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
        }
        aggregate: {
          args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskAssignee>
        }
        groupBy: {
          args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskAssigneeGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskAssigneeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskAssigneeCountAggregateOutputType> | number
        }
      }
    }
    TaskWatcher: {
      payload: Prisma.$TaskWatcherPayload<ExtArgs>
      fields: Prisma.TaskWatcherFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskWatcherFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskWatcherFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        findFirst: {
          args: Prisma.TaskWatcherFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskWatcherFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        findMany: {
          args: Prisma.TaskWatcherFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>[]
        }
        create: {
          args: Prisma.TaskWatcherCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        createMany: {
          args: Prisma.TaskWatcherCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskWatcherCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>[]
        }
        delete: {
          args: Prisma.TaskWatcherDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        update: {
          args: Prisma.TaskWatcherUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        deleteMany: {
          args: Prisma.TaskWatcherDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskWatcherUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskWatcherUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>[]
        }
        upsert: {
          args: Prisma.TaskWatcherUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskWatcherPayload>
        }
        aggregate: {
          args: Prisma.TaskWatcherAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskWatcher>
        }
        groupBy: {
          args: Prisma.TaskWatcherGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskWatcherGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskWatcherCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskWatcherCountAggregateOutputType> | number
        }
      }
    }
    TaskTag: {
      payload: Prisma.$TaskTagPayload<ExtArgs>
      fields: Prisma.TaskTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        findFirst: {
          args: Prisma.TaskTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        findMany: {
          args: Prisma.TaskTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
        }
        create: {
          args: Prisma.TaskTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        createMany: {
          args: Prisma.TaskTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
        }
        delete: {
          args: Prisma.TaskTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        update: {
          args: Prisma.TaskTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        deleteMany: {
          args: Prisma.TaskTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>[]
        }
        upsert: {
          args: Prisma.TaskTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagPayload>
        }
        aggregate: {
          args: Prisma.TaskTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskTag>
        }
        groupBy: {
          args: Prisma.TaskTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskTagCountAggregateOutputType> | number
        }
      }
    }
    TaskTagLink: {
      payload: Prisma.$TaskTagLinkPayload<ExtArgs>
      fields: Prisma.TaskTagLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskTagLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskTagLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        findFirst: {
          args: Prisma.TaskTagLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskTagLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        findMany: {
          args: Prisma.TaskTagLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>[]
        }
        create: {
          args: Prisma.TaskTagLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        createMany: {
          args: Prisma.TaskTagLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskTagLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>[]
        }
        delete: {
          args: Prisma.TaskTagLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        update: {
          args: Prisma.TaskTagLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        deleteMany: {
          args: Prisma.TaskTagLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskTagLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskTagLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>[]
        }
        upsert: {
          args: Prisma.TaskTagLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskTagLinkPayload>
        }
        aggregate: {
          args: Prisma.TaskTagLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskTagLink>
        }
        groupBy: {
          args: Prisma.TaskTagLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskTagLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskTagLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskTagLinkCountAggregateOutputType> | number
        }
      }
    }
    TaskDependency: {
      payload: Prisma.$TaskDependencyPayload<ExtArgs>
      fields: Prisma.TaskDependencyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskDependencyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskDependencyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        findFirst: {
          args: Prisma.TaskDependencyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskDependencyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        findMany: {
          args: Prisma.TaskDependencyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
        }
        create: {
          args: Prisma.TaskDependencyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        createMany: {
          args: Prisma.TaskDependencyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskDependencyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
        }
        delete: {
          args: Prisma.TaskDependencyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        update: {
          args: Prisma.TaskDependencyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        deleteMany: {
          args: Prisma.TaskDependencyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskDependencyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskDependencyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
        }
        upsert: {
          args: Prisma.TaskDependencyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
        }
        aggregate: {
          args: Prisma.TaskDependencyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskDependency>
        }
        groupBy: {
          args: Prisma.TaskDependencyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskDependencyGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskDependencyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskDependencyCountAggregateOutputType> | number
        }
      }
    }
    TaskComment: {
      payload: Prisma.$TaskCommentPayload<ExtArgs>
      fields: Prisma.TaskCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        findFirst: {
          args: Prisma.TaskCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        findMany: {
          args: Prisma.TaskCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
        }
        create: {
          args: Prisma.TaskCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        createMany: {
          args: Prisma.TaskCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskCommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
        }
        delete: {
          args: Prisma.TaskCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        update: {
          args: Prisma.TaskCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        deleteMany: {
          args: Prisma.TaskCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskCommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
        }
        upsert: {
          args: Prisma.TaskCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskCommentPayload>
        }
        aggregate: {
          args: Prisma.TaskCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskComment>
        }
        groupBy: {
          args: Prisma.TaskCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCommentCountAggregateOutputType> | number
        }
      }
    }
    TaskActivity: {
      payload: Prisma.$TaskActivityPayload<ExtArgs>
      fields: Prisma.TaskActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        findFirst: {
          args: Prisma.TaskActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        findMany: {
          args: Prisma.TaskActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
        }
        create: {
          args: Prisma.TaskActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        createMany: {
          args: Prisma.TaskActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
        }
        delete: {
          args: Prisma.TaskActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        update: {
          args: Prisma.TaskActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        deleteMany: {
          args: Prisma.TaskActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>[]
        }
        upsert: {
          args: Prisma.TaskActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskActivityPayload>
        }
        aggregate: {
          args: Prisma.TaskActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskActivity>
        }
        groupBy: {
          args: Prisma.TaskActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskActivityCountAggregateOutputType> | number
        }
      }
    }
    TaskAttachment: {
      payload: Prisma.$TaskAttachmentPayload<ExtArgs>
      fields: Prisma.TaskAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        findFirst: {
          args: Prisma.TaskAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        findMany: {
          args: Prisma.TaskAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
        }
        create: {
          args: Prisma.TaskAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        createMany: {
          args: Prisma.TaskAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskAttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
        }
        delete: {
          args: Prisma.TaskAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        update: {
          args: Prisma.TaskAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.TaskAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskAttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
        }
        upsert: {
          args: Prisma.TaskAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
        }
        aggregate: {
          args: Prisma.TaskAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskAttachment>
        }
        groupBy: {
          args: Prisma.TaskAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskAttachmentCountAggregateOutputType> | number
        }
      }
    }
    Risk: {
      payload: Prisma.$RiskPayload<ExtArgs>
      fields: Prisma.RiskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RiskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RiskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        findFirst: {
          args: Prisma.RiskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RiskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        findMany: {
          args: Prisma.RiskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>[]
        }
        create: {
          args: Prisma.RiskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        createMany: {
          args: Prisma.RiskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RiskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>[]
        }
        delete: {
          args: Prisma.RiskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        update: {
          args: Prisma.RiskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        deleteMany: {
          args: Prisma.RiskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RiskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RiskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>[]
        }
        upsert: {
          args: Prisma.RiskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskPayload>
        }
        aggregate: {
          args: Prisma.RiskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRisk>
        }
        groupBy: {
          args: Prisma.RiskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskGroupByOutputType>[]
        }
        count: {
          args: Prisma.RiskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskCountAggregateOutputType> | number
        }
      }
    }
    RiskMitigationStep: {
      payload: Prisma.$RiskMitigationStepPayload<ExtArgs>
      fields: Prisma.RiskMitigationStepFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RiskMitigationStepFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RiskMitigationStepFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        findFirst: {
          args: Prisma.RiskMitigationStepFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RiskMitigationStepFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        findMany: {
          args: Prisma.RiskMitigationStepFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>[]
        }
        create: {
          args: Prisma.RiskMitigationStepCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        createMany: {
          args: Prisma.RiskMitigationStepCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RiskMitigationStepCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>[]
        }
        delete: {
          args: Prisma.RiskMitigationStepDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        update: {
          args: Prisma.RiskMitigationStepUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        deleteMany: {
          args: Prisma.RiskMitigationStepDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RiskMitigationStepUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RiskMitigationStepUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>[]
        }
        upsert: {
          args: Prisma.RiskMitigationStepUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskMitigationStepPayload>
        }
        aggregate: {
          args: Prisma.RiskMitigationStepAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRiskMitigationStep>
        }
        groupBy: {
          args: Prisma.RiskMitigationStepGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskMitigationStepGroupByOutputType>[]
        }
        count: {
          args: Prisma.RiskMitigationStepCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskMitigationStepCountAggregateOutputType> | number
        }
      }
    }
    TaskRiskLink: {
      payload: Prisma.$TaskRiskLinkPayload<ExtArgs>
      fields: Prisma.TaskRiskLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskRiskLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskRiskLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        findFirst: {
          args: Prisma.TaskRiskLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskRiskLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        findMany: {
          args: Prisma.TaskRiskLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>[]
        }
        create: {
          args: Prisma.TaskRiskLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        createMany: {
          args: Prisma.TaskRiskLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskRiskLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>[]
        }
        delete: {
          args: Prisma.TaskRiskLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        update: {
          args: Prisma.TaskRiskLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        deleteMany: {
          args: Prisma.TaskRiskLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskRiskLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskRiskLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>[]
        }
        upsert: {
          args: Prisma.TaskRiskLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskRiskLinkPayload>
        }
        aggregate: {
          args: Prisma.TaskRiskLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskRiskLink>
        }
        groupBy: {
          args: Prisma.TaskRiskLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskRiskLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskRiskLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskRiskLinkCountAggregateOutputType> | number
        }
      }
    }
    RiskComment: {
      payload: Prisma.$RiskCommentPayload<ExtArgs>
      fields: Prisma.RiskCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RiskCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RiskCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        findFirst: {
          args: Prisma.RiskCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RiskCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        findMany: {
          args: Prisma.RiskCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>[]
        }
        create: {
          args: Prisma.RiskCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        createMany: {
          args: Prisma.RiskCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RiskCommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>[]
        }
        delete: {
          args: Prisma.RiskCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        update: {
          args: Prisma.RiskCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        deleteMany: {
          args: Prisma.RiskCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RiskCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RiskCommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>[]
        }
        upsert: {
          args: Prisma.RiskCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskCommentPayload>
        }
        aggregate: {
          args: Prisma.RiskCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRiskComment>
        }
        groupBy: {
          args: Prisma.RiskCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.RiskCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskCommentCountAggregateOutputType> | number
        }
      }
    }
    RiskActivity: {
      payload: Prisma.$RiskActivityPayload<ExtArgs>
      fields: Prisma.RiskActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RiskActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RiskActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        findFirst: {
          args: Prisma.RiskActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RiskActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        findMany: {
          args: Prisma.RiskActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
        }
        create: {
          args: Prisma.RiskActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        createMany: {
          args: Prisma.RiskActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RiskActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
        }
        delete: {
          args: Prisma.RiskActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        update: {
          args: Prisma.RiskActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        deleteMany: {
          args: Prisma.RiskActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RiskActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RiskActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>[]
        }
        upsert: {
          args: Prisma.RiskActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RiskActivityPayload>
        }
        aggregate: {
          args: Prisma.RiskActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRiskActivity>
        }
        groupBy: {
          args: Prisma.RiskActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.RiskActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RiskActivityCountAggregateOutputType> | number
        }
      }
    }
    TaskNotification: {
      payload: Prisma.$TaskNotificationPayload<ExtArgs>
      fields: Prisma.TaskNotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskNotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskNotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        findFirst: {
          args: Prisma.TaskNotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskNotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        findMany: {
          args: Prisma.TaskNotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
        }
        create: {
          args: Prisma.TaskNotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        createMany: {
          args: Prisma.TaskNotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskNotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
        }
        delete: {
          args: Prisma.TaskNotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        update: {
          args: Prisma.TaskNotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        deleteMany: {
          args: Prisma.TaskNotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskNotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskNotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>[]
        }
        upsert: {
          args: Prisma.TaskNotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskNotificationPayload>
        }
        aggregate: {
          args: Prisma.TaskNotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTaskNotification>
        }
        groupBy: {
          args: Prisma.TaskNotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskNotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskNotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskNotificationCountAggregateOutputType> | number
        }
      }
    }
    SavedTaskFilter: {
      payload: Prisma.$SavedTaskFilterPayload<ExtArgs>
      fields: Prisma.SavedTaskFilterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SavedTaskFilterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SavedTaskFilterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        findFirst: {
          args: Prisma.SavedTaskFilterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SavedTaskFilterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        findMany: {
          args: Prisma.SavedTaskFilterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>[]
        }
        create: {
          args: Prisma.SavedTaskFilterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        createMany: {
          args: Prisma.SavedTaskFilterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SavedTaskFilterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>[]
        }
        delete: {
          args: Prisma.SavedTaskFilterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        update: {
          args: Prisma.SavedTaskFilterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        deleteMany: {
          args: Prisma.SavedTaskFilterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SavedTaskFilterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SavedTaskFilterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>[]
        }
        upsert: {
          args: Prisma.SavedTaskFilterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SavedTaskFilterPayload>
        }
        aggregate: {
          args: Prisma.SavedTaskFilterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSavedTaskFilter>
        }
        groupBy: {
          args: Prisma.SavedTaskFilterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedTaskFilterGroupByOutputType>[]
        }
        count: {
          args: Prisma.SavedTaskFilterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SavedTaskFilterCountAggregateOutputType> | number
        }
      }
    }
    RevenueForecast: {
      payload: Prisma.$RevenueForecastPayload<ExtArgs>
      fields: Prisma.RevenueForecastFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RevenueForecastFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RevenueForecastFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        findFirst: {
          args: Prisma.RevenueForecastFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RevenueForecastFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        findMany: {
          args: Prisma.RevenueForecastFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>[]
        }
        create: {
          args: Prisma.RevenueForecastCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        createMany: {
          args: Prisma.RevenueForecastCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RevenueForecastCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>[]
        }
        delete: {
          args: Prisma.RevenueForecastDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        update: {
          args: Prisma.RevenueForecastUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        deleteMany: {
          args: Prisma.RevenueForecastDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RevenueForecastUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RevenueForecastUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>[]
        }
        upsert: {
          args: Prisma.RevenueForecastUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueForecastPayload>
        }
        aggregate: {
          args: Prisma.RevenueForecastAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRevenueForecast>
        }
        groupBy: {
          args: Prisma.RevenueForecastGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueForecastGroupByOutputType>[]
        }
        count: {
          args: Prisma.RevenueForecastCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueForecastCountAggregateOutputType> | number
        }
      }
    }
    RevenueLineItem: {
      payload: Prisma.$RevenueLineItemPayload<ExtArgs>
      fields: Prisma.RevenueLineItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RevenueLineItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RevenueLineItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        findFirst: {
          args: Prisma.RevenueLineItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RevenueLineItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        findMany: {
          args: Prisma.RevenueLineItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>[]
        }
        create: {
          args: Prisma.RevenueLineItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        createMany: {
          args: Prisma.RevenueLineItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RevenueLineItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>[]
        }
        delete: {
          args: Prisma.RevenueLineItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        update: {
          args: Prisma.RevenueLineItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        deleteMany: {
          args: Prisma.RevenueLineItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RevenueLineItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RevenueLineItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>[]
        }
        upsert: {
          args: Prisma.RevenueLineItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueLineItemPayload>
        }
        aggregate: {
          args: Prisma.RevenueLineItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRevenueLineItem>
        }
        groupBy: {
          args: Prisma.RevenueLineItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueLineItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.RevenueLineItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueLineItemCountAggregateOutputType> | number
        }
      }
    }
    CostForecast: {
      payload: Prisma.$CostForecastPayload<ExtArgs>
      fields: Prisma.CostForecastFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostForecastFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostForecastFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        findFirst: {
          args: Prisma.CostForecastFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostForecastFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        findMany: {
          args: Prisma.CostForecastFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>[]
        }
        create: {
          args: Prisma.CostForecastCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        createMany: {
          args: Prisma.CostForecastCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostForecastCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>[]
        }
        delete: {
          args: Prisma.CostForecastDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        update: {
          args: Prisma.CostForecastUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        deleteMany: {
          args: Prisma.CostForecastDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostForecastUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostForecastUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>[]
        }
        upsert: {
          args: Prisma.CostForecastUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostForecastPayload>
        }
        aggregate: {
          args: Prisma.CostForecastAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostForecast>
        }
        groupBy: {
          args: Prisma.CostForecastGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostForecastGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostForecastCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostForecastCountAggregateOutputType> | number
        }
      }
    }
    CostLineItem: {
      payload: Prisma.$CostLineItemPayload<ExtArgs>
      fields: Prisma.CostLineItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostLineItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostLineItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        findFirst: {
          args: Prisma.CostLineItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostLineItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        findMany: {
          args: Prisma.CostLineItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>[]
        }
        create: {
          args: Prisma.CostLineItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        createMany: {
          args: Prisma.CostLineItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostLineItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>[]
        }
        delete: {
          args: Prisma.CostLineItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        update: {
          args: Prisma.CostLineItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        deleteMany: {
          args: Prisma.CostLineItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostLineItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostLineItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>[]
        }
        upsert: {
          args: Prisma.CostLineItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostLineItemPayload>
        }
        aggregate: {
          args: Prisma.CostLineItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostLineItem>
        }
        groupBy: {
          args: Prisma.CostLineItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostLineItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostLineItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostLineItemCountAggregateOutputType> | number
        }
      }
    }
    CashForecast: {
      payload: Prisma.$CashForecastPayload<ExtArgs>
      fields: Prisma.CashForecastFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CashForecastFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CashForecastFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        findFirst: {
          args: Prisma.CashForecastFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CashForecastFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        findMany: {
          args: Prisma.CashForecastFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>[]
        }
        create: {
          args: Prisma.CashForecastCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        createMany: {
          args: Prisma.CashForecastCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CashForecastCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>[]
        }
        delete: {
          args: Prisma.CashForecastDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        update: {
          args: Prisma.CashForecastUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        deleteMany: {
          args: Prisma.CashForecastDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CashForecastUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CashForecastUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>[]
        }
        upsert: {
          args: Prisma.CashForecastUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPayload>
        }
        aggregate: {
          args: Prisma.CashForecastAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCashForecast>
        }
        groupBy: {
          args: Prisma.CashForecastGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashForecastGroupByOutputType>[]
        }
        count: {
          args: Prisma.CashForecastCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashForecastCountAggregateOutputType> | number
        }
      }
    }
    CashForecastPeriod: {
      payload: Prisma.$CashForecastPeriodPayload<ExtArgs>
      fields: Prisma.CashForecastPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CashForecastPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CashForecastPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        findFirst: {
          args: Prisma.CashForecastPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CashForecastPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        findMany: {
          args: Prisma.CashForecastPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>[]
        }
        create: {
          args: Prisma.CashForecastPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        createMany: {
          args: Prisma.CashForecastPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CashForecastPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>[]
        }
        delete: {
          args: Prisma.CashForecastPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        update: {
          args: Prisma.CashForecastPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        deleteMany: {
          args: Prisma.CashForecastPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CashForecastPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CashForecastPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>[]
        }
        upsert: {
          args: Prisma.CashForecastPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashForecastPeriodPayload>
        }
        aggregate: {
          args: Prisma.CashForecastPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCashForecastPeriod>
        }
        groupBy: {
          args: Prisma.CashForecastPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashForecastPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.CashForecastPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashForecastPeriodCountAggregateOutputType> | number
        }
      }
    }
    ForecastScenario: {
      payload: Prisma.$ForecastScenarioPayload<ExtArgs>
      fields: Prisma.ForecastScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForecastScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForecastScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        findFirst: {
          args: Prisma.ForecastScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForecastScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        findMany: {
          args: Prisma.ForecastScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>[]
        }
        create: {
          args: Prisma.ForecastScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        createMany: {
          args: Prisma.ForecastScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForecastScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>[]
        }
        delete: {
          args: Prisma.ForecastScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        update: {
          args: Prisma.ForecastScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        deleteMany: {
          args: Prisma.ForecastScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForecastScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForecastScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>[]
        }
        upsert: {
          args: Prisma.ForecastScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastScenarioPayload>
        }
        aggregate: {
          args: Prisma.ForecastScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForecastScenario>
        }
        groupBy: {
          args: Prisma.ForecastScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForecastScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastScenarioCountAggregateOutputType> | number
        }
      }
    }
    ForecastAssumption: {
      payload: Prisma.$ForecastAssumptionPayload<ExtArgs>
      fields: Prisma.ForecastAssumptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForecastAssumptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForecastAssumptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        findFirst: {
          args: Prisma.ForecastAssumptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForecastAssumptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        findMany: {
          args: Prisma.ForecastAssumptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>[]
        }
        create: {
          args: Prisma.ForecastAssumptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        createMany: {
          args: Prisma.ForecastAssumptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForecastAssumptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>[]
        }
        delete: {
          args: Prisma.ForecastAssumptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        update: {
          args: Prisma.ForecastAssumptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        deleteMany: {
          args: Prisma.ForecastAssumptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForecastAssumptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForecastAssumptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>[]
        }
        upsert: {
          args: Prisma.ForecastAssumptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAssumptionPayload>
        }
        aggregate: {
          args: Prisma.ForecastAssumptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForecastAssumption>
        }
        groupBy: {
          args: Prisma.ForecastAssumptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAssumptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForecastAssumptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAssumptionCountAggregateOutputType> | number
        }
      }
    }
    ForecastAlert: {
      payload: Prisma.$ForecastAlertPayload<ExtArgs>
      fields: Prisma.ForecastAlertFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForecastAlertFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForecastAlertFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        findFirst: {
          args: Prisma.ForecastAlertFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForecastAlertFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        findMany: {
          args: Prisma.ForecastAlertFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>[]
        }
        create: {
          args: Prisma.ForecastAlertCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        createMany: {
          args: Prisma.ForecastAlertCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForecastAlertCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>[]
        }
        delete: {
          args: Prisma.ForecastAlertDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        update: {
          args: Prisma.ForecastAlertUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        deleteMany: {
          args: Prisma.ForecastAlertDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForecastAlertUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForecastAlertUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>[]
        }
        upsert: {
          args: Prisma.ForecastAlertUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAlertPayload>
        }
        aggregate: {
          args: Prisma.ForecastAlertAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForecastAlert>
        }
        groupBy: {
          args: Prisma.ForecastAlertGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAlertGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForecastAlertCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAlertCountAggregateOutputType> | number
        }
      }
    }
    ForecastAnnotation: {
      payload: Prisma.$ForecastAnnotationPayload<ExtArgs>
      fields: Prisma.ForecastAnnotationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForecastAnnotationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForecastAnnotationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        findFirst: {
          args: Prisma.ForecastAnnotationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForecastAnnotationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        findMany: {
          args: Prisma.ForecastAnnotationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>[]
        }
        create: {
          args: Prisma.ForecastAnnotationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        createMany: {
          args: Prisma.ForecastAnnotationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForecastAnnotationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>[]
        }
        delete: {
          args: Prisma.ForecastAnnotationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        update: {
          args: Prisma.ForecastAnnotationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        deleteMany: {
          args: Prisma.ForecastAnnotationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForecastAnnotationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForecastAnnotationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>[]
        }
        upsert: {
          args: Prisma.ForecastAnnotationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastAnnotationPayload>
        }
        aggregate: {
          args: Prisma.ForecastAnnotationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForecastAnnotation>
        }
        groupBy: {
          args: Prisma.ForecastAnnotationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAnnotationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForecastAnnotationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastAnnotationCountAggregateOutputType> | number
        }
      }
    }
    ForecastVariance: {
      payload: Prisma.$ForecastVariancePayload<ExtArgs>
      fields: Prisma.ForecastVarianceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ForecastVarianceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ForecastVarianceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        findFirst: {
          args: Prisma.ForecastVarianceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ForecastVarianceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        findMany: {
          args: Prisma.ForecastVarianceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>[]
        }
        create: {
          args: Prisma.ForecastVarianceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        createMany: {
          args: Prisma.ForecastVarianceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ForecastVarianceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>[]
        }
        delete: {
          args: Prisma.ForecastVarianceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        update: {
          args: Prisma.ForecastVarianceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        deleteMany: {
          args: Prisma.ForecastVarianceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ForecastVarianceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ForecastVarianceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>[]
        }
        upsert: {
          args: Prisma.ForecastVarianceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ForecastVariancePayload>
        }
        aggregate: {
          args: Prisma.ForecastVarianceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForecastVariance>
        }
        groupBy: {
          args: Prisma.ForecastVarianceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastVarianceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ForecastVarianceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ForecastVarianceCountAggregateOutputType> | number
        }
      }
    }
    Scenario: {
      payload: Prisma.$ScenarioPayload<ExtArgs>
      fields: Prisma.ScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        findFirst: {
          args: Prisma.ScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        findMany: {
          args: Prisma.ScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
        }
        create: {
          args: Prisma.ScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        createMany: {
          args: Prisma.ScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
        }
        delete: {
          args: Prisma.ScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        update: {
          args: Prisma.ScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        deleteMany: {
          args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
        }
        upsert: {
          args: Prisma.ScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioPayload>
        }
        aggregate: {
          args: Prisma.ScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScenario>
        }
        groupBy: {
          args: Prisma.ScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioCountAggregateOutputType> | number
        }
      }
    }
    ScenarioAssumption: {
      payload: Prisma.$ScenarioAssumptionPayload<ExtArgs>
      fields: Prisma.ScenarioAssumptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScenarioAssumptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScenarioAssumptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        findFirst: {
          args: Prisma.ScenarioAssumptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScenarioAssumptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        findMany: {
          args: Prisma.ScenarioAssumptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>[]
        }
        create: {
          args: Prisma.ScenarioAssumptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        createMany: {
          args: Prisma.ScenarioAssumptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScenarioAssumptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>[]
        }
        delete: {
          args: Prisma.ScenarioAssumptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        update: {
          args: Prisma.ScenarioAssumptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        deleteMany: {
          args: Prisma.ScenarioAssumptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScenarioAssumptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScenarioAssumptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>[]
        }
        upsert: {
          args: Prisma.ScenarioAssumptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioAssumptionPayload>
        }
        aggregate: {
          args: Prisma.ScenarioAssumptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScenarioAssumption>
        }
        groupBy: {
          args: Prisma.ScenarioAssumptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioAssumptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScenarioAssumptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioAssumptionCountAggregateOutputType> | number
        }
      }
    }
    StressTest: {
      payload: Prisma.$StressTestPayload<ExtArgs>
      fields: Prisma.StressTestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StressTestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StressTestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        findFirst: {
          args: Prisma.StressTestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StressTestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        findMany: {
          args: Prisma.StressTestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>[]
        }
        create: {
          args: Prisma.StressTestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        createMany: {
          args: Prisma.StressTestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StressTestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>[]
        }
        delete: {
          args: Prisma.StressTestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        update: {
          args: Prisma.StressTestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        deleteMany: {
          args: Prisma.StressTestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StressTestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StressTestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>[]
        }
        upsert: {
          args: Prisma.StressTestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StressTestPayload>
        }
        aggregate: {
          args: Prisma.StressTestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStressTest>
        }
        groupBy: {
          args: Prisma.StressTestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StressTestGroupByOutputType>[]
        }
        count: {
          args: Prisma.StressTestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StressTestCountAggregateOutputType> | number
        }
      }
    }
    SimulationState: {
      payload: Prisma.$SimulationStatePayload<ExtArgs>
      fields: Prisma.SimulationStateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SimulationStateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SimulationStateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        findFirst: {
          args: Prisma.SimulationStateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SimulationStateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        findMany: {
          args: Prisma.SimulationStateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
        }
        create: {
          args: Prisma.SimulationStateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        createMany: {
          args: Prisma.SimulationStateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SimulationStateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
        }
        delete: {
          args: Prisma.SimulationStateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        update: {
          args: Prisma.SimulationStateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        deleteMany: {
          args: Prisma.SimulationStateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SimulationStateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SimulationStateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>[]
        }
        upsert: {
          args: Prisma.SimulationStateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SimulationStatePayload>
        }
        aggregate: {
          args: Prisma.SimulationStateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSimulationState>
        }
        groupBy: {
          args: Prisma.SimulationStateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SimulationStateGroupByOutputType>[]
        }
        count: {
          args: Prisma.SimulationStateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SimulationStateCountAggregateOutputType> | number
        }
      }
    }
    ScenarioComment: {
      payload: Prisma.$ScenarioCommentPayload<ExtArgs>
      fields: Prisma.ScenarioCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScenarioCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScenarioCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        findFirst: {
          args: Prisma.ScenarioCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScenarioCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        findMany: {
          args: Prisma.ScenarioCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>[]
        }
        create: {
          args: Prisma.ScenarioCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        createMany: {
          args: Prisma.ScenarioCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScenarioCommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>[]
        }
        delete: {
          args: Prisma.ScenarioCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        update: {
          args: Prisma.ScenarioCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        deleteMany: {
          args: Prisma.ScenarioCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScenarioCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScenarioCommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>[]
        }
        upsert: {
          args: Prisma.ScenarioCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioCommentPayload>
        }
        aggregate: {
          args: Prisma.ScenarioCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScenarioComment>
        }
        groupBy: {
          args: Prisma.ScenarioCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScenarioCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioCommentCountAggregateOutputType> | number
        }
      }
    }
    ScenarioDecision: {
      payload: Prisma.$ScenarioDecisionPayload<ExtArgs>
      fields: Prisma.ScenarioDecisionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScenarioDecisionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScenarioDecisionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        findFirst: {
          args: Prisma.ScenarioDecisionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScenarioDecisionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        findMany: {
          args: Prisma.ScenarioDecisionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>[]
        }
        create: {
          args: Prisma.ScenarioDecisionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        createMany: {
          args: Prisma.ScenarioDecisionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScenarioDecisionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>[]
        }
        delete: {
          args: Prisma.ScenarioDecisionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        update: {
          args: Prisma.ScenarioDecisionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        deleteMany: {
          args: Prisma.ScenarioDecisionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScenarioDecisionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScenarioDecisionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>[]
        }
        upsert: {
          args: Prisma.ScenarioDecisionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioDecisionPayload>
        }
        aggregate: {
          args: Prisma.ScenarioDecisionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScenarioDecision>
        }
        groupBy: {
          args: Prisma.ScenarioDecisionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioDecisionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScenarioDecisionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioDecisionCountAggregateOutputType> | number
        }
      }
    }
    ScenarioChangeEvent: {
      payload: Prisma.$ScenarioChangeEventPayload<ExtArgs>
      fields: Prisma.ScenarioChangeEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScenarioChangeEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScenarioChangeEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        findFirst: {
          args: Prisma.ScenarioChangeEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScenarioChangeEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        findMany: {
          args: Prisma.ScenarioChangeEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>[]
        }
        create: {
          args: Prisma.ScenarioChangeEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        createMany: {
          args: Prisma.ScenarioChangeEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ScenarioChangeEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>[]
        }
        delete: {
          args: Prisma.ScenarioChangeEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        update: {
          args: Prisma.ScenarioChangeEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        deleteMany: {
          args: Prisma.ScenarioChangeEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScenarioChangeEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ScenarioChangeEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>[]
        }
        upsert: {
          args: Prisma.ScenarioChangeEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScenarioChangeEventPayload>
        }
        aggregate: {
          args: Prisma.ScenarioChangeEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScenarioChangeEvent>
        }
        groupBy: {
          args: Prisma.ScenarioChangeEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioChangeEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScenarioChangeEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScenarioChangeEventCountAggregateOutputType> | number
        }
      }
    }
    KPI: {
      payload: Prisma.$KPIPayload<ExtArgs>
      fields: Prisma.KPIFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KPIFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KPIFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        findFirst: {
          args: Prisma.KPIFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KPIFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        findMany: {
          args: Prisma.KPIFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>[]
        }
        create: {
          args: Prisma.KPICreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        createMany: {
          args: Prisma.KPICreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KPICreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>[]
        }
        delete: {
          args: Prisma.KPIDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        update: {
          args: Prisma.KPIUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        deleteMany: {
          args: Prisma.KPIDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KPIUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KPIUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>[]
        }
        upsert: {
          args: Prisma.KPIUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIPayload>
        }
        aggregate: {
          args: Prisma.KPIAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKPI>
        }
        groupBy: {
          args: Prisma.KPIGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIGroupByOutputType>[]
        }
        count: {
          args: Prisma.KPICountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPICountAggregateOutputType> | number
        }
      }
    }
    KPIHistory: {
      payload: Prisma.$KPIHistoryPayload<ExtArgs>
      fields: Prisma.KPIHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KPIHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KPIHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        findFirst: {
          args: Prisma.KPIHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KPIHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        findMany: {
          args: Prisma.KPIHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>[]
        }
        create: {
          args: Prisma.KPIHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        createMany: {
          args: Prisma.KPIHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KPIHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>[]
        }
        delete: {
          args: Prisma.KPIHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        update: {
          args: Prisma.KPIHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        deleteMany: {
          args: Prisma.KPIHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KPIHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KPIHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>[]
        }
        upsert: {
          args: Prisma.KPIHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIHistoryPayload>
        }
        aggregate: {
          args: Prisma.KPIHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKPIHistory>
        }
        groupBy: {
          args: Prisma.KPIHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.KPIHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIHistoryCountAggregateOutputType> | number
        }
      }
    }
    KPIAlert: {
      payload: Prisma.$KPIAlertPayload<ExtArgs>
      fields: Prisma.KPIAlertFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KPIAlertFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KPIAlertFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        findFirst: {
          args: Prisma.KPIAlertFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KPIAlertFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        findMany: {
          args: Prisma.KPIAlertFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>[]
        }
        create: {
          args: Prisma.KPIAlertCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        createMany: {
          args: Prisma.KPIAlertCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KPIAlertCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>[]
        }
        delete: {
          args: Prisma.KPIAlertDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        update: {
          args: Prisma.KPIAlertUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        deleteMany: {
          args: Prisma.KPIAlertDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KPIAlertUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KPIAlertUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>[]
        }
        upsert: {
          args: Prisma.KPIAlertUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIAlertPayload>
        }
        aggregate: {
          args: Prisma.KPIAlertAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKPIAlert>
        }
        groupBy: {
          args: Prisma.KPIAlertGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIAlertGroupByOutputType>[]
        }
        count: {
          args: Prisma.KPIAlertCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIAlertCountAggregateOutputType> | number
        }
      }
    }
    KPITarget: {
      payload: Prisma.$KPITargetPayload<ExtArgs>
      fields: Prisma.KPITargetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KPITargetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KPITargetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        findFirst: {
          args: Prisma.KPITargetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KPITargetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        findMany: {
          args: Prisma.KPITargetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>[]
        }
        create: {
          args: Prisma.KPITargetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        createMany: {
          args: Prisma.KPITargetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KPITargetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>[]
        }
        delete: {
          args: Prisma.KPITargetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        update: {
          args: Prisma.KPITargetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        deleteMany: {
          args: Prisma.KPITargetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KPITargetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KPITargetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>[]
        }
        upsert: {
          args: Prisma.KPITargetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPITargetPayload>
        }
        aggregate: {
          args: Prisma.KPITargetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKPITarget>
        }
        groupBy: {
          args: Prisma.KPITargetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPITargetGroupByOutputType>[]
        }
        count: {
          args: Prisma.KPITargetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPITargetCountAggregateOutputType> | number
        }
      }
    }
    KPIBenchmark: {
      payload: Prisma.$KPIBenchmarkPayload<ExtArgs>
      fields: Prisma.KPIBenchmarkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KPIBenchmarkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KPIBenchmarkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        findFirst: {
          args: Prisma.KPIBenchmarkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KPIBenchmarkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        findMany: {
          args: Prisma.KPIBenchmarkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>[]
        }
        create: {
          args: Prisma.KPIBenchmarkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        createMany: {
          args: Prisma.KPIBenchmarkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KPIBenchmarkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>[]
        }
        delete: {
          args: Prisma.KPIBenchmarkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        update: {
          args: Prisma.KPIBenchmarkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        deleteMany: {
          args: Prisma.KPIBenchmarkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KPIBenchmarkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KPIBenchmarkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>[]
        }
        upsert: {
          args: Prisma.KPIBenchmarkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KPIBenchmarkPayload>
        }
        aggregate: {
          args: Prisma.KPIBenchmarkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKPIBenchmark>
        }
        groupBy: {
          args: Prisma.KPIBenchmarkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIBenchmarkGroupByOutputType>[]
        }
        count: {
          args: Prisma.KPIBenchmarkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KPIBenchmarkCountAggregateOutputType> | number
        }
      }
    }
    FXRate: {
      payload: Prisma.$FXRatePayload<ExtArgs>
      fields: Prisma.FXRateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXRateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXRateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        findFirst: {
          args: Prisma.FXRateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXRateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        findMany: {
          args: Prisma.FXRateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>[]
        }
        create: {
          args: Prisma.FXRateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        createMany: {
          args: Prisma.FXRateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXRateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>[]
        }
        delete: {
          args: Prisma.FXRateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        update: {
          args: Prisma.FXRateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        deleteMany: {
          args: Prisma.FXRateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXRateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXRateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>[]
        }
        upsert: {
          args: Prisma.FXRateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRatePayload>
        }
        aggregate: {
          args: Prisma.FXRateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXRate>
        }
        groupBy: {
          args: Prisma.FXRateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXRateGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXRateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXRateCountAggregateOutputType> | number
        }
      }
    }
    FXExposure: {
      payload: Prisma.$FXExposurePayload<ExtArgs>
      fields: Prisma.FXExposureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXExposureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXExposureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        findFirst: {
          args: Prisma.FXExposureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXExposureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        findMany: {
          args: Prisma.FXExposureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>[]
        }
        create: {
          args: Prisma.FXExposureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        createMany: {
          args: Prisma.FXExposureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXExposureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>[]
        }
        delete: {
          args: Prisma.FXExposureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        update: {
          args: Prisma.FXExposureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        deleteMany: {
          args: Prisma.FXExposureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXExposureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXExposureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>[]
        }
        upsert: {
          args: Prisma.FXExposureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXExposurePayload>
        }
        aggregate: {
          args: Prisma.FXExposureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXExposure>
        }
        groupBy: {
          args: Prisma.FXExposureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXExposureGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXExposureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXExposureCountAggregateOutputType> | number
        }
      }
    }
    FXConversion: {
      payload: Prisma.$FXConversionPayload<ExtArgs>
      fields: Prisma.FXConversionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXConversionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXConversionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        findFirst: {
          args: Prisma.FXConversionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXConversionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        findMany: {
          args: Prisma.FXConversionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>[]
        }
        create: {
          args: Prisma.FXConversionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        createMany: {
          args: Prisma.FXConversionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXConversionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>[]
        }
        delete: {
          args: Prisma.FXConversionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        update: {
          args: Prisma.FXConversionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        deleteMany: {
          args: Prisma.FXConversionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXConversionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXConversionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>[]
        }
        upsert: {
          args: Prisma.FXConversionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXConversionPayload>
        }
        aggregate: {
          args: Prisma.FXConversionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXConversion>
        }
        groupBy: {
          args: Prisma.FXConversionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXConversionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXConversionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXConversionCountAggregateOutputType> | number
        }
      }
    }
    FXScenario: {
      payload: Prisma.$FXScenarioPayload<ExtArgs>
      fields: Prisma.FXScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        findFirst: {
          args: Prisma.FXScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        findMany: {
          args: Prisma.FXScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>[]
        }
        create: {
          args: Prisma.FXScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        createMany: {
          args: Prisma.FXScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>[]
        }
        delete: {
          args: Prisma.FXScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        update: {
          args: Prisma.FXScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        deleteMany: {
          args: Prisma.FXScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>[]
        }
        upsert: {
          args: Prisma.FXScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXScenarioPayload>
        }
        aggregate: {
          args: Prisma.FXScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXScenario>
        }
        groupBy: {
          args: Prisma.FXScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXScenarioCountAggregateOutputType> | number
        }
      }
    }
    FXForecast: {
      payload: Prisma.$FXForecastPayload<ExtArgs>
      fields: Prisma.FXForecastFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXForecastFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXForecastFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        findFirst: {
          args: Prisma.FXForecastFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXForecastFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        findMany: {
          args: Prisma.FXForecastFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>[]
        }
        create: {
          args: Prisma.FXForecastCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        createMany: {
          args: Prisma.FXForecastCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXForecastCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>[]
        }
        delete: {
          args: Prisma.FXForecastDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        update: {
          args: Prisma.FXForecastUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        deleteMany: {
          args: Prisma.FXForecastDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXForecastUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXForecastUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>[]
        }
        upsert: {
          args: Prisma.FXForecastUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXForecastPayload>
        }
        aggregate: {
          args: Prisma.FXForecastAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXForecast>
        }
        groupBy: {
          args: Prisma.FXForecastGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXForecastGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXForecastCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXForecastCountAggregateOutputType> | number
        }
      }
    }
    FXCost: {
      payload: Prisma.$FXCostPayload<ExtArgs>
      fields: Prisma.FXCostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXCostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXCostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        findFirst: {
          args: Prisma.FXCostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXCostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        findMany: {
          args: Prisma.FXCostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>[]
        }
        create: {
          args: Prisma.FXCostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        createMany: {
          args: Prisma.FXCostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXCostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>[]
        }
        delete: {
          args: Prisma.FXCostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        update: {
          args: Prisma.FXCostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        deleteMany: {
          args: Prisma.FXCostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXCostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXCostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>[]
        }
        upsert: {
          args: Prisma.FXCostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXCostPayload>
        }
        aggregate: {
          args: Prisma.FXCostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXCost>
        }
        groupBy: {
          args: Prisma.FXCostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXCostGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXCostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXCostCountAggregateOutputType> | number
        }
      }
    }
    FXRiskIndicator: {
      payload: Prisma.$FXRiskIndicatorPayload<ExtArgs>
      fields: Prisma.FXRiskIndicatorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXRiskIndicatorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXRiskIndicatorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        findFirst: {
          args: Prisma.FXRiskIndicatorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXRiskIndicatorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        findMany: {
          args: Prisma.FXRiskIndicatorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>[]
        }
        create: {
          args: Prisma.FXRiskIndicatorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        createMany: {
          args: Prisma.FXRiskIndicatorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXRiskIndicatorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>[]
        }
        delete: {
          args: Prisma.FXRiskIndicatorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        update: {
          args: Prisma.FXRiskIndicatorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        deleteMany: {
          args: Prisma.FXRiskIndicatorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXRiskIndicatorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXRiskIndicatorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>[]
        }
        upsert: {
          args: Prisma.FXRiskIndicatorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXRiskIndicatorPayload>
        }
        aggregate: {
          args: Prisma.FXRiskIndicatorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXRiskIndicator>
        }
        groupBy: {
          args: Prisma.FXRiskIndicatorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXRiskIndicatorGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXRiskIndicatorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXRiskIndicatorCountAggregateOutputType> | number
        }
      }
    }
    FXAuditLog: {
      payload: Prisma.$FXAuditLogPayload<ExtArgs>
      fields: Prisma.FXAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FXAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FXAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        findFirst: {
          args: Prisma.FXAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FXAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        findMany: {
          args: Prisma.FXAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>[]
        }
        create: {
          args: Prisma.FXAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        createMany: {
          args: Prisma.FXAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FXAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>[]
        }
        delete: {
          args: Prisma.FXAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        update: {
          args: Prisma.FXAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.FXAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FXAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FXAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.FXAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FXAuditLogPayload>
        }
        aggregate: {
          args: Prisma.FXAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFXAuditLog>
        }
        groupBy: {
          args: Prisma.FXAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.FXAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FXAuditLogCountAggregateOutputType> | number
        }
      }
    }
    InvestorSnapshot: {
      payload: Prisma.$InvestorSnapshotPayload<ExtArgs>
      fields: Prisma.InvestorSnapshotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvestorSnapshotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvestorSnapshotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        findFirst: {
          args: Prisma.InvestorSnapshotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvestorSnapshotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        findMany: {
          args: Prisma.InvestorSnapshotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>[]
        }
        create: {
          args: Prisma.InvestorSnapshotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        createMany: {
          args: Prisma.InvestorSnapshotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvestorSnapshotCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>[]
        }
        delete: {
          args: Prisma.InvestorSnapshotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        update: {
          args: Prisma.InvestorSnapshotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        deleteMany: {
          args: Prisma.InvestorSnapshotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvestorSnapshotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvestorSnapshotUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>[]
        }
        upsert: {
          args: Prisma.InvestorSnapshotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorSnapshotPayload>
        }
        aggregate: {
          args: Prisma.InvestorSnapshotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvestorSnapshot>
        }
        groupBy: {
          args: Prisma.InvestorSnapshotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorSnapshotGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvestorSnapshotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorSnapshotCountAggregateOutputType> | number
        }
      }
    }
    BoardReport: {
      payload: Prisma.$BoardReportPayload<ExtArgs>
      fields: Prisma.BoardReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BoardReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BoardReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        findFirst: {
          args: Prisma.BoardReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BoardReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        findMany: {
          args: Prisma.BoardReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>[]
        }
        create: {
          args: Prisma.BoardReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        createMany: {
          args: Prisma.BoardReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BoardReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>[]
        }
        delete: {
          args: Prisma.BoardReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        update: {
          args: Prisma.BoardReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        deleteMany: {
          args: Prisma.BoardReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BoardReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BoardReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>[]
        }
        upsert: {
          args: Prisma.BoardReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BoardReportPayload>
        }
        aggregate: {
          args: Prisma.BoardReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBoardReport>
        }
        groupBy: {
          args: Prisma.BoardReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BoardReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.BoardReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BoardReportCountAggregateOutputType> | number
        }
      }
    }
    RunwayProjection: {
      payload: Prisma.$RunwayProjectionPayload<ExtArgs>
      fields: Prisma.RunwayProjectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RunwayProjectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RunwayProjectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        findFirst: {
          args: Prisma.RunwayProjectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RunwayProjectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        findMany: {
          args: Prisma.RunwayProjectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>[]
        }
        create: {
          args: Prisma.RunwayProjectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        createMany: {
          args: Prisma.RunwayProjectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RunwayProjectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>[]
        }
        delete: {
          args: Prisma.RunwayProjectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        update: {
          args: Prisma.RunwayProjectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        deleteMany: {
          args: Prisma.RunwayProjectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RunwayProjectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RunwayProjectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>[]
        }
        upsert: {
          args: Prisma.RunwayProjectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RunwayProjectionPayload>
        }
        aggregate: {
          args: Prisma.RunwayProjectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRunwayProjection>
        }
        groupBy: {
          args: Prisma.RunwayProjectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RunwayProjectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RunwayProjectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RunwayProjectionCountAggregateOutputType> | number
        }
      }
    }
    InvestorAccessLog: {
      payload: Prisma.$InvestorAccessLogPayload<ExtArgs>
      fields: Prisma.InvestorAccessLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvestorAccessLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvestorAccessLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        findFirst: {
          args: Prisma.InvestorAccessLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvestorAccessLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        findMany: {
          args: Prisma.InvestorAccessLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>[]
        }
        create: {
          args: Prisma.InvestorAccessLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        createMany: {
          args: Prisma.InvestorAccessLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvestorAccessLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>[]
        }
        delete: {
          args: Prisma.InvestorAccessLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        update: {
          args: Prisma.InvestorAccessLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        deleteMany: {
          args: Prisma.InvestorAccessLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvestorAccessLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvestorAccessLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>[]
        }
        upsert: {
          args: Prisma.InvestorAccessLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorAccessLogPayload>
        }
        aggregate: {
          args: Prisma.InvestorAccessLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvestorAccessLog>
        }
        groupBy: {
          args: Prisma.InvestorAccessLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorAccessLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvestorAccessLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorAccessLogCountAggregateOutputType> | number
        }
      }
    }
    CashflowItem: {
      payload: Prisma.$CashflowItemPayload<ExtArgs>
      fields: Prisma.CashflowItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CashflowItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CashflowItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        findFirst: {
          args: Prisma.CashflowItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CashflowItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        findMany: {
          args: Prisma.CashflowItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>[]
        }
        create: {
          args: Prisma.CashflowItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        createMany: {
          args: Prisma.CashflowItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CashflowItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>[]
        }
        delete: {
          args: Prisma.CashflowItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        update: {
          args: Prisma.CashflowItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        deleteMany: {
          args: Prisma.CashflowItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CashflowItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CashflowItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>[]
        }
        upsert: {
          args: Prisma.CashflowItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CashflowItemPayload>
        }
        aggregate: {
          args: Prisma.CashflowItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCashflowItem>
        }
        groupBy: {
          args: Prisma.CashflowItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashflowItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.CashflowItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CashflowItemCountAggregateOutputType> | number
        }
      }
    }
    LiquidityScenario: {
      payload: Prisma.$LiquidityScenarioPayload<ExtArgs>
      fields: Prisma.LiquidityScenarioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiquidityScenarioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiquidityScenarioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        findFirst: {
          args: Prisma.LiquidityScenarioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiquidityScenarioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        findMany: {
          args: Prisma.LiquidityScenarioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>[]
        }
        create: {
          args: Prisma.LiquidityScenarioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        createMany: {
          args: Prisma.LiquidityScenarioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiquidityScenarioCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>[]
        }
        delete: {
          args: Prisma.LiquidityScenarioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        update: {
          args: Prisma.LiquidityScenarioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        deleteMany: {
          args: Prisma.LiquidityScenarioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiquidityScenarioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiquidityScenarioUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>[]
        }
        upsert: {
          args: Prisma.LiquidityScenarioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityScenarioPayload>
        }
        aggregate: {
          args: Prisma.LiquidityScenarioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiquidityScenario>
        }
        groupBy: {
          args: Prisma.LiquidityScenarioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityScenarioGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiquidityScenarioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityScenarioCountAggregateOutputType> | number
        }
      }
    }
    LiquidityGap: {
      payload: Prisma.$LiquidityGapPayload<ExtArgs>
      fields: Prisma.LiquidityGapFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiquidityGapFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiquidityGapFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        findFirst: {
          args: Prisma.LiquidityGapFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiquidityGapFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        findMany: {
          args: Prisma.LiquidityGapFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>[]
        }
        create: {
          args: Prisma.LiquidityGapCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        createMany: {
          args: Prisma.LiquidityGapCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiquidityGapCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>[]
        }
        delete: {
          args: Prisma.LiquidityGapDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        update: {
          args: Prisma.LiquidityGapUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        deleteMany: {
          args: Prisma.LiquidityGapDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiquidityGapUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiquidityGapUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>[]
        }
        upsert: {
          args: Prisma.LiquidityGapUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityGapPayload>
        }
        aggregate: {
          args: Prisma.LiquidityGapAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiquidityGap>
        }
        groupBy: {
          args: Prisma.LiquidityGapGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityGapGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiquidityGapCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityGapCountAggregateOutputType> | number
        }
      }
    }
    LiquidityRiskSignal: {
      payload: Prisma.$LiquidityRiskSignalPayload<ExtArgs>
      fields: Prisma.LiquidityRiskSignalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiquidityRiskSignalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiquidityRiskSignalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        findFirst: {
          args: Prisma.LiquidityRiskSignalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiquidityRiskSignalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        findMany: {
          args: Prisma.LiquidityRiskSignalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>[]
        }
        create: {
          args: Prisma.LiquidityRiskSignalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        createMany: {
          args: Prisma.LiquidityRiskSignalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiquidityRiskSignalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>[]
        }
        delete: {
          args: Prisma.LiquidityRiskSignalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        update: {
          args: Prisma.LiquidityRiskSignalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        deleteMany: {
          args: Prisma.LiquidityRiskSignalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiquidityRiskSignalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiquidityRiskSignalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>[]
        }
        upsert: {
          args: Prisma.LiquidityRiskSignalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityRiskSignalPayload>
        }
        aggregate: {
          args: Prisma.LiquidityRiskSignalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiquidityRiskSignal>
        }
        groupBy: {
          args: Prisma.LiquidityRiskSignalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityRiskSignalGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiquidityRiskSignalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityRiskSignalCountAggregateOutputType> | number
        }
      }
    }
    LiquidityAuditLog: {
      payload: Prisma.$LiquidityAuditLogPayload<ExtArgs>
      fields: Prisma.LiquidityAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiquidityAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiquidityAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        findFirst: {
          args: Prisma.LiquidityAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiquidityAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        findMany: {
          args: Prisma.LiquidityAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>[]
        }
        create: {
          args: Prisma.LiquidityAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        createMany: {
          args: Prisma.LiquidityAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiquidityAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>[]
        }
        delete: {
          args: Prisma.LiquidityAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        update: {
          args: Prisma.LiquidityAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.LiquidityAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiquidityAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiquidityAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.LiquidityAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityAuditLogPayload>
        }
        aggregate: {
          args: Prisma.LiquidityAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiquidityAuditLog>
        }
        groupBy: {
          args: Prisma.LiquidityAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiquidityAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityAuditLogCountAggregateOutputType> | number
        }
      }
    }
    LiquidityPosition: {
      payload: Prisma.$LiquidityPositionPayload<ExtArgs>
      fields: Prisma.LiquidityPositionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiquidityPositionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiquidityPositionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        findFirst: {
          args: Prisma.LiquidityPositionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiquidityPositionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        findMany: {
          args: Prisma.LiquidityPositionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>[]
        }
        create: {
          args: Prisma.LiquidityPositionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        createMany: {
          args: Prisma.LiquidityPositionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiquidityPositionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>[]
        }
        delete: {
          args: Prisma.LiquidityPositionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        update: {
          args: Prisma.LiquidityPositionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        deleteMany: {
          args: Prisma.LiquidityPositionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiquidityPositionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiquidityPositionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>[]
        }
        upsert: {
          args: Prisma.LiquidityPositionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiquidityPositionPayload>
        }
        aggregate: {
          args: Prisma.LiquidityPositionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiquidityPosition>
        }
        groupBy: {
          args: Prisma.LiquidityPositionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityPositionGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiquidityPositionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiquidityPositionCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  emailVerified: 'emailVerified',
  image: 'image',
  role: 'role',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  access_token: 'access_token',
  expires_at: 'expires_at',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  country: 'country',
  industry: 'industry',
  fiscalYearEnd: 'fiscalYearEnd',
  defaultCurrency: 'defaultCurrency',
  taxId: 'taxId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const FinancialAccountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  accountNumber: 'accountNumber',
  type: 'type',
  balance: 'balance',
  currency: 'currency',
  isActive: 'isActive',
  description: 'description',
  parentId: 'parentId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinancialAccountScalarFieldEnum = (typeof FinancialAccountScalarFieldEnum)[keyof typeof FinancialAccountScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  date: 'date',
  description: 'description',
  amount: 'amount',
  currency: 'currency',
  type: 'type',
  category: 'category',
  status: 'status',
  tags: 'tags',
  tokenized: 'tokenized',
  txHash: 'txHash',
  deletedAt: 'deletedAt',
  accountId: 'accountId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const ReceiptScalarFieldEnum = {
  id: 'id',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  fileSize: 'fileSize',
  vendor: 'vendor',
  amount: 'amount',
  date: 'date',
  extractedText: 'extractedText',
  confidence: 'confidence',
  category: 'category',
  status: 'status',
  deletedAt: 'deletedAt',
  transactionId: 'transactionId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


export const ChatChannelScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChatChannelScalarFieldEnum = (typeof ChatChannelScalarFieldEnum)[keyof typeof ChatChannelScalarFieldEnum]


export const ChatMessageScalarFieldEnum = {
  id: 'id',
  content: 'content',
  channelId: 'channelId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


export const UserSettingsScalarFieldEnum = {
  id: 'id',
  language: 'language',
  timezone: 'timezone',
  currency: 'currency',
  dateFormat: 'dateFormat',
  theme: 'theme',
  emailNotifications: 'emailNotifications',
  pushNotifications: 'pushNotifications',
  transactionNotifications: 'transactionNotifications',
  reportNotifications: 'reportNotifications',
  aiSuggestionNotifications: 'aiSuggestionNotifications',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


export const WalletScalarFieldEnum = {
  id: 'id',
  name: 'name',
  address: 'address',
  network: 'network',
  provider: 'provider',
  isActive: 'isActive',
  isWatching: 'isWatching',
  nativeBalance: 'nativeBalance',
  nativeSymbol: 'nativeSymbol',
  totalValueUsd: 'totalValueUsd',
  lastSyncAt: 'lastSyncAt',
  lastSyncStatus: 'lastSyncStatus',
  walletType: 'walletType',
  purpose: 'purpose',
  ens: 'ens',
  avatar: 'avatar',
  notes: 'notes',
  tags: 'tags',
  isDefault: 'isDefault',
  userId: 'userId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


export const WalletTokenScalarFieldEnum = {
  id: 'id',
  contractAddress: 'contractAddress',
  symbol: 'symbol',
  name: 'name',
  decimals: 'decimals',
  logoUrl: 'logoUrl',
  balance: 'balance',
  balanceUsd: 'balanceUsd',
  priceUsd: 'priceUsd',
  price24hChange: 'price24hChange',
  tokenType: 'tokenType',
  isHidden: 'isHidden',
  isSpam: 'isSpam',
  lastPriceAt: 'lastPriceAt',
  walletId: 'walletId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WalletTokenScalarFieldEnum = (typeof WalletTokenScalarFieldEnum)[keyof typeof WalletTokenScalarFieldEnum]


export const WalletTransactionScalarFieldEnum = {
  id: 'id',
  hash: 'hash',
  blockNumber: 'blockNumber',
  network: 'network',
  type: 'type',
  status: 'status',
  fromAddress: 'fromAddress',
  toAddress: 'toAddress',
  isIncoming: 'isIncoming',
  value: 'value',
  valueUsd: 'valueUsd',
  tokenSymbol: 'tokenSymbol',
  tokenAddress: 'tokenAddress',
  gasUsed: 'gasUsed',
  gasPrice: 'gasPrice',
  gasCostUsd: 'gasCostUsd',
  timestamp: 'timestamp',
  confirmedAt: 'confirmedAt',
  methodName: 'methodName',
  description: 'description',
  notes: 'notes',
  tags: 'tags',
  linkedTransactionId: 'linkedTransactionId',
  walletId: 'walletId',
  createdAt: 'createdAt'
} as const

export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


export const AISuggestionScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  impact: 'impact',
  priority: 'priority',
  status: 'status',
  metadata: 'metadata',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AISuggestionScalarFieldEnum = (typeof AISuggestionScalarFieldEnum)[keyof typeof AISuggestionScalarFieldEnum]


export const SavedReportScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  parameters: 'parameters',
  isScheduled: 'isScheduled',
  scheduleFreq: 'scheduleFreq',
  lastGenerated: 'lastGenerated',
  status: 'status',
  archivedAt: 'archivedAt',
  cachedData: 'cachedData',
  cacheExpiry: 'cacheExpiry',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SavedReportScalarFieldEnum = (typeof SavedReportScalarFieldEnum)[keyof typeof SavedReportScalarFieldEnum]


export const CorporateEntityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  jurisdiction: 'jurisdiction',
  taxId: 'taxId',
  incorporationDate: 'incorporationDate',
  ownershipPercent: 'ownershipPercent',
  revenue: 'revenue',
  expenses: 'expenses',
  taxLiability: 'taxLiability',
  effectiveTaxRate: 'effectiveTaxRate',
  isActive: 'isActive',
  parentId: 'parentId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CorporateEntityScalarFieldEnum = (typeof CorporateEntityScalarFieldEnum)[keyof typeof CorporateEntityScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  invoiceNumber: 'invoiceNumber',
  status: 'status',
  version: 'version',
  isLatest: 'isLatest',
  previousVersionId: 'previousVersionId',
  customerId: 'customerId',
  customerName: 'customerName',
  customerEmail: 'customerEmail',
  customerTaxId: 'customerTaxId',
  customerAddress: 'customerAddress',
  sender: 'sender',
  recipient: 'recipient',
  entityId: 'entityId',
  entityName: 'entityName',
  entityTaxId: 'entityTaxId',
  entityAddress: 'entityAddress',
  invoiceDate: 'invoiceDate',
  dueDate: 'dueDate',
  serviceDate: 'serviceDate',
  servicePeriodStart: 'servicePeriodStart',
  servicePeriodEnd: 'servicePeriodEnd',
  items: 'items',
  currency: 'currency',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  taxableAmount: 'taxableAmount',
  discountAmount: 'discountAmount',
  discountPercent: 'discountPercent',
  total: 'total',
  paidAmount: 'paidAmount',
  outstandingAmount: 'outstandingAmount',
  applyTax: 'applyTax',
  taxRate: 'taxRate',
  taxClassification: 'taxClassification',
  taxExemptReason: 'taxExemptReason',
  taxExemptNote: 'taxExemptNote',
  taxJurisdiction: 'taxJurisdiction',
  fxRateToBase: 'fxRateToBase',
  fxRateDate: 'fxRateDate',
  baseCurrency: 'baseCurrency',
  totalInBase: 'totalInBase',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  payment: 'payment',
  paymentTerms: 'paymentTerms',
  bankDetails: 'bankDetails',
  confirmedAt: 'confirmedAt',
  sentAt: 'sentAt',
  paidAt: 'paidAt',
  cancelledAt: 'cancelledAt',
  archivedAt: 'archivedAt',
  createdBy: 'createdBy',
  createdByName: 'createdByName',
  confirmedBy: 'confirmedBy',
  confirmedByName: 'confirmedByName',
  cancelledBy: 'cancelledBy',
  cancelledByName: 'cancelledByName',
  cancellationReason: 'cancellationReason',
  notes: 'notes',
  internalNotes: 'internalNotes',
  language: 'language',
  reference: 'reference',
  poNumber: 'poNumber',
  isRecurring: 'isRecurring',
  recurringInterval: 'recurringInterval',
  recurringEndDate: 'recurringEndDate',
  nextRecurringDate: 'nextRecurringDate',
  parentInvoiceId: 'parentInvoiceId',
  orderNumber: 'orderNumber',
  projectId: 'projectId',
  costCenterId: 'costCenterId',
  receivableId: 'receivableId',
  organizationId: 'organizationId',
  orderId: 'orderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const InvoiceVersionScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  version: 'version',
  snapshot: 'snapshot',
  changeType: 'changeType',
  changeReason: 'changeReason',
  changedFields: 'changedFields',
  createdBy: 'createdBy',
  createdByName: 'createdByName',
  createdAt: 'createdAt'
} as const

export type InvoiceVersionScalarFieldEnum = (typeof InvoiceVersionScalarFieldEnum)[keyof typeof InvoiceVersionScalarFieldEnum]


export const InvoiceAccountingEventScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  invoiceId: 'invoiceId',
  eventType: 'eventType',
  debitAccountId: 'debitAccountId',
  debitAccountCode: 'debitAccountCode',
  debitAccountName: 'debitAccountName',
  creditAccountId: 'creditAccountId',
  creditAccountCode: 'creditAccountCode',
  creditAccountName: 'creditAccountName',
  amount: 'amount',
  currency: 'currency',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  effectiveDate: 'effectiveDate',
  status: 'status',
  reversedAt: 'reversedAt',
  reversalEventId: 'reversalEventId',
  description: 'description',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type InvoiceAccountingEventScalarFieldEnum = (typeof InvoiceAccountingEventScalarFieldEnum)[keyof typeof InvoiceAccountingEventScalarFieldEnum]


export const InvoicePaymentScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  amount: 'amount',
  currency: 'currency',
  paymentDate: 'paymentDate',
  paymentMethod: 'paymentMethod',
  bankAccount: 'bankAccount',
  transactionRef: 'transactionRef',
  transactionId: 'transactionId',
  reference: 'reference',
  notes: 'notes',
  status: 'status',
  creditNoteId: 'creditNoteId',
  offsetReceivableId: 'offsetReceivableId',
  treasuryMovementId: 'treasuryMovementId',
  appliedBy: 'appliedBy',
  appliedByName: 'appliedByName',
  createdAt: 'createdAt'
} as const

export type InvoicePaymentScalarFieldEnum = (typeof InvoicePaymentScalarFieldEnum)[keyof typeof InvoicePaymentScalarFieldEnum]


export const OrderScalarFieldEnum = {
  id: 'id',
  orderNumber: 'orderNumber',
  status: 'status',
  customerId: 'customerId',
  customerName: 'customerName',
  customerEmail: 'customerEmail',
  customerAddress: 'customerAddress',
  orderDate: 'orderDate',
  expectedDeliveryDate: 'expectedDeliveryDate',
  completedDate: 'completedDate',
  items: 'items',
  currency: 'currency',
  subtotal: 'subtotal',
  taxAmount: 'taxAmount',
  discountAmount: 'discountAmount',
  total: 'total',
  taxRate: 'taxRate',
  fulfilledQuantity: 'fulfilledQuantity',
  totalQuantity: 'totalQuantity',
  fulfillmentPercent: 'fulfillmentPercent',
  invoicedAmount: 'invoicedAmount',
  paidAmount: 'paidAmount',
  notes: 'notes',
  internalNotes: 'internalNotes',
  tags: 'tags',
  priority: 'priority',
  isRecurring: 'isRecurring',
  recurringInterval: 'recurringInterval',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId'
} as const

export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


export const ArchiveRecordScalarFieldEnum = {
  id: 'id',
  archiveRecordId: 'archiveRecordId',
  originalObjectId: 'originalObjectId',
  objectType: 'objectType',
  objectVersion: 'objectVersion',
  parentRecordId: 'parentRecordId',
  legalEntityId: 'legalEntityId',
  partyId: 'partyId',
  createdAt: 'createdAt',
  archivedAt: 'archivedAt',
  effectiveDate: 'effectiveDate',
  accountingPeriod: 'accountingPeriod',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  timezone: 'timezone',
  contentHash: 'contentHash',
  predecessorHash: 'predecessorHash',
  signature: 'signature',
  tamperChecksum: 'tamperChecksum',
  signatureCount: 'signatureCount',
  integrityVerified: 'integrityVerified',
  lastVerifiedAt: 'lastVerifiedAt',
  triggerType: 'triggerType',
  triggerReason: 'triggerReason',
  triggerExplanation: 'triggerExplanation',
  initiatingActor: 'initiatingActor',
  initiatingActorName: 'initiatingActorName',
  actorType: 'actorType',
  sourceModule: 'sourceModule',
  linkedEntityIds: 'linkedEntityIds',
  title: 'title',
  description: 'description',
  content: 'content',
  contentType: 'contentType',
  contentSize: 'contentSize',
  amount: 'amount',
  currency: 'currency',
  reportingCurrency: 'reportingCurrency',
  fxRateAtArchive: 'fxRateAtArchive',
  amountInReporting: 'amountInReporting',
  category: 'category',
  subcategory: 'subcategory',
  jurisdictionIds: 'jurisdictionIds',
  tags: 'tags',
  systemTags: 'systemTags',
  confidenceScore: 'confidenceScore',
  validationMode: 'validationMode',
  locale: 'locale',
  language: 'language',
  displayFormats: 'displayFormats',
  counterpartyId: 'counterpartyId',
  counterpartyName: 'counterpartyName',
  counterpartyType: 'counterpartyType',
  versionNumber: 'versionNumber',
  isCurrentVersion: 'isCurrentVersion',
  supersededBy: 'supersededBy',
  supersedes: 'supersedes',
  versionReason: 'versionReason',
  retentionPolicyId: 'retentionPolicyId',
  retentionStartDate: 'retentionStartDate',
  retentionEndDate: 'retentionEndDate',
  retentionStatus: 'retentionStatus',
  legalHold: 'legalHold',
  legalHoldReason: 'legalHoldReason',
  legalHoldBy: 'legalHoldBy',
  legalHoldAt: 'legalHoldAt',
  status: 'status',
  accessCount: 'accessCount',
  lastAccessedAt: 'lastAccessedAt',
  lastAccessedBy: 'lastAccessedBy',
  exportCount: 'exportCount',
  lastExportedAt: 'lastExportedAt',
  attachments: 'attachments',
  documentCount: 'documentCount',
  ruleId: 'ruleId',
  ruleVersion: 'ruleVersion',
  explanation: 'explanation',
  proposedBy: 'proposedBy',
  proposedAt: 'proposedAt',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  importBatchId: 'importBatchId',
  importSource: 'importSource',
  importedAt: 'importedAt',
  organizationId: 'organizationId',
  updatedAt: 'updatedAt'
} as const

export type ArchiveRecordScalarFieldEnum = (typeof ArchiveRecordScalarFieldEnum)[keyof typeof ArchiveRecordScalarFieldEnum]


export const ArchiveLinkScalarFieldEnum = {
  id: 'id',
  sourceArchiveId: 'sourceArchiveId',
  targetArchiveId: 'targetArchiveId',
  linkType: 'linkType',
  linkDirection: 'linkDirection',
  linkDescription: 'linkDescription',
  linkedAt: 'linkedAt',
  linkedBy: 'linkedBy',
  isImmutable: 'isImmutable'
} as const

export type ArchiveLinkScalarFieldEnum = (typeof ArchiveLinkScalarFieldEnum)[keyof typeof ArchiveLinkScalarFieldEnum]


export const ArchiveVersionScalarFieldEnum = {
  id: 'id',
  archiveRecordId: 'archiveRecordId',
  versionNumber: 'versionNumber',
  versionHash: 'versionHash',
  previousVersionId: 'previousVersionId',
  contentSnapshot: 'contentSnapshot',
  changeDescription: 'changeDescription',
  changedFields: 'changedFields',
  createdBy: 'createdBy',
  createdByName: 'createdByName',
  createdAt: 'createdAt'
} as const

export type ArchiveVersionScalarFieldEnum = (typeof ArchiveVersionScalarFieldEnum)[keyof typeof ArchiveVersionScalarFieldEnum]


export const ArchiveAccessLogScalarFieldEnum = {
  id: 'id',
  archiveRecordId: 'archiveRecordId',
  accessType: 'accessType',
  accessReason: 'accessReason',
  accessScope: 'accessScope',
  actorId: 'actorId',
  actorName: 'actorName',
  actorRole: 'actorRole',
  actorType: 'actorType',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  requestId: 'requestId',
  requiredApprovals: 'requiredApprovals',
  receivedApprovals: 'receivedApprovals',
  approvers: 'approvers',
  accessGrantedAt: 'accessGrantedAt',
  accessExpiresAt: 'accessExpiresAt',
  accessGranted: 'accessGranted',
  denialReason: 'denialReason',
  timestamp: 'timestamp'
} as const

export type ArchiveAccessLogScalarFieldEnum = (typeof ArchiveAccessLogScalarFieldEnum)[keyof typeof ArchiveAccessLogScalarFieldEnum]


export const ArchiveRetentionPolicyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  description: 'description',
  objectTypes: 'objectTypes',
  jurisdictions: 'jurisdictions',
  categories: 'categories',
  retentionYears: 'retentionYears',
  retentionMonths: 'retentionMonths',
  retentionStartTrigger: 'retentionStartTrigger',
  legalBasis: 'legalBasis',
  legalReference: 'legalReference',
  warningDaysBefore: 'warningDaysBefore',
  autoExtendOnAccess: 'autoExtendOnAccess',
  autoExtendDays: 'autoExtendDays',
  priority: 'priority',
  isActive: 'isActive',
  effectiveFrom: 'effectiveFrom',
  effectiveTo: 'effectiveTo',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArchiveRetentionPolicyScalarFieldEnum = (typeof ArchiveRetentionPolicyScalarFieldEnum)[keyof typeof ArchiveRetentionPolicyScalarFieldEnum]


export const ArchiveExportScalarFieldEnum = {
  id: 'id',
  exportNumber: 'exportNumber',
  exportType: 'exportType',
  exportFormat: 'exportFormat',
  archiveRecordIds: 'archiveRecordIds',
  recordCount: 'recordCount',
  filterCriteria: 'filterCriteria',
  fileUrl: 'fileUrl',
  fileSize: 'fileSize',
  fileHash: 'fileHash',
  chainOfCustody: 'chainOfCustody',
  integrityProof: 'integrityProof',
  status: 'status',
  generatedAt: 'generatedAt',
  expiresAt: 'expiresAt',
  downloadCount: 'downloadCount',
  lastDownloadedAt: 'lastDownloadedAt',
  requestedBy: 'requestedBy',
  requestedByName: 'requestedByName',
  requestPurpose: 'requestPurpose',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type ArchiveExportScalarFieldEnum = (typeof ArchiveExportScalarFieldEnum)[keyof typeof ArchiveExportScalarFieldEnum]


export const ArchiveImportBatchScalarFieldEnum = {
  id: 'id',
  batchNumber: 'batchNumber',
  source: 'source',
  sourceIdentifier: 'sourceIdentifier',
  sourceHash: 'sourceHash',
  totalRecords: 'totalRecords',
  successCount: 'successCount',
  errorCount: 'errorCount',
  warningCount: 'warningCount',
  skippedCount: 'skippedCount',
  status: 'status',
  importMode: 'importMode',
  dateFrom: 'dateFrom',
  dateTo: 'dateTo',
  objectTypeFilter: 'objectTypeFilter',
  fieldMapping: 'fieldMapping',
  errors: 'errors',
  warnings: 'warnings',
  createdRecordIds: 'createdRecordIds',
  canRollback: 'canRollback',
  rolledBackAt: 'rolledBackAt',
  rolledBackBy: 'rolledBackBy',
  importedBy: 'importedBy',
  importedByName: 'importedByName',
  organizationId: 'organizationId',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type ArchiveImportBatchScalarFieldEnum = (typeof ArchiveImportBatchScalarFieldEnum)[keyof typeof ArchiveImportBatchScalarFieldEnum]


export const ArchiveAutomationRuleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  description: 'description',
  triggerType: 'triggerType',
  triggerConditions: 'triggerConditions',
  objectTypes: 'objectTypes',
  categories: 'categories',
  action: 'action',
  actionConfig: 'actionConfig',
  confidenceThreshold: 'confidenceThreshold',
  proposalThreshold: 'proposalThreshold',
  requiresApproval: 'requiresApproval',
  approverRoles: 'approverRoles',
  isActive: 'isActive',
  priority: 'priority',
  lastExecutedAt: 'lastExecutedAt',
  executionCount: 'executionCount',
  explanationTemplate: 'explanationTemplate',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArchiveAutomationRuleScalarFieldEnum = (typeof ArchiveAutomationRuleScalarFieldEnum)[keyof typeof ArchiveAutomationRuleScalarFieldEnum]


export const ArchiveExceptionScalarFieldEnum = {
  id: 'id',
  sourceObjectId: 'sourceObjectId',
  sourceObjectType: 'sourceObjectType',
  sourceModule: 'sourceModule',
  exceptionType: 'exceptionType',
  exceptionCode: 'exceptionCode',
  exceptionMessage: 'exceptionMessage',
  exceptionDetails: 'exceptionDetails',
  validationMode: 'validationMode',
  validationErrors: 'validationErrors',
  confidenceScore: 'confidenceScore',
  assignedTo: 'assignedTo',
  assignedToName: 'assignedToName',
  assignedAt: 'assignedAt',
  slaDeadline: 'slaDeadline',
  isOverdue: 'isOverdue',
  escalationLevel: 'escalationLevel',
  escalatedTo: 'escalatedTo',
  escalatedAt: 'escalatedAt',
  status: 'status',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  resolution: 'resolution',
  resolutionAction: 'resolutionAction',
  retryCount: 'retryCount',
  maxRetries: 'maxRetries',
  lastRetryAt: 'lastRetryAt',
  nextRetryAt: 'nextRetryAt',
  archiveRecordId: 'archiveRecordId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArchiveExceptionScalarFieldEnum = (typeof ArchiveExceptionScalarFieldEnum)[keyof typeof ArchiveExceptionScalarFieldEnum]


export const ArchiveSavedViewScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  filters: 'filters',
  columns: 'columns',
  sortBy: 'sortBy',
  sortOrder: 'sortOrder',
  groupBy: 'groupBy',
  isPublic: 'isPublic',
  sharedWith: 'sharedWith',
  isScheduled: 'isScheduled',
  scheduleFrequency: 'scheduleFrequency',
  scheduleCron: 'scheduleCron',
  deliveryMethod: 'deliveryMethod',
  deliveryTarget: 'deliveryTarget',
  lastDeliveredAt: 'lastDeliveredAt',
  createdBy: 'createdBy',
  createdByName: 'createdByName',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArchiveSavedViewScalarFieldEnum = (typeof ArchiveSavedViewScalarFieldEnum)[keyof typeof ArchiveSavedViewScalarFieldEnum]


export const LiabilityScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  legalReference: 'legalReference',
  counterpartyId: 'counterpartyId',
  counterpartyName: 'counterpartyName',
  counterpartyType: 'counterpartyType',
  partyId: 'partyId',
  legalEntityId: 'legalEntityId',
  jurisdictionIds: 'jurisdictionIds',
  primaryClass: 'primaryClass',
  isInterestBearing: 'isInterestBearing',
  isSecured: 'isSecured',
  isFixed: 'isFixed',
  isGuaranteed: 'isGuaranteed',
  guarantorId: 'guarantorId',
  guarantorName: 'guarantorName',
  status: 'status',
  previousStatus: 'previousStatus',
  statusChangedAt: 'statusChangedAt',
  statusChangedBy: 'statusChangedBy',
  originalPrincipal: 'originalPrincipal',
  outstandingPrincipal: 'outstandingPrincipal',
  accruedInterest: 'accruedInterest',
  feesPenalties: 'feesPenalties',
  totalOutstanding: 'totalOutstanding',
  totalSettled: 'totalSettled',
  currency: 'currency',
  reportingCurrency: 'reportingCurrency',
  fxSource: 'fxSource',
  fxRateAtRecognition: 'fxRateAtRecognition',
  fxRateAtSettlement: 'fxRateAtSettlement',
  fxRateHistory: 'fxRateHistory',
  amountInReporting: 'amountInReporting',
  unrealizedFxGainLoss: 'unrealizedFxGainLoss',
  creditLimit: 'creditLimit',
  availableCredit: 'availableCredit',
  utilizationRate: 'utilizationRate',
  amortizationMethod: 'amortizationMethod',
  confidenceScore: 'confidenceScore',
  inceptionDate: 'inceptionDate',
  recognitionDate: 'recognitionDate',
  activationDate: 'activationDate',
  maturityDate: 'maturityDate',
  nextPaymentDate: 'nextPaymentDate',
  lastPaymentDate: 'lastPaymentDate',
  settledDate: 'settledDate',
  gracePeriodDays: 'gracePeriodDays',
  graceEndDate: 'graceEndDate',
  earlyRepaymentAllowed: 'earlyRepaymentAllowed',
  earlyRepaymentPenalty: 'earlyRepaymentPenalty',
  earlyRepaymentConditions: 'earlyRepaymentConditions',
  interestType: 'interestType',
  interestRate: 'interestRate',
  interestIndex: 'interestIndex',
  interestSpread: 'interestSpread',
  interestCompounding: 'interestCompounding',
  interestDayCount: 'interestDayCount',
  interestAccrualStart: 'interestAccrualStart',
  lastInterestAccrual: 'lastInterestAccrual',
  nextInterestAccrual: 'nextInterestAccrual',
  interestSchedule: 'interestSchedule',
  originationFee: 'originationFee',
  originationFeeRate: 'originationFeeRate',
  commitmentFee: 'commitmentFee',
  commitmentFeeRate: 'commitmentFeeRate',
  penaltiesAccrued: 'penaltiesAccrued',
  legalFeesAccrued: 'legalFeesAccrued',
  otherFeesAccrued: 'otherFeesAccrued',
  paymentFrequency: 'paymentFrequency',
  regularPaymentAmount: 'regularPaymentAmount',
  paymentSchedule: 'paymentSchedule',
  totalPaymentsExpected: 'totalPaymentsExpected',
  paymentsCompleted: 'paymentsCompleted',
  paymentsMissed: 'paymentsMissed',
  expectedCashImpact: 'expectedCashImpact',
  earliestCashImpact: 'earliestCashImpact',
  worstCaseCashImpact: 'worstCaseCashImpact',
  nextCashOutflow: 'nextCashOutflow',
  cashflowProbability: 'cashflowProbability',
  collateralDescription: 'collateralDescription',
  collateralValue: 'collateralValue',
  collateralCurrency: 'collateralCurrency',
  collateralType: 'collateralType',
  collateralValuationDate: 'collateralValuationDate',
  riskLevel: 'riskLevel',
  riskScore: 'riskScore',
  defaultProbability: 'defaultProbability',
  covenants: 'covenants',
  covenantBreaches: 'covenantBreaches',
  lastCovenantCheck: 'lastCovenantCheck',
  nextCovenantCheck: 'nextCovenantCheck',
  isInDefault: 'isInDefault',
  defaultDate: 'defaultDate',
  defaultReason: 'defaultReason',
  daysOverdue: 'daysOverdue',
  isDisputed: 'isDisputed',
  disputeReason: 'disputeReason',
  disputeAmount: 'disputeAmount',
  disputeOpenedAt: 'disputeOpenedAt',
  disputeResolvedAt: 'disputeResolvedAt',
  disputeResolution: 'disputeResolution',
  isRestructured: 'isRestructured',
  restructuredDate: 'restructuredDate',
  restructuredReason: 'restructuredReason',
  originalLiabilityId: 'originalLiabilityId',
  restructuredTerms: 'restructuredTerms',
  isWrittenOff: 'isWrittenOff',
  writeOffDate: 'writeOffDate',
  writeOffAmount: 'writeOffAmount',
  writeOffReason: 'writeOffReason',
  writeOffApprovedBy: 'writeOffApprovedBy',
  writeOffReasonCode: 'writeOffReasonCode',
  requiresApproval: 'requiresApproval',
  approvalThreshold: 'approvalThreshold',
  approvalStatus: 'approvalStatus',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  approvalChain: 'approvalChain',
  isHedged: 'isHedged',
  hedgeId: 'hedgeId',
  hedgePercentage: 'hedgePercentage',
  name: 'name',
  description: 'description',
  reference: 'reference',
  internalReference: 'internalReference',
  tags: 'tags',
  systemTags: 'systemTags',
  metadata: 'metadata',
  attachments: 'attachments',
  notes: 'notes',
  internalNotes: 'internalNotes',
  validationMode: 'validationMode',
  locale: 'locale',
  language: 'language',
  sourceType: 'sourceType',
  sourceId: 'sourceId',
  sourceModule: 'sourceModule',
  importBatchId: 'importBatchId',
  version: 'version',
  eventCount: 'eventCount',
  lastEventId: 'lastEventId',
  archivedAt: 'archivedAt',
  archivedBy: 'archivedBy',
  archiveReason: 'archiveReason',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilityScalarFieldEnum = (typeof LiabilityScalarFieldEnum)[keyof typeof LiabilityScalarFieldEnum]


export const LiabilityEventScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  liabilityId: 'liabilityId',
  eventType: 'eventType',
  timestamp: 'timestamp',
  effectiveDate: 'effectiveDate',
  actorId: 'actorId',
  actorName: 'actorName',
  actorType: 'actorType',
  payload: 'payload',
  previousState: 'previousState',
  previousEventId: 'previousEventId',
  contentHash: 'contentHash',
  explanation: 'explanation',
  ruleId: 'ruleId',
  ruleVersion: 'ruleVersion',
  metadata: 'metadata',
  isReversed: 'isReversed',
  reversedBy: 'reversedBy',
  reversalOf: 'reversalOf'
} as const

export type LiabilityEventScalarFieldEnum = (typeof LiabilityEventScalarFieldEnum)[keyof typeof LiabilityEventScalarFieldEnum]


export const LiabilityPaymentScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  paymentId: 'paymentId',
  amount: 'amount',
  principalAmount: 'principalAmount',
  interestAmount: 'interestAmount',
  feesAmount: 'feesAmount',
  penaltyAmount: 'penaltyAmount',
  currency: 'currency',
  fxRate: 'fxRate',
  amountInReporting: 'amountInReporting',
  scheduledDate: 'scheduledDate',
  dueDate: 'dueDate',
  paymentDate: 'paymentDate',
  executedAt: 'executedAt',
  status: 'status',
  requiresApproval: 'requiresApproval',
  approvalThreshold: 'approvalThreshold',
  approvalStatus: 'approvalStatus',
  approvalChain: 'approvalChain',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  executedBy: 'executedBy',
  paymentMethod: 'paymentMethod',
  bankReference: 'bankReference',
  transactionId: 'transactionId',
  failureReason: 'failureReason',
  failureCode: 'failureCode',
  retryCount: 'retryCount',
  nextRetryAt: 'nextRetryAt',
  isReversed: 'isReversed',
  reversedAt: 'reversedAt',
  reversedBy: 'reversedBy',
  reversalReason: 'reversalReason',
  reference: 'reference',
  description: 'description',
  notes: 'notes',
  isIntercompany: 'isIntercompany',
  counterpartyLegalEntityId: 'counterpartyLegalEntityId',
  nettingId: 'nettingId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilityPaymentScalarFieldEnum = (typeof LiabilityPaymentScalarFieldEnum)[keyof typeof LiabilityPaymentScalarFieldEnum]


export const LiabilitySettlementScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  settlementId: 'settlementId',
  settlementType: 'settlementType',
  amount: 'amount',
  principalSettled: 'principalSettled',
  interestSettled: 'interestSettled',
  feesSettled: 'feesSettled',
  penaltiesWaived: 'penaltiesWaived',
  currency: 'currency',
  fxRate: 'fxRate',
  fxGainLoss: 'fxGainLoss',
  outstandingBefore: 'outstandingBefore',
  outstandingAfter: 'outstandingAfter',
  settlementDate: 'settlementDate',
  effectiveDate: 'effectiveDate',
  settledBy: 'settledBy',
  approvedBy: 'approvedBy',
  paymentId: 'paymentId',
  reference: 'reference',
  notes: 'notes',
  isOffset: 'isOffset',
  offsetReceivableId: 'offsetReceivableId',
  nettingBatchId: 'nettingBatchId',
  createdAt: 'createdAt'
} as const

export type LiabilitySettlementScalarFieldEnum = (typeof LiabilitySettlementScalarFieldEnum)[keyof typeof LiabilitySettlementScalarFieldEnum]


export const LiabilityAccrualScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  accrualId: 'accrualId',
  accrualType: 'accrualType',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  principalBase: 'principalBase',
  rate: 'rate',
  dayCount: 'dayCount',
  dayCountBasis: 'dayCountBasis',
  amount: 'amount',
  currency: 'currency',
  amountInReporting: 'amountInReporting',
  fxRate: 'fxRate',
  status: 'status',
  postedAt: 'postedAt',
  postedBy: 'postedBy',
  journalEntryId: 'journalEntryId',
  isReversed: 'isReversed',
  reversedAt: 'reversedAt',
  reversedBy: 'reversedBy',
  explanation: 'explanation',
  calculationDetails: 'calculationDetails',
  createdAt: 'createdAt'
} as const

export type LiabilityAccrualScalarFieldEnum = (typeof LiabilityAccrualScalarFieldEnum)[keyof typeof LiabilityAccrualScalarFieldEnum]


export const LiabilityCovenantCheckScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  covenantName: 'covenantName',
  covenantType: 'covenantType',
  checkDate: 'checkDate',
  periodEnd: 'periodEnd',
  threshold: 'threshold',
  thresholdType: 'thresholdType',
  thresholdMin: 'thresholdMin',
  thresholdMax: 'thresholdMax',
  actualValue: 'actualValue',
  status: 'status',
  variance: 'variance',
  variancePercent: 'variancePercent',
  isBreached: 'isBreached',
  breachSeverity: 'breachSeverity',
  breachNotified: 'breachNotified',
  notifiedAt: 'notifiedAt',
  notifiedTo: 'notifiedTo',
  isWaived: 'isWaived',
  waiverApprovedBy: 'waiverApprovedBy',
  waiverApprovedAt: 'waiverApprovedAt',
  waiverReason: 'waiverReason',
  calculationDetails: 'calculationDetails',
  supportingDocuments: 'supportingDocuments',
  checkedBy: 'checkedBy',
  createdAt: 'createdAt'
} as const

export type LiabilityCovenantCheckScalarFieldEnum = (typeof LiabilityCovenantCheckScalarFieldEnum)[keyof typeof LiabilityCovenantCheckScalarFieldEnum]


export const LiabilityImportBatchScalarFieldEnum = {
  id: 'id',
  batchNumber: 'batchNumber',
  source: 'source',
  sourceIdentifier: 'sourceIdentifier',
  sourceHash: 'sourceHash',
  totalRecords: 'totalRecords',
  successCount: 'successCount',
  errorCount: 'errorCount',
  warningCount: 'warningCount',
  skippedCount: 'skippedCount',
  status: 'status',
  importMode: 'importMode',
  dateFrom: 'dateFrom',
  dateTo: 'dateTo',
  counterpartyFilter: 'counterpartyFilter',
  typeFilter: 'typeFilter',
  fieldMapping: 'fieldMapping',
  mappingTemplate: 'mappingTemplate',
  errors: 'errors',
  warnings: 'warnings',
  createdLiabilityIds: 'createdLiabilityIds',
  canRollback: 'canRollback',
  rolledBackAt: 'rolledBackAt',
  rolledBackBy: 'rolledBackBy',
  importedBy: 'importedBy',
  importedByName: 'importedByName',
  organizationId: 'organizationId',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type LiabilityImportBatchScalarFieldEnum = (typeof LiabilityImportBatchScalarFieldEnum)[keyof typeof LiabilityImportBatchScalarFieldEnum]


export const LiabilityAutomationRuleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  description: 'description',
  triggerType: 'triggerType',
  triggerConditions: 'triggerConditions',
  schedule: 'schedule',
  liabilityTypes: 'liabilityTypes',
  primaryClasses: 'primaryClasses',
  counterpartyTypes: 'counterpartyTypes',
  actionType: 'actionType',
  actionConfig: 'actionConfig',
  confidenceThreshold: 'confidenceThreshold',
  proposalThreshold: 'proposalThreshold',
  requiresApproval: 'requiresApproval',
  approverRoles: 'approverRoles',
  amountThreshold: 'amountThreshold',
  riskThreshold: 'riskThreshold',
  maturityDaysThreshold: 'maturityDaysThreshold',
  fallbackRuleId: 'fallbackRuleId',
  fallbackBehavior: 'fallbackBehavior',
  explanationTemplate: 'explanationTemplate',
  isActive: 'isActive',
  priority: 'priority',
  lastExecutedAt: 'lastExecutedAt',
  executionCount: 'executionCount',
  successCount: 'successCount',
  failureCount: 'failureCount',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilityAutomationRuleScalarFieldEnum = (typeof LiabilityAutomationRuleScalarFieldEnum)[keyof typeof LiabilityAutomationRuleScalarFieldEnum]


export const LiabilityExceptionScalarFieldEnum = {
  id: 'id',
  liabilityId: 'liabilityId',
  sourceObjectId: 'sourceObjectId',
  sourceObjectType: 'sourceObjectType',
  sourceModule: 'sourceModule',
  exceptionType: 'exceptionType',
  exceptionCode: 'exceptionCode',
  exceptionMessage: 'exceptionMessage',
  exceptionDetails: 'exceptionDetails',
  validationMode: 'validationMode',
  validationErrors: 'validationErrors',
  confidenceScore: 'confidenceScore',
  assignedTo: 'assignedTo',
  assignedToName: 'assignedToName',
  assignedAt: 'assignedAt',
  slaDeadline: 'slaDeadline',
  isOverdue: 'isOverdue',
  escalationLevel: 'escalationLevel',
  escalatedTo: 'escalatedTo',
  escalatedAt: 'escalatedAt',
  status: 'status',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  resolution: 'resolution',
  resolutionAction: 'resolutionAction',
  retryCount: 'retryCount',
  maxRetries: 'maxRetries',
  lastRetryAt: 'lastRetryAt',
  nextRetryAt: 'nextRetryAt',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilityExceptionScalarFieldEnum = (typeof LiabilityExceptionScalarFieldEnum)[keyof typeof LiabilityExceptionScalarFieldEnum]


export const LiabilitySavedViewScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  filters: 'filters',
  columns: 'columns',
  sortBy: 'sortBy',
  sortOrder: 'sortOrder',
  groupBy: 'groupBy',
  includeAggregations: 'includeAggregations',
  aggregationFields: 'aggregationFields',
  isPublic: 'isPublic',
  sharedWith: 'sharedWith',
  isScheduled: 'isScheduled',
  scheduleFrequency: 'scheduleFrequency',
  scheduleCron: 'scheduleCron',
  deliveryMethod: 'deliveryMethod',
  deliveryTarget: 'deliveryTarget',
  lastDeliveredAt: 'lastDeliveredAt',
  defaultExportFormat: 'defaultExportFormat',
  createdBy: 'createdBy',
  createdByName: 'createdByName',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiabilitySavedViewScalarFieldEnum = (typeof LiabilitySavedViewScalarFieldEnum)[keyof typeof LiabilitySavedViewScalarFieldEnum]


export const InventoryItemScalarFieldEnum = {
  id: 'id',
  type: 'type',
  status: 'status',
  sku: 'sku',
  name: 'name',
  description: 'description',
  barcode: 'barcode',
  category: 'category',
  subcategory: 'subcategory',
  quantityOnHand: 'quantityOnHand',
  quantityReserved: 'quantityReserved',
  quantityAvailable: 'quantityAvailable',
  quantityOnOrder: 'quantityOnOrder',
  unitOfMeasure: 'unitOfMeasure',
  minimumStock: 'minimumStock',
  maximumStock: 'maximumStock',
  reorderPoint: 'reorderPoint',
  reorderQuantity: 'reorderQuantity',
  currency: 'currency',
  unitCost: 'unitCost',
  averageCost: 'averageCost',
  lastPurchaseCost: 'lastPurchaseCost',
  sellingPrice: 'sellingPrice',
  totalValue: 'totalValue',
  costingMethod: 'costingMethod',
  warehouseId: 'warehouseId',
  warehouseName: 'warehouseName',
  location: 'location',
  zone: 'zone',
  ownershipType: 'ownershipType',
  supplierId: 'supplierId',
  supplierName: 'supplierName',
  isSerialTracked: 'isSerialTracked',
  isBatchTracked: 'isBatchTracked',
  isExpiryTracked: 'isExpiryTracked',
  leadTimeDays: 'leadTimeDays',
  weight: 'weight',
  weightUnit: 'weightUnit',
  length: 'length',
  width: 'width',
  height: 'height',
  dimensionUnit: 'dimensionUnit',
  tags: 'tags',
  notes: 'notes',
  imageUrl: 'imageUrl',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


export const InventoryMovementScalarFieldEnum = {
  id: 'id',
  type: 'type',
  quantity: 'quantity',
  previousQuantity: 'previousQuantity',
  newQuantity: 'newQuantity',
  unitCost: 'unitCost',
  totalCost: 'totalCost',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  referenceNumber: 'referenceNumber',
  fromWarehouseId: 'fromWarehouseId',
  fromLocation: 'fromLocation',
  toWarehouseId: 'toWarehouseId',
  toLocation: 'toLocation',
  batchId: 'batchId',
  serialNumber: 'serialNumber',
  reason: 'reason',
  notes: 'notes',
  performedBy: 'performedBy',
  movementDate: 'movementDate',
  inventoryItemId: 'inventoryItemId',
  createdAt: 'createdAt'
} as const

export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


export const InventoryBatchScalarFieldEnum = {
  id: 'id',
  batchNumber: 'batchNumber',
  lotNumber: 'lotNumber',
  initialQuantity: 'initialQuantity',
  currentQuantity: 'currentQuantity',
  reservedQuantity: 'reservedQuantity',
  unitCost: 'unitCost',
  manufacturingDate: 'manufacturingDate',
  expiryDate: 'expiryDate',
  receivedDate: 'receivedDate',
  status: 'status',
  supplierId: 'supplierId',
  supplierBatchRef: 'supplierBatchRef',
  qualityStatus: 'qualityStatus',
  qualityNotes: 'qualityNotes',
  warehouseId: 'warehouseId',
  location: 'location',
  inventoryItemId: 'inventoryItemId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InventoryBatchScalarFieldEnum = (typeof InventoryBatchScalarFieldEnum)[keyof typeof InventoryBatchScalarFieldEnum]


export const ReceivableScalarFieldEnum = {
  id: 'id',
  originType: 'originType',
  originReferenceId: 'originReferenceId',
  creditorEntityId: 'creditorEntityId',
  debtorId: 'debtorId',
  debtorName: 'debtorName',
  debtorEmail: 'debtorEmail',
  debtorPhone: 'debtorPhone',
  debtorAddress: 'debtorAddress',
  currency: 'currency',
  originalAmount: 'originalAmount',
  outstandingAmount: 'outstandingAmount',
  paidAmount: 'paidAmount',
  disputedAmount: 'disputedAmount',
  writtenOffAmount: 'writtenOffAmount',
  issueDate: 'issueDate',
  dueDate: 'dueDate',
  expectedPaymentDate: 'expectedPaymentDate',
  lastActivityDate: 'lastActivityDate',
  status: 'status',
  riskLevel: 'riskLevel',
  daysOutstanding: 'daysOutstanding',
  agingBucket: 'agingBucket',
  isDisputed: 'isDisputed',
  disputeReason: 'disputeReason',
  disputeOpenedAt: 'disputeOpenedAt',
  disputeResolvedAt: 'disputeResolvedAt',
  collectionStage: 'collectionStage',
  collectionStartedAt: 'collectionStartedAt',
  collectionAgency: 'collectionAgency',
  autoRemindersEnabled: 'autoRemindersEnabled',
  nextReminderDate: 'nextReminderDate',
  reminderCount: 'reminderCount',
  reference: 'reference',
  description: 'description',
  notes: 'notes',
  internalNotes: 'internalNotes',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReceivableScalarFieldEnum = (typeof ReceivableScalarFieldEnum)[keyof typeof ReceivableScalarFieldEnum]


export const ReceivablePaymentScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  currency: 'currency',
  appliedAt: 'appliedAt',
  type: 'type',
  reference: 'reference',
  transactionId: 'transactionId',
  notes: 'notes',
  appliedBy: 'appliedBy',
  receivableId: 'receivableId',
  createdAt: 'createdAt'
} as const

export type ReceivablePaymentScalarFieldEnum = (typeof ReceivablePaymentScalarFieldEnum)[keyof typeof ReceivablePaymentScalarFieldEnum]


export const ReceivableEventScalarFieldEnum = {
  id: 'id',
  type: 'type',
  description: 'description',
  previousValue: 'previousValue',
  newValue: 'newValue',
  amount: 'amount',
  performedBy: 'performedBy',
  notes: 'notes',
  metadata: 'metadata',
  receivableId: 'receivableId',
  createdAt: 'createdAt'
} as const

export type ReceivableEventScalarFieldEnum = (typeof ReceivableEventScalarFieldEnum)[keyof typeof ReceivableEventScalarFieldEnum]


export const TreasuryAccountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  accountNumber: 'accountNumber',
  type: 'type',
  bankName: 'bankName',
  bankCode: 'bankCode',
  iban: 'iban',
  cashClassification: 'cashClassification',
  currency: 'currency',
  currentBalance: 'currentBalance',
  availableBalance: 'availableBalance',
  pendingInflows: 'pendingInflows',
  pendingOutflows: 'pendingOutflows',
  minimumBalance: 'minimumBalance',
  targetBalance: 'targetBalance',
  status: 'status',
  isMainAccount: 'isMainAccount',
  participatesInPooling: 'participatesInPooling',
  poolingRole: 'poolingRole',
  masterAccountId: 'masterAccountId',
  entityId: 'entityId',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryAccountScalarFieldEnum = (typeof TreasuryAccountScalarFieldEnum)[keyof typeof TreasuryAccountScalarFieldEnum]


export const CapitalBucketScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  currency: 'currency',
  targetAmount: 'targetAmount',
  currentAmount: 'currentAmount',
  minimumAmount: 'minimumAmount',
  fundingStatus: 'fundingStatus',
  fundingPercent: 'fundingPercent',
  priority: 'priority',
  isRequired: 'isRequired',
  autoFund: 'autoFund',
  fundingSourceAccountId: 'fundingSourceAccountId',
  timeHorizon: 'timeHorizon',
  targetDate: 'targetDate',
  notes: 'notes',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapitalBucketScalarFieldEnum = (typeof CapitalBucketScalarFieldEnum)[keyof typeof CapitalBucketScalarFieldEnum]


export const CreditFacilityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  status: 'status',
  lenderName: 'lenderName',
  lenderId: 'lenderId',
  currency: 'currency',
  facilityLimit: 'facilityLimit',
  drawnAmount: 'drawnAmount',
  availableAmount: 'availableAmount',
  pendingDrawdowns: 'pendingDrawdowns',
  utilizationRate: 'utilizationRate',
  utilizationAlert: 'utilizationAlert',
  interestRate: 'interestRate',
  interestType: 'interestType',
  spreadBps: 'spreadBps',
  commitmentFeeBps: 'commitmentFeeBps',
  arrangementFee: 'arrangementFee',
  startDate: 'startDate',
  maturityDate: 'maturityDate',
  nextReviewDate: 'nextReviewDate',
  covenants: 'covenants',
  covenantStatus: 'covenantStatus',
  isSecured: 'isSecured',
  securityDescription: 'securityDescription',
  reference: 'reference',
  notes: 'notes',
  documents: 'documents',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CreditFacilityScalarFieldEnum = (typeof CreditFacilityScalarFieldEnum)[keyof typeof CreditFacilityScalarFieldEnum]


export const FacilityDrawdownScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  currency: 'currency',
  drawdownDate: 'drawdownDate',
  repaidAmount: 'repaidAmount',
  outstandingAmount: 'outstandingAmount',
  status: 'status',
  interestRate: 'interestRate',
  accruedInterest: 'accruedInterest',
  maturityDate: 'maturityDate',
  reference: 'reference',
  purpose: 'purpose',
  notes: 'notes',
  facilityId: 'facilityId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityDrawdownScalarFieldEnum = (typeof FacilityDrawdownScalarFieldEnum)[keyof typeof FacilityDrawdownScalarFieldEnum]


export const TreasuryDecisionScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  status: 'status',
  priority: 'priority',
  currency: 'currency',
  amount: 'amount',
  riskDelta: 'riskDelta',
  requiresApproval: 'requiresApproval',
  approvalThreshold: 'approvalThreshold',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectedBy: 'rejectedBy',
  rejectedAt: 'rejectedAt',
  rejectionReason: 'rejectionReason',
  executionMode: 'executionMode',
  scheduledDate: 'scheduledDate',
  executedAt: 'executedAt',
  executedBy: 'executedBy',
  executionNotes: 'executionNotes',
  expiresAt: 'expiresAt',
  sourceAccountId: 'sourceAccountId',
  targetAccountId: 'targetAccountId',
  facilityId: 'facilityId',
  bucketId: 'bucketId',
  alternatives: 'alternatives',
  notes: 'notes',
  metadata: 'metadata',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryDecisionScalarFieldEnum = (typeof TreasuryDecisionScalarFieldEnum)[keyof typeof TreasuryDecisionScalarFieldEnum]


export const TreasuryScenarioScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  isActive: 'isActive',
  isBaseline: 'isBaseline',
  assumptions: 'assumptions',
  horizonDays: 'horizonDays',
  startDate: 'startDate',
  endDate: 'endDate',
  results: 'results',
  cashFlowProjection: 'cashFlowProjection',
  minimumCashDate: 'minimumCashDate',
  minimumCashAmount: 'minimumCashAmount',
  endingCashAmount: 'endingCashAmount',
  probabilityWeight: 'probabilityWeight',
  riskScore: 'riskScore',
  createdBy: 'createdBy',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TreasuryScenarioScalarFieldEnum = (typeof TreasuryScenarioScalarFieldEnum)[keyof typeof TreasuryScenarioScalarFieldEnum]


export const TreasuryCashMovementScalarFieldEnum = {
  id: 'id',
  type: 'type',
  category: 'category',
  amount: 'amount',
  currency: 'currency',
  balanceBefore: 'balanceBefore',
  balanceAfter: 'balanceAfter',
  movementDate: 'movementDate',
  valueDate: 'valueDate',
  description: 'description',
  reference: 'reference',
  counterparty: 'counterparty',
  status: 'status',
  transactionId: 'transactionId',
  decisionId: 'decisionId',
  accountId: 'accountId',
  createdAt: 'createdAt'
} as const

export type TreasuryCashMovementScalarFieldEnum = (typeof TreasuryCashMovementScalarFieldEnum)[keyof typeof TreasuryCashMovementScalarFieldEnum]


export const NettingOpportunityScalarFieldEnum = {
  id: 'id',
  entityAId: 'entityAId',
  entityAName: 'entityAName',
  entityBId: 'entityBId',
  entityBName: 'entityBName',
  currency: 'currency',
  amountAToB: 'amountAToB',
  amountBToA: 'amountBToA',
  netAmount: 'netAmount',
  netDirection: 'netDirection',
  grossAmount: 'grossAmount',
  savingsAmount: 'savingsAmount',
  savingsPercent: 'savingsPercent',
  status: 'status',
  executedAt: 'executedAt',
  executedBy: 'executedBy',
  validUntil: 'validUntil',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NettingOpportunityScalarFieldEnum = (typeof NettingOpportunityScalarFieldEnum)[keyof typeof NettingOpportunityScalarFieldEnum]


export const AssetScalarFieldEnum = {
  id: 'id',
  assetNumber: 'assetNumber',
  name: 'name',
  description: 'description',
  category: 'category',
  subcategory: 'subcategory',
  assetClass: 'assetClass',
  status: 'status',
  acquisitionDate: 'acquisitionDate',
  acquisitionType: 'acquisitionType',
  acquisitionCost: 'acquisitionCost',
  currency: 'currency',
  vendorId: 'vendorId',
  vendorName: 'vendorName',
  purchaseOrderRef: 'purchaseOrderRef',
  invoiceRef: 'invoiceRef',
  currentBookValue: 'currentBookValue',
  fairValue: 'fairValue',
  residualValue: 'residualValue',
  isDepreciable: 'isDepreciable',
  depreciationMethod: 'depreciationMethod',
  usefulLifeMonths: 'usefulLifeMonths',
  usefulLifeUnits: 'usefulLifeUnits',
  depreciationRate: 'depreciationRate',
  accumulatedDepreciation: 'accumulatedDepreciation',
  accumulatedImpairment: 'accumulatedImpairment',
  depreciationStartDate: 'depreciationStartDate',
  lastDepreciationDate: 'lastDepreciationDate',
  nextDepreciationDate: 'nextDepreciationDate',
  monthlyDepreciation: 'monthlyDepreciation',
  locationId: 'locationId',
  locationName: 'locationName',
  locationAddress: 'locationAddress',
  costCenterId: 'costCenterId',
  costCenterName: 'costCenterName',
  responsibleParty: 'responsibleParty',
  responsiblePartyId: 'responsiblePartyId',
  entityId: 'entityId',
  entityName: 'entityName',
  serialNumber: 'serialNumber',
  modelNumber: 'modelNumber',
  manufacturer: 'manufacturer',
  barcode: 'barcode',
  quantity: 'quantity',
  unitOfMeasure: 'unitOfMeasure',
  isInsured: 'isInsured',
  insurancePolicy: 'insurancePolicy',
  insuredValue: 'insuredValue',
  insuranceExpiry: 'insuranceExpiry',
  warrantyExpiry: 'warrantyExpiry',
  warrantyTerms: 'warrantyTerms',
  requiresMaintenance: 'requiresMaintenance',
  maintenanceSchedule: 'maintenanceSchedule',
  lastMaintenanceDate: 'lastMaintenanceDate',
  nextMaintenanceDate: 'nextMaintenanceDate',
  plannedDisposalDate: 'plannedDisposalDate',
  disposalMethod: 'disposalMethod',
  lastRevaluationDate: 'lastRevaluationDate',
  revaluationSurplus: 'revaluationSurplus',
  isComponent: 'isComponent',
  parentAssetId: 'parentAssetId',
  tags: 'tags',
  notes: 'notes',
  attachments: 'attachments',
  customFields: 'customFields',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


export const AssetDepreciationScalarFieldEnum = {
  id: 'id',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  fiscalYear: 'fiscalYear',
  fiscalPeriod: 'fiscalPeriod',
  depreciationAmount: 'depreciationAmount',
  accumulatedDepreciation: 'accumulatedDepreciation',
  openingBookValue: 'openingBookValue',
  closingBookValue: 'closingBookValue',
  method: 'method',
  rate: 'rate',
  status: 'status',
  journalEntryId: 'journalEntryId',
  postedAt: 'postedAt',
  postedBy: 'postedBy',
  bookType: 'bookType',
  notes: 'notes',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetDepreciationScalarFieldEnum = (typeof AssetDepreciationScalarFieldEnum)[keyof typeof AssetDepreciationScalarFieldEnum]


export const AssetEventScalarFieldEnum = {
  id: 'id',
  type: 'type',
  description: 'description',
  amount: 'amount',
  previousValue: 'previousValue',
  newValue: 'newValue',
  eventDate: 'eventDate',
  effectiveDate: 'effectiveDate',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  requiresApproval: 'requiresApproval',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  performedBy: 'performedBy',
  notes: 'notes',
  metadata: 'metadata',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetEventScalarFieldEnum = (typeof AssetEventScalarFieldEnum)[keyof typeof AssetEventScalarFieldEnum]


export const AssetTransferScalarFieldEnum = {
  id: 'id',
  transferDate: 'transferDate',
  effectiveDate: 'effectiveDate',
  transferType: 'transferType',
  fromEntityId: 'fromEntityId',
  fromEntityName: 'fromEntityName',
  fromCostCenterId: 'fromCostCenterId',
  fromCostCenterName: 'fromCostCenterName',
  fromLocationId: 'fromLocationId',
  fromLocationName: 'fromLocationName',
  fromResponsibleParty: 'fromResponsibleParty',
  toEntityId: 'toEntityId',
  toEntityName: 'toEntityName',
  toCostCenterId: 'toCostCenterId',
  toCostCenterName: 'toCostCenterName',
  toLocationId: 'toLocationId',
  toLocationName: 'toLocationName',
  toResponsibleParty: 'toResponsibleParty',
  bookValueAtTransfer: 'bookValueAtTransfer',
  accumulatedDepAtTransfer: 'accumulatedDepAtTransfer',
  status: 'status',
  requestedBy: 'requestedBy',
  requestedAt: 'requestedAt',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  reason: 'reason',
  notes: 'notes',
  assetId: 'assetId',
  createdAt: 'createdAt'
} as const

export type AssetTransferScalarFieldEnum = (typeof AssetTransferScalarFieldEnum)[keyof typeof AssetTransferScalarFieldEnum]


export const AssetDisposalScalarFieldEnum = {
  id: 'id',
  disposalDate: 'disposalDate',
  disposalType: 'disposalType',
  carryingAmount: 'carryingAmount',
  accumulatedDepreciation: 'accumulatedDepreciation',
  salePrice: 'salePrice',
  saleCurrency: 'saleCurrency',
  buyerName: 'buyerName',
  buyerReference: 'buyerReference',
  invoiceId: 'invoiceId',
  gainOrLoss: 'gainOrLoss',
  isGain: 'isGain',
  disposalCosts: 'disposalCosts',
  taxAmount: 'taxAmount',
  taxTreatment: 'taxTreatment',
  status: 'status',
  reason: 'reason',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  notes: 'notes',
  attachments: 'attachments',
  assetId: 'assetId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssetDisposalScalarFieldEnum = (typeof AssetDisposalScalarFieldEnum)[keyof typeof AssetDisposalScalarFieldEnum]


export const CapExBudgetScalarFieldEnum = {
  id: 'id',
  name: 'name',
  fiscalYear: 'fiscalYear',
  description: 'description',
  entityId: 'entityId',
  entityName: 'entityName',
  projectId: 'projectId',
  projectName: 'projectName',
  costCenterId: 'costCenterId',
  currency: 'currency',
  budgetAmount: 'budgetAmount',
  committedAmount: 'committedAmount',
  spentAmount: 'spentAmount',
  remainingAmount: 'remainingAmount',
  status: 'status',
  utilizationPercent: 'utilizationPercent',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapExBudgetScalarFieldEnum = (typeof CapExBudgetScalarFieldEnum)[keyof typeof CapExBudgetScalarFieldEnum]


export const CapExItemScalarFieldEnum = {
  id: 'id',
  description: 'description',
  category: 'category',
  estimatedAmount: 'estimatedAmount',
  actualAmount: 'actualAmount',
  variance: 'variance',
  status: 'status',
  classification: 'classification',
  classificationReason: 'classificationReason',
  assetId: 'assetId',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  plannedDate: 'plannedDate',
  actualDate: 'actualDate',
  notes: 'notes',
  budgetId: 'budgetId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CapExItemScalarFieldEnum = (typeof CapExItemScalarFieldEnum)[keyof typeof CapExItemScalarFieldEnum]


export const CostCenterScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  parentId: 'parentId',
  level: 'level',
  path: 'path',
  managerId: 'managerId',
  managerName: 'managerName',
  annualBudget: 'annualBudget',
  budgetSpent: 'budgetSpent',
  budgetRemaining: 'budgetRemaining',
  budgetUtilization: 'budgetUtilization',
  currency: 'currency',
  allocationMethod: 'allocationMethod',
  allocationBasis: 'allocationBasis',
  isActive: 'isActive',
  effectiveFrom: 'effectiveFrom',
  effectiveTo: 'effectiveTo',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostCenterScalarFieldEnum = (typeof CostCenterScalarFieldEnum)[keyof typeof CostCenterScalarFieldEnum]


export const ProjectScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  type: 'type',
  status: 'status',
  priority: 'priority',
  ownerId: 'ownerId',
  ownerName: 'ownerName',
  costCenterId: 'costCenterId',
  costCenterCode: 'costCenterCode',
  departmentId: 'departmentId',
  clientId: 'clientId',
  clientName: 'clientName',
  plannedStartDate: 'plannedStartDate',
  plannedEndDate: 'plannedEndDate',
  actualStartDate: 'actualStartDate',
  actualEndDate: 'actualEndDate',
  budgetType: 'budgetType',
  budgetAmount: 'budgetAmount',
  budgetSpent: 'budgetSpent',
  budgetRemaining: 'budgetRemaining',
  budgetVariance: 'budgetVariance',
  budgetUtilization: 'budgetUtilization',
  currency: 'currency',
  contractValue: 'contractValue',
  billedAmount: 'billedAmount',
  collectedAmount: 'collectedAmount',
  unbilledAmount: 'unbilledAmount',
  totalRevenue: 'totalRevenue',
  totalCosts: 'totalCosts',
  grossProfit: 'grossProfit',
  grossMargin: 'grossMargin',
  netProfit: 'netProfit',
  netMargin: 'netMargin',
  allocatedHours: 'allocatedHours',
  actualHours: 'actualHours',
  remainingHours: 'remainingHours',
  hourlyRate: 'hourlyRate',
  percentComplete: 'percentComplete',
  milestoneCount: 'milestoneCount',
  milestonesCompleted: 'milestonesCompleted',
  isBillable: 'isBillable',
  billingRate: 'billingRate',
  billingMethod: 'billingMethod',
  tags: 'tags',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const ProjectMilestoneScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  plannedDate: 'plannedDate',
  actualDate: 'actualDate',
  status: 'status',
  percentComplete: 'percentComplete',
  isBillable: 'isBillable',
  billingAmount: 'billingAmount',
  billedAt: 'billedAt',
  dependsOn: 'dependsOn',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectMilestoneScalarFieldEnum = (typeof ProjectMilestoneScalarFieldEnum)[keyof typeof ProjectMilestoneScalarFieldEnum]


export const TimeEntryScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  userName: 'userName',
  projectId: 'projectId',
  projectCode: 'projectCode',
  taskId: 'taskId',
  taskName: 'taskName',
  costCenterId: 'costCenterId',
  date: 'date',
  hours: 'hours',
  startTime: 'startTime',
  endTime: 'endTime',
  description: 'description',
  category: 'category',
  isBillable: 'isBillable',
  hourlyRate: 'hourlyRate',
  billableAmount: 'billableAmount',
  costRate: 'costRate',
  costAmount: 'costAmount',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectionReason: 'rejectionReason',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


export const InternalChargebackScalarFieldEnum = {
  id: 'id',
  chargebackNumber: 'chargebackNumber',
  fromCostCenterId: 'fromCostCenterId',
  fromCostCenterCode: 'fromCostCenterCode',
  toCostCenterId: 'toCostCenterId',
  toCostCenterCode: 'toCostCenterCode',
  projectId: 'projectId',
  projectCode: 'projectCode',
  date: 'date',
  description: 'description',
  category: 'category',
  amount: 'amount',
  currency: 'currency',
  allocationMethod: 'allocationMethod',
  allocationBasis: 'allocationBasis',
  quantity: 'quantity',
  unitRate: 'unitRate',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectionReason: 'rejectionReason',
  invoiceId: 'invoiceId',
  journalEntryId: 'journalEntryId',
  notes: 'notes',
  createdBy: 'createdBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InternalChargebackScalarFieldEnum = (typeof InternalChargebackScalarFieldEnum)[keyof typeof InternalChargebackScalarFieldEnum]


export const AccountingPeriodScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  type: 'type',
  startDate: 'startDate',
  endDate: 'endDate',
  fiscalYear: 'fiscalYear',
  fiscalQuarter: 'fiscalQuarter',
  fiscalMonth: 'fiscalMonth',
  status: 'status',
  closedAt: 'closedAt',
  closedBy: 'closedBy',
  reopenedAt: 'reopenedAt',
  reopenedBy: 'reopenedBy',
  reopenReason: 'reopenReason',
  checklistTotal: 'checklistTotal',
  checklistCompleted: 'checklistCompleted',
  checklistProgress: 'checklistProgress',
  hasUnreconciledItems: 'hasUnreconciledItems',
  hasPendingTransactions: 'hasPendingTransactions',
  hasMissingDocuments: 'hasMissingDocuments',
  hasUnapprovedAdjustments: 'hasUnapprovedAdjustments',
  totalRevenue: 'totalRevenue',
  totalExpenses: 'totalExpenses',
  netIncome: 'netIncome',
  totalAssets: 'totalAssets',
  totalLiabilities: 'totalLiabilities',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountingPeriodScalarFieldEnum = (typeof AccountingPeriodScalarFieldEnum)[keyof typeof AccountingPeriodScalarFieldEnum]


export const CloseChecklistItemScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  name: 'name',
  description: 'description',
  category: 'category',
  orderIndex: 'orderIndex',
  status: 'status',
  completedAt: 'completedAt',
  completedBy: 'completedBy',
  isRequired: 'isRequired',
  isCritical: 'isCritical',
  dependsOn: 'dependsOn',
  isAutomated: 'isAutomated',
  automationRule: 'automationRule',
  lastAutoCheck: 'lastAutoCheck',
  autoCheckResult: 'autoCheckResult',
  attachments: 'attachments',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CloseChecklistItemScalarFieldEnum = (typeof CloseChecklistItemScalarFieldEnum)[keyof typeof CloseChecklistItemScalarFieldEnum]


export const PeriodMissingItemScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  type: 'type',
  severity: 'severity',
  title: 'title',
  description: 'description',
  reference: 'reference',
  relatedEntityType: 'relatedEntityType',
  relatedEntityId: 'relatedEntityId',
  assignedTo: 'assignedTo',
  assignedToName: 'assignedToName',
  dueDate: 'dueDate',
  status: 'status',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  resolution: 'resolution',
  waivedReason: 'waivedReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PeriodMissingItemScalarFieldEnum = (typeof PeriodMissingItemScalarFieldEnum)[keyof typeof PeriodMissingItemScalarFieldEnum]


export const PeriodAdjustmentScalarFieldEnum = {
  id: 'id',
  adjustmentNumber: 'adjustmentNumber',
  periodId: 'periodId',
  type: 'type',
  status: 'status',
  description: 'description',
  reason: 'reason',
  debitAccountId: 'debitAccountId',
  debitAccountName: 'debitAccountName',
  creditAccountId: 'creditAccountId',
  creditAccountName: 'creditAccountName',
  amount: 'amount',
  currency: 'currency',
  effectiveDate: 'effectiveDate',
  isReversing: 'isReversing',
  reversalDate: 'reversalDate',
  reversalPeriodId: 'reversalPeriodId',
  originalAdjustmentId: 'originalAdjustmentId',
  requestedBy: 'requestedBy',
  requestedByName: 'requestedByName',
  approvedBy: 'approvedBy',
  approvedByName: 'approvedByName',
  approvedAt: 'approvedAt',
  rejectedBy: 'rejectedBy',
  rejectionReason: 'rejectionReason',
  postedAt: 'postedAt',
  journalEntryId: 'journalEntryId',
  supportingDocuments: 'supportingDocuments',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PeriodAdjustmentScalarFieldEnum = (typeof PeriodAdjustmentScalarFieldEnum)[keyof typeof PeriodAdjustmentScalarFieldEnum]


export const PeriodAuditEntryScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  action: 'action',
  description: 'description',
  userId: 'userId',
  userName: 'userName',
  previousStatus: 'previousStatus',
  newStatus: 'newStatus',
  metadata: 'metadata',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  createdAt: 'createdAt'
} as const

export type PeriodAuditEntryScalarFieldEnum = (typeof PeriodAuditEntryScalarFieldEnum)[keyof typeof PeriodAuditEntryScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  customerNumber: 'customerNumber',
  name: 'name',
  legalName: 'legalName',
  type: 'type',
  status: 'status',
  industry: 'industry',
  email: 'email',
  phone: 'phone',
  website: 'website',
  address: 'address',
  taxId: 'taxId',
  vatNumber: 'vatNumber',
  registrationNumber: 'registrationNumber',
  classification: 'classification',
  employeeCount: 'employeeCount',
  annualRevenue: 'annualRevenue',
  accountManagerId: 'accountManagerId',
  accountManagerName: 'accountManagerName',
  segment: 'segment',
  tags: 'tags',
  creditLimit: 'creditLimit',
  creditUsed: 'creditUsed',
  creditAvailable: 'creditAvailable',
  creditStatus: 'creditStatus',
  paymentTerms: 'paymentTerms',
  paymentBehavior: 'paymentBehavior',
  averageDaysToPayment: 'averageDaysToPayment',
  onTimePaymentRate: 'onTimePaymentRate',
  latePaymentCount: 'latePaymentCount',
  riskLevel: 'riskLevel',
  riskScore: 'riskScore',
  totalRevenue: 'totalRevenue',
  totalOrders: 'totalOrders',
  averageOrderValue: 'averageOrderValue',
  outstandingBalance: 'outstandingBalance',
  overdueAmount: 'overdueAmount',
  currency: 'currency',
  customerSince: 'customerSince',
  lastActivityDate: 'lastActivityDate',
  lastPurchaseDate: 'lastPurchaseDate',
  lastOrderDate: 'lastOrderDate',
  lastPaymentDate: 'lastPaymentDate',
  lastContactDate: 'lastContactDate',
  preferredPaymentMethod: 'preferredPaymentMethod',
  preferredLanguage: 'preferredLanguage',
  invoiceDelivery: 'invoiceDelivery',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const CustomerContactScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  name: 'name',
  title: 'title',
  email: 'email',
  phone: 'phone',
  isPrimary: 'isPrimary',
  role: 'role',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerContactScalarFieldEnum = (typeof CustomerContactScalarFieldEnum)[keyof typeof CustomerContactScalarFieldEnum]


export const CustomerPaymentScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  invoiceId: 'invoiceId',
  invoiceNumber: 'invoiceNumber',
  amount: 'amount',
  currency: 'currency',
  invoiceDate: 'invoiceDate',
  dueDate: 'dueDate',
  paymentDate: 'paymentDate',
  status: 'status',
  daysToPayment: 'daysToPayment',
  daysOverdue: 'daysOverdue',
  paymentMethod: 'paymentMethod',
  referenceNumber: 'referenceNumber',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type CustomerPaymentScalarFieldEnum = (typeof CustomerPaymentScalarFieldEnum)[keyof typeof CustomerPaymentScalarFieldEnum]


export const CustomerCreditEventScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  type: 'type',
  previousValue: 'previousValue',
  newValue: 'newValue',
  reason: 'reason',
  changedBy: 'changedBy',
  changedByName: 'changedByName',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type CustomerCreditEventScalarFieldEnum = (typeof CustomerCreditEventScalarFieldEnum)[keyof typeof CustomerCreditEventScalarFieldEnum]


export const CustomerRevenueScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  period: 'period',
  periodType: 'periodType',
  revenue: 'revenue',
  cost: 'cost',
  profit: 'profit',
  margin: 'margin',
  productRevenue: 'productRevenue',
  serviceRevenue: 'serviceRevenue',
  otherRevenue: 'otherRevenue',
  orderCount: 'orderCount',
  averageOrderValue: 'averageOrderValue',
  createdAt: 'createdAt'
} as const

export type CustomerRevenueScalarFieldEnum = (typeof CustomerRevenueScalarFieldEnum)[keyof typeof CustomerRevenueScalarFieldEnum]


export const CustomerRiskIndicatorScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  category: 'category',
  indicator: 'indicator',
  description: 'description',
  severity: 'severity',
  score: 'score',
  status: 'status',
  detectedAt: 'detectedAt',
  resolvedAt: 'resolvedAt',
  recommendedAction: 'recommendedAction',
  actionTaken: 'actionTaken',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerRiskIndicatorScalarFieldEnum = (typeof CustomerRiskIndicatorScalarFieldEnum)[keyof typeof CustomerRiskIndicatorScalarFieldEnum]


export const SupplierScalarFieldEnum = {
  id: 'id',
  supplierNumber: 'supplierNumber',
  name: 'name',
  legalName: 'legalName',
  status: 'status',
  category: 'category',
  email: 'email',
  phone: 'phone',
  website: 'website',
  address: 'address',
  taxId: 'taxId',
  registrationNumber: 'registrationNumber',
  founded: 'founded',
  employeeCount: 'employeeCount',
  accountManagerId: 'accountManagerId',
  accountManagerName: 'accountManagerName',
  tags: 'tags',
  supplierSince: 'supplierSince',
  lastOrderDate: 'lastOrderDate',
  lastPaymentDate: 'lastPaymentDate',
  contractExpiryDate: 'contractExpiryDate',
  totalSpend: 'totalSpend',
  totalOrders: 'totalOrders',
  averageOrderValue: 'averageOrderValue',
  outstandingBalance: 'outstandingBalance',
  currency: 'currency',
  paymentTerms: 'paymentTerms',
  preferredPaymentMethod: 'preferredPaymentMethod',
  earlyPaymentDiscount: 'earlyPaymentDiscount',
  bankDetails: 'bankDetails',
  reliabilityRating: 'reliabilityRating',
  reliabilityScore: 'reliabilityScore',
  onTimeDeliveryRate: 'onTimeDeliveryRate',
  qualityScore: 'qualityScore',
  defectRate: 'defectRate',
  avgLeadTime: 'avgLeadTime',
  dependencyLevel: 'dependencyLevel',
  dependencyScore: 'dependencyScore',
  spendPercentage: 'spendPercentage',
  alternativeSuppliers: 'alternativeSuppliers',
  criticalItems: 'criticalItems',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


export const SupplierContactScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  name: 'name',
  title: 'title',
  email: 'email',
  phone: 'phone',
  isPrimary: 'isPrimary',
  role: 'role',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupplierContactScalarFieldEnum = (typeof SupplierContactScalarFieldEnum)[keyof typeof SupplierContactScalarFieldEnum]


export const SupplierBalanceScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  totalOutstanding: 'totalOutstanding',
  currentDue: 'currentDue',
  overdue30: 'overdue30',
  overdue60: 'overdue60',
  overdue90Plus: 'overdue90Plus',
  availableCredits: 'availableCredits',
  pendingCredits: 'pendingCredits',
  lastPaymentAmount: 'lastPaymentAmount',
  lastPaymentDate: 'lastPaymentDate',
  nextPaymentDue: 'nextPaymentDue',
  nextPaymentAmount: 'nextPaymentAmount',
  ytdPayments: 'ytdPayments',
  ytdPurchases: 'ytdPurchases',
  updatedAt: 'updatedAt'
} as const

export type SupplierBalanceScalarFieldEnum = (typeof SupplierBalanceScalarFieldEnum)[keyof typeof SupplierBalanceScalarFieldEnum]


export const SupplierPaymentScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  paymentNumber: 'paymentNumber',
  invoiceIds: 'invoiceIds',
  amount: 'amount',
  currency: 'currency',
  paymentDate: 'paymentDate',
  dueDate: 'dueDate',
  paymentMethod: 'paymentMethod',
  referenceNumber: 'referenceNumber',
  bankAccount: 'bankAccount',
  status: 'status',
  discountTaken: 'discountTaken',
  discountType: 'discountType',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type SupplierPaymentScalarFieldEnum = (typeof SupplierPaymentScalarFieldEnum)[keyof typeof SupplierPaymentScalarFieldEnum]


export const SupplierReliabilityScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  orderId: 'orderId',
  orderNumber: 'orderNumber',
  orderDate: 'orderDate',
  expectedDeliveryDate: 'expectedDeliveryDate',
  actualDeliveryDate: 'actualDeliveryDate',
  daysVariance: 'daysVariance',
  itemsOrdered: 'itemsOrdered',
  itemsReceived: 'itemsReceived',
  itemsDefective: 'itemsDefective',
  qualityScore: 'qualityScore',
  hasIssues: 'hasIssues',
  issueType: 'issueType',
  issueDescription: 'issueDescription',
  issueResolved: 'issueResolved',
  createdAt: 'createdAt'
} as const

export type SupplierReliabilityScalarFieldEnum = (typeof SupplierReliabilityScalarFieldEnum)[keyof typeof SupplierReliabilityScalarFieldEnum]


export const SupplierSpendScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  period: 'period',
  periodType: 'periodType',
  totalSpend: 'totalSpend',
  directSpend: 'directSpend',
  indirectSpend: 'indirectSpend',
  goodsSpend: 'goodsSpend',
  servicesSpend: 'servicesSpend',
  orderCount: 'orderCount',
  averageOrderValue: 'averageOrderValue',
  previousPeriodSpend: 'previousPeriodSpend',
  changePercentage: 'changePercentage',
  budgetAmount: 'budgetAmount',
  budgetVariance: 'budgetVariance',
  createdAt: 'createdAt'
} as const

export type SupplierSpendScalarFieldEnum = (typeof SupplierSpendScalarFieldEnum)[keyof typeof SupplierSpendScalarFieldEnum]


export const SupplierRiskScalarFieldEnum = {
  id: 'id',
  supplierId: 'supplierId',
  riskType: 'riskType',
  title: 'title',
  description: 'description',
  severity: 'severity',
  impactScore: 'impactScore',
  probabilityScore: 'probabilityScore',
  overallRiskScore: 'overallRiskScore',
  mitigationPlan: 'mitigationPlan',
  mitigationStatus: 'mitigationStatus',
  status: 'status',
  identifiedAt: 'identifiedAt',
  resolvedAt: 'resolvedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupplierRiskScalarFieldEnum = (typeof SupplierRiskScalarFieldEnum)[keyof typeof SupplierRiskScalarFieldEnum]


export const NettingAgreementScalarFieldEnum = {
  id: 'id',
  agreementNumber: 'agreementNumber',
  name: 'name',
  type: 'type',
  status: 'status',
  nettingFrequency: 'nettingFrequency',
  settlementDays: 'settlementDays',
  baseCurrency: 'baseCurrency',
  minimumNettingAmount: 'minimumNettingAmount',
  maximumNettingAmount: 'maximumNettingAmount',
  effectiveDate: 'effectiveDate',
  expiryDate: 'expiryDate',
  lastNettingDate: 'lastNettingDate',
  nextNettingDate: 'nextNettingDate',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NettingAgreementScalarFieldEnum = (typeof NettingAgreementScalarFieldEnum)[keyof typeof NettingAgreementScalarFieldEnum]


export const NettingPartyScalarFieldEnum = {
  id: 'id',
  partyId: 'partyId',
  partyName: 'partyName',
  partyType: 'partyType',
  accountNumber: 'accountNumber',
  bankName: 'bankName',
  bankDetails: 'bankDetails',
  isNettingCenter: 'isNettingCenter',
  agreementId: 'agreementId',
  createdAt: 'createdAt'
} as const

export type NettingPartyScalarFieldEnum = (typeof NettingPartyScalarFieldEnum)[keyof typeof NettingPartyScalarFieldEnum]


export const NettingSessionScalarFieldEnum = {
  id: 'id',
  sessionNumber: 'sessionNumber',
  type: 'type',
  status: 'status',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  nettingDate: 'nettingDate',
  settlementDate: 'settlementDate',
  baseCurrency: 'baseCurrency',
  totalReceivables: 'totalReceivables',
  totalPayables: 'totalPayables',
  grossAmount: 'grossAmount',
  netAmount: 'netAmount',
  savingsAmount: 'savingsAmount',
  savingsPercentage: 'savingsPercentage',
  createdById: 'createdById',
  createdByName: 'createdByName',
  approvedBy: 'approvedBy',
  approvedByName: 'approvedByName',
  approvedAt: 'approvedAt',
  rejectedBy: 'rejectedBy',
  rejectedByName: 'rejectedByName',
  rejectedAt: 'rejectedAt',
  rejectedReason: 'rejectedReason',
  notes: 'notes',
  agreementId: 'agreementId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NettingSessionScalarFieldEnum = (typeof NettingSessionScalarFieldEnum)[keyof typeof NettingSessionScalarFieldEnum]


export const NettingPositionScalarFieldEnum = {
  id: 'id',
  partyId: 'partyId',
  partyName: 'partyName',
  partyType: 'partyType',
  receivables: 'receivables',
  payables: 'payables',
  grossPosition: 'grossPosition',
  netPosition: 'netPosition',
  receivableCount: 'receivableCount',
  payableCount: 'payableCount',
  settlementDirection: 'settlementDirection',
  settlementAmount: 'settlementAmount',
  sessionId: 'sessionId',
  nettingPartyId: 'nettingPartyId',
  createdAt: 'createdAt'
} as const

export type NettingPositionScalarFieldEnum = (typeof NettingPositionScalarFieldEnum)[keyof typeof NettingPositionScalarFieldEnum]


export const NettingTransactionScalarFieldEnum = {
  id: 'id',
  documentType: 'documentType',
  documentNumber: 'documentNumber',
  documentDate: 'documentDate',
  dueDate: 'dueDate',
  counterpartyId: 'counterpartyId',
  counterpartyName: 'counterpartyName',
  originalCurrency: 'originalCurrency',
  originalAmount: 'originalAmount',
  baseCurrencyAmount: 'baseCurrencyAmount',
  exchangeRate: 'exchangeRate',
  direction: 'direction',
  included: 'included',
  excludedReason: 'excludedReason',
  positionId: 'positionId',
  createdAt: 'createdAt'
} as const

export type NettingTransactionScalarFieldEnum = (typeof NettingTransactionScalarFieldEnum)[keyof typeof NettingTransactionScalarFieldEnum]


export const SettlementInstructionScalarFieldEnum = {
  id: 'id',
  instructionNumber: 'instructionNumber',
  payerId: 'payerId',
  payerName: 'payerName',
  receiverId: 'receiverId',
  receiverName: 'receiverName',
  amount: 'amount',
  currency: 'currency',
  settlementMethod: 'settlementMethod',
  payerBankAccount: 'payerBankAccount',
  receiverBankAccount: 'receiverBankAccount',
  status: 'status',
  valueDate: 'valueDate',
  processedAt: 'processedAt',
  paymentReference: 'paymentReference',
  sessionId: 'sessionId',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type SettlementInstructionScalarFieldEnum = (typeof SettlementInstructionScalarFieldEnum)[keyof typeof SettlementInstructionScalarFieldEnum]


export const OffsetEntryScalarFieldEnum = {
  id: 'id',
  offsetNumber: 'offsetNumber',
  type: 'type',
  status: 'status',
  partyId: 'partyId',
  partyName: 'partyName',
  partyType: 'partyType',
  sourceDocumentType: 'sourceDocumentType',
  sourceDocumentNumber: 'sourceDocumentNumber',
  sourceAmount: 'sourceAmount',
  targetDocumentType: 'targetDocumentType',
  targetDocumentNumber: 'targetDocumentNumber',
  targetAmount: 'targetAmount',
  offsetAmount: 'offsetAmount',
  currency: 'currency',
  offsetDate: 'offsetDate',
  effectiveDate: 'effectiveDate',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  approverName: 'approverName',
  reversedAt: 'reversedAt',
  reversedBy: 'reversedBy',
  reversalReason: 'reversalReason',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OffsetEntryScalarFieldEnum = (typeof OffsetEntryScalarFieldEnum)[keyof typeof OffsetEntryScalarFieldEnum]


export const OfferScalarFieldEnum = {
  id: 'id',
  offerNumber: 'offerNumber',
  version: 'version',
  status: 'status',
  counterparty: 'counterparty',
  customerId: 'customerId',
  customerName: 'customerName',
  offerDate: 'offerDate',
  validityDays: 'validityDays',
  expiryDate: 'expiryDate',
  sentAt: 'sentAt',
  acceptedAt: 'acceptedAt',
  rejectedAt: 'rejectedAt',
  convertedAt: 'convertedAt',
  currency: 'currency',
  paymentTerms: 'paymentTerms',
  deliveryTerms: 'deliveryTerms',
  lineItems: 'lineItems',
  subtotal: 'subtotal',
  totalDiscount: 'totalDiscount',
  taxTotal: 'taxTotal',
  grandTotal: 'grandTotal',
  taxRate: 'taxRate',
  totalCost: 'totalCost',
  grossMargin: 'grossMargin',
  grossMarginPercent: 'grossMarginPercent',
  internalNotes: 'internalNotes',
  customerNotes: 'customerNotes',
  termsAndConditions: 'termsAndConditions',
  disclaimer: 'disclaimer',
  acceptanceMethod: 'acceptanceMethod',
  rejectionReason: 'rejectionReason',
  convertedOrderId: 'convertedOrderId',
  convertedOrderNumber: 'convertedOrderNumber',
  templateId: 'templateId',
  templateName: 'templateName',
  previousVersionId: 'previousVersionId',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  sentBy: 'sentBy',
  approvedBy: 'approvedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


export const OfferVersionScalarFieldEnum = {
  id: 'id',
  offerId: 'offerId',
  version: 'version',
  changes: 'changes',
  revisionNotes: 'revisionNotes',
  snapshotData: 'snapshotData',
  createdBy: 'createdBy',
  createdAt: 'createdAt'
} as const

export type OfferVersionScalarFieldEnum = (typeof OfferVersionScalarFieldEnum)[keyof typeof OfferVersionScalarFieldEnum]


export const OfferAuditLogScalarFieldEnum = {
  id: 'id',
  offerId: 'offerId',
  offerNumber: 'offerNumber',
  action: 'action',
  details: 'details',
  previousStatus: 'previousStatus',
  newStatus: 'newStatus',
  userId: 'userId',
  userName: 'userName',
  userRole: 'userRole',
  ipAddress: 'ipAddress',
  metadata: 'metadata',
  timestamp: 'timestamp'
} as const

export type OfferAuditLogScalarFieldEnum = (typeof OfferAuditLogScalarFieldEnum)[keyof typeof OfferAuditLogScalarFieldEnum]


export const OfferTemplateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  category: 'category',
  defaultCurrency: 'defaultCurrency',
  defaultValidityDays: 'defaultValidityDays',
  defaultPaymentTerms: 'defaultPaymentTerms',
  defaultDeliveryTerms: 'defaultDeliveryTerms',
  defaultTermsAndConditions: 'defaultTermsAndConditions',
  defaultDisclaimer: 'defaultDisclaimer',
  defaultLineItems: 'defaultLineItems',
  headerText: 'headerText',
  footerText: 'footerText',
  usageCount: 'usageCount',
  lastUsedAt: 'lastUsedAt',
  isActive: 'isActive',
  createdBy: 'createdBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OfferTemplateScalarFieldEnum = (typeof OfferTemplateScalarFieldEnum)[keyof typeof OfferTemplateScalarFieldEnum]


export const TaskScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  priority: 'priority',
  type: 'type',
  category: 'category',
  dueDate: 'dueDate',
  dueTime: 'dueTime',
  startDate: 'startDate',
  completedAt: 'completedAt',
  snoozedUntil: 'snoozedUntil',
  reminderDate: 'reminderDate',
  ownerId: 'ownerId',
  ownerName: 'ownerName',
  createdById: 'createdById',
  createdByName: 'createdByName',
  assignmentReason: 'assignmentReason',
  sourceSystem: 'sourceSystem',
  sourceEntityId: 'sourceEntityId',
  sourceEntityType: 'sourceEntityType',
  slaDeadline: 'slaDeadline',
  slaBreach: 'slaBreach',
  slaWarning: 'slaWarning',
  isBlocked: 'isBlocked',
  progress: 'progress',
  estimatedHours: 'estimatedHours',
  actualHours: 'actualHours',
  hasUnreadUpdates: 'hasUnreadUpdates',
  hasMentions: 'hasMentions',
  isRecurring: 'isRecurring',
  recurringInterval: 'recurringInterval',
  metadata: 'metadata',
  organizationId: 'organizationId',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


export const TaskAssigneeScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  userId: 'userId',
  userName: 'userName',
  email: 'email',
  avatar: 'avatar',
  assignedAt: 'assignedAt',
  assignedBy: 'assignedBy'
} as const

export type TaskAssigneeScalarFieldEnum = (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum]


export const TaskWatcherScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  userId: 'userId',
  userName: 'userName',
  watchingSince: 'watchingSince'
} as const

export type TaskWatcherScalarFieldEnum = (typeof TaskWatcherScalarFieldEnum)[keyof typeof TaskWatcherScalarFieldEnum]


export const TaskTagScalarFieldEnum = {
  id: 'id',
  name: 'name',
  color: 'color',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type TaskTagScalarFieldEnum = (typeof TaskTagScalarFieldEnum)[keyof typeof TaskTagScalarFieldEnum]


export const TaskTagLinkScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  tagId: 'tagId'
} as const

export type TaskTagLinkScalarFieldEnum = (typeof TaskTagLinkScalarFieldEnum)[keyof typeof TaskTagLinkScalarFieldEnum]


export const TaskDependencyScalarFieldEnum = {
  id: 'id',
  dependentTaskId: 'dependentTaskId',
  blockingTaskId: 'blockingTaskId',
  createdAt: 'createdAt'
} as const

export type TaskDependencyScalarFieldEnum = (typeof TaskDependencyScalarFieldEnum)[keyof typeof TaskDependencyScalarFieldEnum]


export const TaskCommentScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  content: 'content',
  authorId: 'authorId',
  authorName: 'authorName',
  parentId: 'parentId',
  mentions: 'mentions',
  reactions: 'reactions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TaskCommentScalarFieldEnum = (typeof TaskCommentScalarFieldEnum)[keyof typeof TaskCommentScalarFieldEnum]


export const TaskActivityScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  type: 'type',
  actorId: 'actorId',
  actorName: 'actorName',
  details: 'details',
  previousValue: 'previousValue',
  newValue: 'newValue',
  timestamp: 'timestamp'
} as const

export type TaskActivityScalarFieldEnum = (typeof TaskActivityScalarFieldEnum)[keyof typeof TaskActivityScalarFieldEnum]


export const TaskAttachmentScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  name: 'name',
  url: 'url',
  fileType: 'fileType',
  size: 'size',
  uploadedBy: 'uploadedBy',
  uploadedByName: 'uploadedByName',
  uploadedAt: 'uploadedAt'
} as const

export type TaskAttachmentScalarFieldEnum = (typeof TaskAttachmentScalarFieldEnum)[keyof typeof TaskAttachmentScalarFieldEnum]


export const RiskScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  severity: 'severity',
  likelihood: 'likelihood',
  impactScore: 'impactScore',
  status: 'status',
  identifiedAt: 'identifiedAt',
  targetMitigationDate: 'targetMitigationDate',
  resolvedAt: 'resolvedAt',
  lastUpdatedAt: 'lastUpdatedAt',
  ownerId: 'ownerId',
  ownerName: 'ownerName',
  escalatedTo: 'escalatedTo',
  escalatedToName: 'escalatedToName',
  impactAreas: 'impactAreas',
  affectedSystemId: 'affectedSystemId',
  affectedSystemName: 'affectedSystemName',
  affectedProjectId: 'affectedProjectId',
  affectedProjectName: 'affectedProjectName',
  blastRadius: 'blastRadius',
  mitigationPlan: 'mitigationPlan',
  mitigationProgress: 'mitigationProgress',
  sourceSystem: 'sourceSystem',
  sourceEntityId: 'sourceEntityId',
  isNewlyEscalated: 'isNewlyEscalated',
  isStale: 'isStale',
  isMitigationOverdue: 'isMitigationOverdue',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RiskScalarFieldEnum = (typeof RiskScalarFieldEnum)[keyof typeof RiskScalarFieldEnum]


export const RiskMitigationStepScalarFieldEnum = {
  id: 'id',
  riskId: 'riskId',
  description: 'description',
  orderIndex: 'orderIndex',
  ownerId: 'ownerId',
  ownerName: 'ownerName',
  deadline: 'deadline',
  status: 'status',
  completedAt: 'completedAt',
  createdAt: 'createdAt'
} as const

export type RiskMitigationStepScalarFieldEnum = (typeof RiskMitigationStepScalarFieldEnum)[keyof typeof RiskMitigationStepScalarFieldEnum]


export const TaskRiskLinkScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  riskId: 'riskId',
  createdAt: 'createdAt'
} as const

export type TaskRiskLinkScalarFieldEnum = (typeof TaskRiskLinkScalarFieldEnum)[keyof typeof TaskRiskLinkScalarFieldEnum]


export const RiskCommentScalarFieldEnum = {
  id: 'id',
  riskId: 'riskId',
  content: 'content',
  authorId: 'authorId',
  authorName: 'authorName',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RiskCommentScalarFieldEnum = (typeof RiskCommentScalarFieldEnum)[keyof typeof RiskCommentScalarFieldEnum]


export const RiskActivityScalarFieldEnum = {
  id: 'id',
  riskId: 'riskId',
  type: 'type',
  actorId: 'actorId',
  actorName: 'actorName',
  details: 'details',
  previousValue: 'previousValue',
  newValue: 'newValue',
  timestamp: 'timestamp'
} as const

export type RiskActivityScalarFieldEnum = (typeof RiskActivityScalarFieldEnum)[keyof typeof RiskActivityScalarFieldEnum]


export const TaskNotificationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  message: 'message',
  taskId: 'taskId',
  riskId: 'riskId',
  actorId: 'actorId',
  actorName: 'actorName',
  recipientId: 'recipientId',
  isRead: 'isRead',
  readAt: 'readAt',
  timestamp: 'timestamp',
  organizationId: 'organizationId'
} as const

export type TaskNotificationScalarFieldEnum = (typeof TaskNotificationScalarFieldEnum)[keyof typeof TaskNotificationScalarFieldEnum]


export const SavedTaskFilterScalarFieldEnum = {
  id: 'id',
  name: 'name',
  icon: 'icon',
  filters: 'filters',
  isDefault: 'isDefault',
  isShared: 'isShared',
  createdBy: 'createdBy',
  orderIndex: 'orderIndex',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SavedTaskFilterScalarFieldEnum = (typeof SavedTaskFilterScalarFieldEnum)[keyof typeof SavedTaskFilterScalarFieldEnum]


export const RevenueForecastScalarFieldEnum = {
  id: 'id',
  version: 'version',
  scenarioId: 'scenarioId',
  timeHorizon: 'timeHorizon',
  granularity: 'granularity',
  currency: 'currency',
  totalExpected: 'totalExpected',
  totalBestCase: 'totalBestCase',
  totalWorstCase: 'totalWorstCase',
  committedRevenue: 'committedRevenue',
  projectedRevenue: 'projectedRevenue',
  atRiskRevenue: 'atRiskRevenue',
  byProduct: 'byProduct',
  bySegment: 'bySegment',
  byRegion: 'byRegion',
  byType: 'byType',
  dataSource: 'dataSource',
  confidence: 'confidence',
  lastUpdatedBy: 'lastUpdatedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RevenueForecastScalarFieldEnum = (typeof RevenueForecastScalarFieldEnum)[keyof typeof RevenueForecastScalarFieldEnum]


export const RevenueLineItemScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  revenueType: 'revenueType',
  segment: 'segment',
  region: 'region',
  customerId: 'customerId',
  customerName: 'customerName',
  periods: 'periods',
  isCommitted: 'isCommitted',
  isAtRisk: 'isAtRisk',
  isRenewal: 'isRenewal',
  hasUpsell: 'hasUpsell',
  hasDownsell: 'hasDownsell',
  highUncertainty: 'highUncertainty',
  drivers: 'drivers',
  confidence: 'confidence',
  confidenceScore: 'confidenceScore',
  revenueForecastId: 'revenueForecastId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RevenueLineItemScalarFieldEnum = (typeof RevenueLineItemScalarFieldEnum)[keyof typeof RevenueLineItemScalarFieldEnum]


export const CostForecastScalarFieldEnum = {
  id: 'id',
  version: 'version',
  scenarioId: 'scenarioId',
  timeHorizon: 'timeHorizon',
  granularity: 'granularity',
  currency: 'currency',
  totalExpected: 'totalExpected',
  totalBestCase: 'totalBestCase',
  totalWorstCase: 'totalWorstCase',
  committedCosts: 'committedCosts',
  estimatedCosts: 'estimatedCosts',
  byCategory: 'byCategory',
  byDepartment: 'byDepartment',
  byVendor: 'byVendor',
  byProject: 'byProject',
  overrunCount: 'overrunCount',
  unplannedSpendTotal: 'unplannedSpendTotal',
  dataSource: 'dataSource',
  confidence: 'confidence',
  lastUpdatedBy: 'lastUpdatedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostForecastScalarFieldEnum = (typeof CostForecastScalarFieldEnum)[keyof typeof CostForecastScalarFieldEnum]


export const CostLineItemScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  department: 'department',
  costCenter: 'costCenter',
  vendorId: 'vendorId',
  vendorName: 'vendorName',
  projectId: 'projectId',
  projectName: 'projectName',
  periods: 'periods',
  isCommitted: 'isCommitted',
  isContractual: 'isContractual',
  hasStepChange: 'hasStepChange',
  stepChangeDescription: 'stepChangeDescription',
  isOverrun: 'isOverrun',
  isUnplanned: 'isUnplanned',
  drivers: 'drivers',
  scenarioImpact: 'scenarioImpact',
  confidence: 'confidence',
  confidenceScore: 'confidenceScore',
  costForecastId: 'costForecastId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostLineItemScalarFieldEnum = (typeof CostLineItemScalarFieldEnum)[keyof typeof CostLineItemScalarFieldEnum]


export const CashForecastScalarFieldEnum = {
  id: 'id',
  version: 'version',
  scenarioId: 'scenarioId',
  timeHorizon: 'timeHorizon',
  granularity: 'granularity',
  currency: 'currency',
  currentCashBalance: 'currentCashBalance',
  minimumCashRunway: 'minimumCashRunway',
  covenantThreshold: 'covenantThreshold',
  projectedMinimumBalance: 'projectedMinimumBalance',
  projectedMinimumDate: 'projectedMinimumDate',
  avgCollectionDays: 'avgCollectionDays',
  avgPaymentTerms: 'avgPaymentTerms',
  delayedReceivables: 'delayedReceivables',
  hasNegativePeriods: 'hasNegativePeriods',
  hasCriticalPeriods: 'hasCriticalPeriods',
  covenantAtRisk: 'covenantAtRisk',
  stressScenarios: 'stressScenarios',
  dataSource: 'dataSource',
  confidence: 'confidence',
  lastUpdatedBy: 'lastUpdatedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CashForecastScalarFieldEnum = (typeof CashForecastScalarFieldEnum)[keyof typeof CashForecastScalarFieldEnum]


export const CashForecastPeriodScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  periodLabel: 'periodLabel',
  startDate: 'startDate',
  endDate: 'endDate',
  openingBalance: 'openingBalance',
  closingBalance: 'closingBalance',
  netCashFlow: 'netCashFlow',
  cashIn: 'cashIn',
  cashInBreakdown: 'cashInBreakdown',
  cashOut: 'cashOut',
  cashOutBreakdown: 'cashOutBreakdown',
  isNegative: 'isNegative',
  isCritical: 'isCritical',
  breachesMinimum: 'breachesMinimum',
  breachesCovenant: 'breachesCovenant',
  confidence: 'confidence',
  cashForecastId: 'cashForecastId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CashForecastPeriodScalarFieldEnum = (typeof CashForecastPeriodScalarFieldEnum)[keyof typeof CashForecastPeriodScalarFieldEnum]


export const ForecastScenarioScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  revenueForecastId: 'revenueForecastId',
  costForecastId: 'costForecastId',
  cashForecastId: 'cashForecastId',
  revenueVsBase: 'revenueVsBase',
  costVsBase: 'costVsBase',
  cashVsBase: 'cashVsBase',
  netVsBase: 'netVsBase',
  isLocked: 'isLocked',
  isActive: 'isActive',
  createdBy: 'createdBy',
  lastUpdatedBy: 'lastUpdatedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForecastScenarioScalarFieldEnum = (typeof ForecastScenarioScalarFieldEnum)[keyof typeof ForecastScenarioScalarFieldEnum]


export const ForecastAssumptionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  value: 'value',
  unit: 'unit',
  description: 'description',
  impactedForecasts: 'impactedForecasts',
  isEditable: 'isEditable',
  lastUpdatedBy: 'lastUpdatedBy',
  scenarioId: 'scenarioId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForecastAssumptionScalarFieldEnum = (typeof ForecastAssumptionScalarFieldEnum)[keyof typeof ForecastAssumptionScalarFieldEnum]


export const ForecastAlertScalarFieldEnum = {
  id: 'id',
  type: 'type',
  severity: 'severity',
  title: 'title',
  message: 'message',
  forecastType: 'forecastType',
  periodId: 'periodId',
  lineItemId: 'lineItemId',
  threshold: 'threshold',
  currentValue: 'currentValue',
  isRead: 'isRead',
  isDismissed: 'isDismissed',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type ForecastAlertScalarFieldEnum = (typeof ForecastAlertScalarFieldEnum)[keyof typeof ForecastAlertScalarFieldEnum]


export const ForecastAnnotationScalarFieldEnum = {
  id: 'id',
  content: 'content',
  authorId: 'authorId',
  authorName: 'authorName',
  lineItemId: 'lineItemId',
  periodId: 'periodId',
  revenueForecastId: 'revenueForecastId',
  costForecastId: 'costForecastId',
  cashForecastId: 'cashForecastId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForecastAnnotationScalarFieldEnum = (typeof ForecastAnnotationScalarFieldEnum)[keyof typeof ForecastAnnotationScalarFieldEnum]


export const ForecastVarianceScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  periodLabel: 'periodLabel',
  revenueForecast: 'revenueForecast',
  revenueActual: 'revenueActual',
  revenueVariance: 'revenueVariance',
  revenueVariancePct: 'revenueVariancePct',
  costForecast: 'costForecast',
  costActual: 'costActual',
  costVariance: 'costVariance',
  costVariancePct: 'costVariancePct',
  cashForecast: 'cashForecast',
  cashActual: 'cashActual',
  cashVariance: 'cashVariance',
  cashVariancePct: 'cashVariancePct',
  netForecast: 'netForecast',
  netActual: 'netActual',
  netVariance: 'netVariance',
  netVariancePct: 'netVariancePct',
  revenueAttribution: 'revenueAttribution',
  costAttribution: 'costAttribution',
  cashAttribution: 'cashAttribution',
  hasMaterialVariance: 'hasMaterialVariance',
  varianceThresholdBreached: 'varianceThresholdBreached',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ForecastVarianceScalarFieldEnum = (typeof ForecastVarianceScalarFieldEnum)[keyof typeof ForecastVarianceScalarFieldEnum]


export const ScenarioScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  caseType: 'caseType',
  status: 'status',
  visibility: 'visibility',
  metrics: 'metrics',
  confidenceLevel: 'confidenceLevel',
  confidenceScore: 'confidenceScore',
  uncertaintyBandLow: 'uncertaintyBandLow',
  uncertaintyBandHigh: 'uncertaintyBandHigh',
  derivedFromId: 'derivedFromId',
  derivedFromName: 'derivedFromName',
  ownerId: 'ownerId',
  ownerName: 'ownerName',
  sharedWithTeams: 'sharedWithTeams',
  version: 'version',
  previousVersionId: 'previousVersionId',
  tags: 'tags',
  createdBy: 'createdBy',
  lastModifiedBy: 'lastModifiedBy',
  lockedAt: 'lockedAt',
  lockedBy: 'lockedBy',
  approvedAt: 'approvedAt',
  approvedBy: 'approvedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


export const ScenarioAssumptionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  baseValue: 'baseValue',
  currentValue: 'currentValue',
  unit: 'unit',
  description: 'description',
  isProtected: 'isProtected',
  isOverridden: 'isOverridden',
  minValue: 'minValue',
  maxValue: 'maxValue',
  step: 'step',
  impactedMetrics: 'impactedMetrics',
  lastModifiedAt: 'lastModifiedAt',
  lastModifiedBy: 'lastModifiedBy',
  scenarioId: 'scenarioId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ScenarioAssumptionScalarFieldEnum = (typeof ScenarioAssumptionScalarFieldEnum)[keyof typeof ScenarioAssumptionScalarFieldEnum]


export const StressTestScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  isTemplate: 'isTemplate',
  parameters: 'parameters',
  intensity: 'intensity',
  result: 'result',
  resultMetrics: 'resultMetrics',
  thresholds: 'thresholds',
  cashShortfallPoint: 'cashShortfallPoint',
  covenantBreachPoint: 'covenantBreachPoint',
  marginCollapsePoint: 'marginCollapsePoint',
  defaultIntensities: 'defaultIntensities',
  lastRunAt: 'lastRunAt',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StressTestScalarFieldEnum = (typeof StressTestScalarFieldEnum)[keyof typeof StressTestScalarFieldEnum]


export const SimulationStateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  drivers: 'drivers',
  resultMetrics: 'resultMetrics',
  comparisonBaselineId: 'comparisonBaselineId',
  isPinned: 'isPinned',
  pinnedAsScenarioId: 'pinnedAsScenarioId',
  organizationId: 'organizationId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SimulationStateScalarFieldEnum = (typeof SimulationStateScalarFieldEnum)[keyof typeof SimulationStateScalarFieldEnum]


export const ScenarioCommentScalarFieldEnum = {
  id: 'id',
  scenarioId: 'scenarioId',
  content: 'content',
  authorId: 'authorId',
  authorName: 'authorName',
  parentId: 'parentId',
  isResolved: 'isResolved',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ScenarioCommentScalarFieldEnum = (typeof ScenarioCommentScalarFieldEnum)[keyof typeof ScenarioCommentScalarFieldEnum]


export const ScenarioDecisionScalarFieldEnum = {
  id: 'id',
  scenarioId: 'scenarioId',
  type: 'type',
  decision: 'decision',
  rationale: 'rationale',
  decidedBy: 'decidedBy',
  decidedByName: 'decidedByName',
  decidedAt: 'decidedAt',
  createdAt: 'createdAt'
} as const

export type ScenarioDecisionScalarFieldEnum = (typeof ScenarioDecisionScalarFieldEnum)[keyof typeof ScenarioDecisionScalarFieldEnum]


export const ScenarioChangeEventScalarFieldEnum = {
  id: 'id',
  scenarioId: 'scenarioId',
  changeType: 'changeType',
  assumptionId: 'assumptionId',
  assumptionName: 'assumptionName',
  previousValue: 'previousValue',
  newValue: 'newValue',
  previousStatus: 'previousStatus',
  newStatus: 'newStatus',
  description: 'description',
  userId: 'userId',
  userName: 'userName',
  timestamp: 'timestamp'
} as const

export type ScenarioChangeEventScalarFieldEnum = (typeof ScenarioChangeEventScalarFieldEnum)[keyof typeof ScenarioChangeEventScalarFieldEnum]


export const KPIScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  shortName: 'shortName',
  description: 'description',
  category: 'category',
  calculationType: 'calculationType',
  formula: 'formula',
  dataSource: 'dataSource',
  dataSources: 'dataSources',
  unit: 'unit',
  format: 'format',
  higherIsBetter: 'higherIsBetter',
  currentValue: 'currentValue',
  previousValue: 'previousValue',
  targetValue: 'targetValue',
  baselineValue: 'baselineValue',
  rollingAvg3M: 'rollingAvg3M',
  rollingAvg6M: 'rollingAvg6M',
  rollingAvg12M: 'rollingAvg12M',
  deltaVsPrior: 'deltaVsPrior',
  deltaVsPriorPercent: 'deltaVsPriorPercent',
  deltaVsTarget: 'deltaVsTarget',
  deltaVsTargetPercent: 'deltaVsTargetPercent',
  status: 'status',
  trend: 'trend',
  trendMomentum: 'trendMomentum',
  dataFreshness: 'dataFreshness',
  lastCalculatedAt: 'lastCalculatedAt',
  thresholds: 'thresholds',
  seasonalityFactor: 'seasonalityFactor',
  volatility: 'volatility',
  isAnomaly: 'isAnomaly',
  displayOrder: 'displayOrder',
  isVisible: 'isVisible',
  isPinned: 'isPinned',
  tags: 'tags',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type KPIScalarFieldEnum = (typeof KPIScalarFieldEnum)[keyof typeof KPIScalarFieldEnum]


export const KPIHistoryScalarFieldEnum = {
  id: 'id',
  periodType: 'periodType',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  periodLabel: 'periodLabel',
  value: 'value',
  targetValue: 'targetValue',
  previousValue: 'previousValue',
  vsTarget: 'vsTarget',
  vsPrevious: 'vsPrevious',
  status: 'status',
  trend: 'trend',
  isAnomaly: 'isAnomaly',
  annotation: 'annotation',
  kpiId: 'kpiId',
  createdAt: 'createdAt'
} as const

export type KPIHistoryScalarFieldEnum = (typeof KPIHistoryScalarFieldEnum)[keyof typeof KPIHistoryScalarFieldEnum]


export const KPIAlertScalarFieldEnum = {
  id: 'id',
  type: 'type',
  severity: 'severity',
  title: 'title',
  message: 'message',
  currentValue: 'currentValue',
  threshold: 'threshold',
  deviation: 'deviation',
  suggestedAction: 'suggestedAction',
  isRead: 'isRead',
  isDismissed: 'isDismissed',
  readAt: 'readAt',
  dismissedAt: 'dismissedAt',
  dismissedBy: 'dismissedBy',
  triggeredAt: 'triggeredAt',
  kpiId: 'kpiId',
  organizationId: 'organizationId'
} as const

export type KPIAlertScalarFieldEnum = (typeof KPIAlertScalarFieldEnum)[keyof typeof KPIAlertScalarFieldEnum]


export const KPITargetScalarFieldEnum = {
  id: 'id',
  periodType: 'periodType',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  periodLabel: 'periodLabel',
  targetValue: 'targetValue',
  stretchValue: 'stretchValue',
  minimumValue: 'minimumValue',
  status: 'status',
  actualValue: 'actualValue',
  achievementPercent: 'achievementPercent',
  notes: 'notes',
  kpiId: 'kpiId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type KPITargetScalarFieldEnum = (typeof KPITargetScalarFieldEnum)[keyof typeof KPITargetScalarFieldEnum]


export const KPIBenchmarkScalarFieldEnum = {
  id: 'id',
  source: 'source',
  sourceName: 'sourceName',
  value: 'value',
  percentile: 'percentile',
  rangeMin: 'rangeMin',
  rangeMax: 'rangeMax',
  validFrom: 'validFrom',
  validTo: 'validTo',
  isActive: 'isActive',
  notes: 'notes',
  kpiId: 'kpiId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type KPIBenchmarkScalarFieldEnum = (typeof KPIBenchmarkScalarFieldEnum)[keyof typeof KPIBenchmarkScalarFieldEnum]


export const FXRateScalarFieldEnum = {
  id: 'id',
  baseCurrency: 'baseCurrency',
  quoteCurrency: 'quoteCurrency',
  rate: 'rate',
  inverseRate: 'inverseRate',
  source: 'source',
  timestamp: 'timestamp',
  validUntil: 'validUntil',
  spread: 'spread',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type FXRateScalarFieldEnum = (typeof FXRateScalarFieldEnum)[keyof typeof FXRateScalarFieldEnum]


export const FXExposureScalarFieldEnum = {
  id: 'id',
  baseCurrency: 'baseCurrency',
  quoteCurrency: 'quoteCurrency',
  type: 'type',
  direction: 'direction',
  timeHorizon: 'timeHorizon',
  status: 'status',
  grossExposure: 'grossExposure',
  netExposure: 'netExposure',
  hedgedAmount: 'hedgedAmount',
  unhedgedAmount: 'unhedgedAmount',
  hedgePercentage: 'hedgePercentage',
  receivables: 'receivables',
  payables: 'payables',
  cashBalance: 'cashBalance',
  operationalInflows: 'operationalInflows',
  operationalOutflows: 'operationalOutflows',
  structuralPositions: 'structuralPositions',
  entityId: 'entityId',
  entityName: 'entityName',
  spotRate: 'spotRate',
  bookingRate: 'bookingRate',
  currentRate: 'currentRate',
  targetRate: 'targetRate',
  baseCurrencyValue: 'baseCurrencyValue',
  valuationDate: 'valuationDate',
  riskLevel: 'riskLevel',
  volatility30d: 'volatility30d',
  var95: 'var95',
  unrealizedGainLoss: 'unrealizedGainLoss',
  realizedGainLoss: 'realizedGainLoss',
  exposureDate: 'exposureDate',
  settlementDate: 'settlementDate',
  maturityDate: 'maturityDate',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  counterparty: 'counterparty',
  dataQuality: 'dataQuality',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXExposureScalarFieldEnum = (typeof FXExposureScalarFieldEnum)[keyof typeof FXExposureScalarFieldEnum]


export const FXConversionScalarFieldEnum = {
  id: 'id',
  conversionNumber: 'conversionNumber',
  sourceCurrency: 'sourceCurrency',
  targetCurrency: 'targetCurrency',
  sourceAmount: 'sourceAmount',
  targetAmount: 'targetAmount',
  appliedRate: 'appliedRate',
  referenceRate: 'referenceRate',
  rateDeviation: 'rateDeviation',
  rateSource: 'rateSource',
  spreadCost: 'spreadCost',
  feeCost: 'feeCost',
  totalCost: 'totalCost',
  effectiveRate: 'effectiveRate',
  executionChannel: 'executionChannel',
  counterparty: 'counterparty',
  conversionDate: 'conversionDate',
  valueDate: 'valueDate',
  settlementDate: 'settlementDate',
  status: 'status',
  purpose: 'purpose',
  relatedDocuments: 'relatedDocuments',
  initiatedBy: 'initiatedBy',
  approvedBy: 'approvedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXConversionScalarFieldEnum = (typeof FXConversionScalarFieldEnum)[keyof typeof FXConversionScalarFieldEnum]


export const FXScenarioScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  baseCurrency: 'baseCurrency',
  rateAssumptions: 'rateAssumptions',
  totalExposureImpact: 'totalExposureImpact',
  revenueImpact: 'revenueImpact',
  costImpact: 'costImpact',
  cashImpact: 'cashImpact',
  scenarioType: 'scenarioType',
  severity: 'severity',
  probability: 'probability',
  isActive: 'isActive',
  isHypothetical: 'isHypothetical',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXScenarioScalarFieldEnum = (typeof FXScenarioScalarFieldEnum)[keyof typeof FXScenarioScalarFieldEnum]


export const FXForecastScalarFieldEnum = {
  id: 'id',
  name: 'name',
  baseCurrency: 'baseCurrency',
  horizonMonths: 'horizonMonths',
  projectedExposures: 'projectedExposures',
  assumptions: 'assumptions',
  status: 'status',
  isHypothetical: 'isHypothetical',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXForecastScalarFieldEnum = (typeof FXForecastScalarFieldEnum)[keyof typeof FXForecastScalarFieldEnum]


export const FXCostScalarFieldEnum = {
  id: 'id',
  period: 'period',
  baseCurrency: 'baseCurrency',
  spreadCosts: 'spreadCosts',
  transactionFees: 'transactionFees',
  bankCharges: 'bankCharges',
  totalExplicitCosts: 'totalExplicitCosts',
  rateDeviationImpact: 'rateDeviationImpact',
  timingImpact: 'timingImpact',
  totalImplicitCosts: 'totalImplicitCosts',
  totalFXCosts: 'totalFXCosts',
  costAsPercentOfVolume: 'costAsPercentOfVolume',
  revenueImpact: 'revenueImpact',
  costImpact: 'costImpact',
  cashImpact: 'cashImpact',
  netPnLImpact: 'netPnLImpact',
  priorPeriodCosts: 'priorPeriodCosts',
  changeVsPrior: 'changeVsPrior',
  changePercentVsPrior: 'changePercentVsPrior',
  calculationMethod: 'calculationMethod',
  referenceRateUsed: 'referenceRateUsed',
  lastCalculated: 'lastCalculated',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXCostScalarFieldEnum = (typeof FXCostScalarFieldEnum)[keyof typeof FXCostScalarFieldEnum]


export const FXRiskIndicatorScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  riskLevel: 'riskLevel',
  metric: 'metric',
  threshold: 'threshold',
  breached: 'breached',
  currency: 'currency',
  recommendation: 'recommendation',
  isActive: 'isActive',
  lastAssessed: 'lastAssessed',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FXRiskIndicatorScalarFieldEnum = (typeof FXRiskIndicatorScalarFieldEnum)[keyof typeof FXRiskIndicatorScalarFieldEnum]


export const FXAuditLogScalarFieldEnum = {
  id: 'id',
  action: 'action',
  category: 'category',
  details: 'details',
  oldValue: 'oldValue',
  newValue: 'newValue',
  userId: 'userId',
  userName: 'userName',
  ipAddress: 'ipAddress',
  organizationId: 'organizationId',
  timestamp: 'timestamp'
} as const

export type FXAuditLogScalarFieldEnum = (typeof FXAuditLogScalarFieldEnum)[keyof typeof FXAuditLogScalarFieldEnum]


export const InvestorSnapshotScalarFieldEnum = {
  id: 'id',
  snapshotDate: 'snapshotDate',
  periodType: 'periodType',
  periodLabel: 'periodLabel',
  revenueMTD: 'revenueMTD',
  revenueQTD: 'revenueQTD',
  revenueYTD: 'revenueYTD',
  revenueTTM: 'revenueTTM',
  totalCosts: 'totalCosts',
  fixedCosts: 'fixedCosts',
  variableCosts: 'variableCosts',
  grossMargin: 'grossMargin',
  grossMarginPercent: 'grossMarginPercent',
  operatingMargin: 'operatingMargin',
  operatingMarginPercent: 'operatingMarginPercent',
  ebitda: 'ebitda',
  ebitdaMarginPercent: 'ebitdaMarginPercent',
  netMargin: 'netMargin',
  netMarginPercent: 'netMarginPercent',
  cashAndEquivalents: 'cashAndEquivalents',
  restrictedCash: 'restrictedCash',
  totalCash: 'totalCash',
  shortTermLiabilities: 'shortTermLiabilities',
  longTermLiabilities: 'longTermLiabilities',
  totalLiabilities: 'totalLiabilities',
  currentAssets: 'currentAssets',
  currentLiabilities: 'currentLiabilities',
  netWorkingCapital: 'netWorkingCapital',
  employeeCount: 'employeeCount',
  revenuePerEmployee: 'revenuePerEmployee',
  costPerEmployee: 'costPerEmployee',
  unitEconomics: 'unitEconomics',
  currentRatio: 'currentRatio',
  quickRatio: 'quickRatio',
  monthlyBurn: 'monthlyBurn',
  burnAvg3Month: 'burnAvg3Month',
  burnAvg6Month: 'burnAvg6Month',
  burnTrend: 'burnTrend',
  burnTrendPercent: 'burnTrendPercent',
  runwayMonths: 'runwayMonths',
  runwayEndDate: 'runwayEndDate',
  overallRiskLevel: 'overallRiskLevel',
  liquidityRisk: 'liquidityRisk',
  dataQuality: 'dataQuality',
  dataCompleteness: 'dataCompleteness',
  currency: 'currency',
  computedAt: 'computedAt',
  computedBy: 'computedBy',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type InvestorSnapshotScalarFieldEnum = (typeof InvestorSnapshotScalarFieldEnum)[keyof typeof InvestorSnapshotScalarFieldEnum]


export const BoardReportScalarFieldEnum = {
  id: 'id',
  title: 'title',
  periodCovered: 'periodCovered',
  asOfDate: 'asOfDate',
  financialHealthStatus: 'financialHealthStatus',
  liquidityStatus: 'liquidityStatus',
  sustainabilityOutlook: 'sustainabilityOutlook',
  keyHighlights: 'keyHighlights',
  materialChanges: 'materialChanges',
  riskFactors: 'riskFactors',
  dataLimitations: 'dataLimitations',
  concentrationRisks: 'concentrationRisks',
  snapshotId: 'snapshotId',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  publishedAt: 'publishedAt',
  distributedTo: 'distributedTo',
  distributedAt: 'distributedAt',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BoardReportScalarFieldEnum = (typeof BoardReportScalarFieldEnum)[keyof typeof BoardReportScalarFieldEnum]


export const RunwayProjectionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  scenarioType: 'scenarioType',
  projectionDate: 'projectionDate',
  currentCash: 'currentCash',
  currency: 'currency',
  assumptions: 'assumptions',
  monthlyBurnRate: 'monthlyBurnRate',
  runwayMonths: 'runwayMonths',
  runwayEndDate: 'runwayEndDate',
  confidenceLevel: 'confidenceLevel',
  projectionBasis: 'projectionBasis',
  timeHorizon: 'timeHorizon',
  warnings: 'warnings',
  dataInputs: 'dataInputs',
  isActive: 'isActive',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RunwayProjectionScalarFieldEnum = (typeof RunwayProjectionScalarFieldEnum)[keyof typeof RunwayProjectionScalarFieldEnum]


export const InvestorAccessLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  userName: 'userName',
  userRole: 'userRole',
  action: 'action',
  section: 'section',
  details: 'details',
  ipAddress: 'ipAddress',
  sessionId: 'sessionId',
  userAgent: 'userAgent',
  organizationId: 'organizationId',
  timestamp: 'timestamp'
} as const

export type InvestorAccessLogScalarFieldEnum = (typeof InvestorAccessLogScalarFieldEnum)[keyof typeof InvestorAccessLogScalarFieldEnum]


export const CashflowItemScalarFieldEnum = {
  id: 'id',
  type: 'type',
  category: 'category',
  description: 'description',
  amount: 'amount',
  currency: 'currency',
  expectedDate: 'expectedDate',
  confidence: 'confidence',
  sourceType: 'sourceType',
  sourceReference: 'sourceReference',
  sourceDocument: 'sourceDocument',
  counterparty: 'counterparty',
  entityId: 'entityId',
  entityName: 'entityName',
  isRecurring: 'isRecurring',
  recurrencePattern: 'recurrencePattern',
  status: 'status',
  notes: 'notes',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type CashflowItemScalarFieldEnum = (typeof CashflowItemScalarFieldEnum)[keyof typeof CashflowItemScalarFieldEnum]


export const LiquidityScenarioScalarFieldEnum = {
  id: 'id',
  type: 'type',
  name: 'name',
  description: 'description',
  assumptions: 'assumptions',
  horizonDays: 'horizonDays',
  timeBucket: 'timeBucket',
  startDate: 'startDate',
  startingCashBalance: 'startingCashBalance',
  minimumBuffer: 'minimumBuffer',
  currency: 'currency',
  timeline: 'timeline',
  totalInflows: 'totalInflows',
  totalOutflows: 'totalOutflows',
  netChange: 'netChange',
  endingBalance: 'endingBalance',
  lowestBalance: 'lowestBalance',
  lowestBalanceDate: 'lowestBalanceDate',
  daysWithGap: 'daysWithGap',
  totalGapAmount: 'totalGapAmount',
  confirmedCashflows: 'confirmedCashflows',
  expectedCashflows: 'expectedCashflows',
  estimatedCashflows: 'estimatedCashflows',
  dataCompleteness: 'dataCompleteness',
  varianceEndingBalance: 'varianceEndingBalance',
  varianceLowestBalance: 'varianceLowestBalance',
  additionalGapDays: 'additionalGapDays',
  isActive: 'isActive',
  isHypothetical: 'isHypothetical',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type LiquidityScenarioScalarFieldEnum = (typeof LiquidityScenarioScalarFieldEnum)[keyof typeof LiquidityScenarioScalarFieldEnum]


export const LiquidityGapScalarFieldEnum = {
  id: 'id',
  startDate: 'startDate',
  endDate: 'endDate',
  durationDays: 'durationDays',
  peakDeficit: 'peakDeficit',
  averageDeficit: 'averageDeficit',
  totalDeficitDays: 'totalDeficitDays',
  currency: 'currency',
  causes: 'causes',
  affectedPeriods: 'affectedPeriods',
  severity: 'severity',
  status: 'status',
  mitigationPlan: 'mitigationPlan',
  mitigatedAt: 'mitigatedAt',
  mitigatedBy: 'mitigatedBy',
  scenarioId: 'scenarioId',
  organizationId: 'organizationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiquidityGapScalarFieldEnum = (typeof LiquidityGapScalarFieldEnum)[keyof typeof LiquidityGapScalarFieldEnum]


export const LiquidityRiskSignalScalarFieldEnum = {
  id: 'id',
  type: 'type',
  title: 'title',
  description: 'description',
  riskLevel: 'riskLevel',
  metric: 'metric',
  threshold: 'threshold',
  breached: 'breached',
  affectedPeriod: 'affectedPeriod',
  relatedItems: 'relatedItems',
  status: 'status',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  dismissedAt: 'dismissedAt',
  dismissedBy: 'dismissedBy',
  organizationId: 'organizationId',
  detectedAt: 'detectedAt'
} as const

export type LiquidityRiskSignalScalarFieldEnum = (typeof LiquidityRiskSignalScalarFieldEnum)[keyof typeof LiquidityRiskSignalScalarFieldEnum]


export const LiquidityAuditLogScalarFieldEnum = {
  id: 'id',
  action: 'action',
  details: 'details',
  userId: 'userId',
  userName: 'userName',
  userRole: 'userRole',
  scenarioId: 'scenarioId',
  dataReferenced: 'dataReferenced',
  organizationId: 'organizationId',
  timestamp: 'timestamp'
} as const

export type LiquidityAuditLogScalarFieldEnum = (typeof LiquidityAuditLogScalarFieldEnum)[keyof typeof LiquidityAuditLogScalarFieldEnum]


export const LiquidityPositionScalarFieldEnum = {
  id: 'id',
  positionDate: 'positionDate',
  periodType: 'periodType',
  totalCash: 'totalCash',
  operatingCash: 'operatingCash',
  reserveCash: 'reserveCash',
  restrictedCash: 'restrictedCash',
  availableCredit: 'availableCredit',
  totalLiquidity: 'totalLiquidity',
  minimumBuffer: 'minimumBuffer',
  expectedInflows: 'expectedInflows',
  expectedOutflows: 'expectedOutflows',
  netCashFlow: 'netCashFlow',
  confirmedInflows: 'confirmedInflows',
  expectedInflows2: 'expectedInflows2',
  estimatedInflows: 'estimatedInflows',
  confirmedOutflows: 'confirmedOutflows',
  expectedOutflows2: 'expectedOutflows2',
  estimatedOutflows: 'estimatedOutflows',
  projectedEndingCash: 'projectedEndingCash',
  runwayDays: 'runwayDays',
  runwayMonths: 'runwayMonths',
  currentRatio: 'currentRatio',
  quickRatio: 'quickRatio',
  cashBurnRate: 'cashBurnRate',
  bufferDays: 'bufferDays',
  concentrationIndex: 'concentrationIndex',
  volatilityIndex: 'volatilityIndex',
  status: 'status',
  riskLevel: 'riskLevel',
  riskScore: 'riskScore',
  dataCompleteness: 'dataCompleteness',
  knownBlindSpots: 'knownBlindSpots',
  accountBreakdown: 'accountBreakdown',
  currency: 'currency',
  organizationId: 'organizationId',
  createdAt: 'createdAt'
} as const

export type LiquidityPositionScalarFieldEnum = (typeof LiquidityPositionScalarFieldEnum)[keyof typeof LiquidityPositionScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  account?: Prisma.AccountOmit
  session?: Prisma.SessionOmit
  verificationToken?: Prisma.VerificationTokenOmit
  organization?: Prisma.OrganizationOmit
  financialAccount?: Prisma.FinancialAccountOmit
  transaction?: Prisma.TransactionOmit
  receipt?: Prisma.ReceiptOmit
  chatChannel?: Prisma.ChatChannelOmit
  chatMessage?: Prisma.ChatMessageOmit
  userSettings?: Prisma.UserSettingsOmit
  wallet?: Prisma.WalletOmit
  walletToken?: Prisma.WalletTokenOmit
  walletTransaction?: Prisma.WalletTransactionOmit
  aISuggestion?: Prisma.AISuggestionOmit
  savedReport?: Prisma.SavedReportOmit
  corporateEntity?: Prisma.CorporateEntityOmit
  invoice?: Prisma.InvoiceOmit
  invoiceVersion?: Prisma.InvoiceVersionOmit
  invoiceAccountingEvent?: Prisma.InvoiceAccountingEventOmit
  invoicePayment?: Prisma.InvoicePaymentOmit
  order?: Prisma.OrderOmit
  archiveRecord?: Prisma.ArchiveRecordOmit
  archiveLink?: Prisma.ArchiveLinkOmit
  archiveVersion?: Prisma.ArchiveVersionOmit
  archiveAccessLog?: Prisma.ArchiveAccessLogOmit
  archiveRetentionPolicy?: Prisma.ArchiveRetentionPolicyOmit
  archiveExport?: Prisma.ArchiveExportOmit
  archiveImportBatch?: Prisma.ArchiveImportBatchOmit
  archiveAutomationRule?: Prisma.ArchiveAutomationRuleOmit
  archiveException?: Prisma.ArchiveExceptionOmit
  archiveSavedView?: Prisma.ArchiveSavedViewOmit
  liability?: Prisma.LiabilityOmit
  liabilityEvent?: Prisma.LiabilityEventOmit
  liabilityPayment?: Prisma.LiabilityPaymentOmit
  liabilitySettlement?: Prisma.LiabilitySettlementOmit
  liabilityAccrual?: Prisma.LiabilityAccrualOmit
  liabilityCovenantCheck?: Prisma.LiabilityCovenantCheckOmit
  liabilityImportBatch?: Prisma.LiabilityImportBatchOmit
  liabilityAutomationRule?: Prisma.LiabilityAutomationRuleOmit
  liabilityException?: Prisma.LiabilityExceptionOmit
  liabilitySavedView?: Prisma.LiabilitySavedViewOmit
  inventoryItem?: Prisma.InventoryItemOmit
  inventoryMovement?: Prisma.InventoryMovementOmit
  inventoryBatch?: Prisma.InventoryBatchOmit
  receivable?: Prisma.ReceivableOmit
  receivablePayment?: Prisma.ReceivablePaymentOmit
  receivableEvent?: Prisma.ReceivableEventOmit
  treasuryAccount?: Prisma.TreasuryAccountOmit
  capitalBucket?: Prisma.CapitalBucketOmit
  creditFacility?: Prisma.CreditFacilityOmit
  facilityDrawdown?: Prisma.FacilityDrawdownOmit
  treasuryDecision?: Prisma.TreasuryDecisionOmit
  treasuryScenario?: Prisma.TreasuryScenarioOmit
  treasuryCashMovement?: Prisma.TreasuryCashMovementOmit
  nettingOpportunity?: Prisma.NettingOpportunityOmit
  asset?: Prisma.AssetOmit
  assetDepreciation?: Prisma.AssetDepreciationOmit
  assetEvent?: Prisma.AssetEventOmit
  assetTransfer?: Prisma.AssetTransferOmit
  assetDisposal?: Prisma.AssetDisposalOmit
  capExBudget?: Prisma.CapExBudgetOmit
  capExItem?: Prisma.CapExItemOmit
  costCenter?: Prisma.CostCenterOmit
  project?: Prisma.ProjectOmit
  projectMilestone?: Prisma.ProjectMilestoneOmit
  timeEntry?: Prisma.TimeEntryOmit
  internalChargeback?: Prisma.InternalChargebackOmit
  accountingPeriod?: Prisma.AccountingPeriodOmit
  closeChecklistItem?: Prisma.CloseChecklistItemOmit
  periodMissingItem?: Prisma.PeriodMissingItemOmit
  periodAdjustment?: Prisma.PeriodAdjustmentOmit
  periodAuditEntry?: Prisma.PeriodAuditEntryOmit
  customer?: Prisma.CustomerOmit
  customerContact?: Prisma.CustomerContactOmit
  customerPayment?: Prisma.CustomerPaymentOmit
  customerCreditEvent?: Prisma.CustomerCreditEventOmit
  customerRevenue?: Prisma.CustomerRevenueOmit
  customerRiskIndicator?: Prisma.CustomerRiskIndicatorOmit
  supplier?: Prisma.SupplierOmit
  supplierContact?: Prisma.SupplierContactOmit
  supplierBalance?: Prisma.SupplierBalanceOmit
  supplierPayment?: Prisma.SupplierPaymentOmit
  supplierReliability?: Prisma.SupplierReliabilityOmit
  supplierSpend?: Prisma.SupplierSpendOmit
  supplierRisk?: Prisma.SupplierRiskOmit
  nettingAgreement?: Prisma.NettingAgreementOmit
  nettingParty?: Prisma.NettingPartyOmit
  nettingSession?: Prisma.NettingSessionOmit
  nettingPosition?: Prisma.NettingPositionOmit
  nettingTransaction?: Prisma.NettingTransactionOmit
  settlementInstruction?: Prisma.SettlementInstructionOmit
  offsetEntry?: Prisma.OffsetEntryOmit
  offer?: Prisma.OfferOmit
  offerVersion?: Prisma.OfferVersionOmit
  offerAuditLog?: Prisma.OfferAuditLogOmit
  offerTemplate?: Prisma.OfferTemplateOmit
  task?: Prisma.TaskOmit
  taskAssignee?: Prisma.TaskAssigneeOmit
  taskWatcher?: Prisma.TaskWatcherOmit
  taskTag?: Prisma.TaskTagOmit
  taskTagLink?: Prisma.TaskTagLinkOmit
  taskDependency?: Prisma.TaskDependencyOmit
  taskComment?: Prisma.TaskCommentOmit
  taskActivity?: Prisma.TaskActivityOmit
  taskAttachment?: Prisma.TaskAttachmentOmit
  risk?: Prisma.RiskOmit
  riskMitigationStep?: Prisma.RiskMitigationStepOmit
  taskRiskLink?: Prisma.TaskRiskLinkOmit
  riskComment?: Prisma.RiskCommentOmit
  riskActivity?: Prisma.RiskActivityOmit
  taskNotification?: Prisma.TaskNotificationOmit
  savedTaskFilter?: Prisma.SavedTaskFilterOmit
  revenueForecast?: Prisma.RevenueForecastOmit
  revenueLineItem?: Prisma.RevenueLineItemOmit
  costForecast?: Prisma.CostForecastOmit
  costLineItem?: Prisma.CostLineItemOmit
  cashForecast?: Prisma.CashForecastOmit
  cashForecastPeriod?: Prisma.CashForecastPeriodOmit
  forecastScenario?: Prisma.ForecastScenarioOmit
  forecastAssumption?: Prisma.ForecastAssumptionOmit
  forecastAlert?: Prisma.ForecastAlertOmit
  forecastAnnotation?: Prisma.ForecastAnnotationOmit
  forecastVariance?: Prisma.ForecastVarianceOmit
  scenario?: Prisma.ScenarioOmit
  scenarioAssumption?: Prisma.ScenarioAssumptionOmit
  stressTest?: Prisma.StressTestOmit
  simulationState?: Prisma.SimulationStateOmit
  scenarioComment?: Prisma.ScenarioCommentOmit
  scenarioDecision?: Prisma.ScenarioDecisionOmit
  scenarioChangeEvent?: Prisma.ScenarioChangeEventOmit
  kPI?: Prisma.KPIOmit
  kPIHistory?: Prisma.KPIHistoryOmit
  kPIAlert?: Prisma.KPIAlertOmit
  kPITarget?: Prisma.KPITargetOmit
  kPIBenchmark?: Prisma.KPIBenchmarkOmit
  fXRate?: Prisma.FXRateOmit
  fXExposure?: Prisma.FXExposureOmit
  fXConversion?: Prisma.FXConversionOmit
  fXScenario?: Prisma.FXScenarioOmit
  fXForecast?: Prisma.FXForecastOmit
  fXCost?: Prisma.FXCostOmit
  fXRiskIndicator?: Prisma.FXRiskIndicatorOmit
  fXAuditLog?: Prisma.FXAuditLogOmit
  investorSnapshot?: Prisma.InvestorSnapshotOmit
  boardReport?: Prisma.BoardReportOmit
  runwayProjection?: Prisma.RunwayProjectionOmit
  investorAccessLog?: Prisma.InvestorAccessLogOmit
  cashflowItem?: Prisma.CashflowItemOmit
  liquidityScenario?: Prisma.LiquidityScenarioOmit
  liquidityGap?: Prisma.LiquidityGapOmit
  liquidityRiskSignal?: Prisma.LiquidityRiskSignalOmit
  liquidityAuditLog?: Prisma.LiquidityAuditLogOmit
  liquidityPosition?: Prisma.LiquidityPositionOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

